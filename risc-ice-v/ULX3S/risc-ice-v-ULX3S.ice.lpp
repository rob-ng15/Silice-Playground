// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface dualbram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface dualbram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// simple dual port BRAM

interface simple_dualbram_port0 {
  output! addr0,
  input   rdata0,
}

interface simple_dualbram_port1 {
  output! addr1,
  output! wenable1,
  output! wdata1,
}

interface bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----


// HDMI + UART + SDCARD + SDRAM Driver Includes
// SL 2020-09-05
// Silice HDMI driver
//
// 640x480, 250MHz TMDS from 25MHz pixel clock
//
// Currently limited to the ULX3S, but should be relatively easy to port,
// pending pll and differential serial output primitives
//
// See also
// - https://www.digikey.com/eewiki/pages/viewpage.action?pageId=36569119
// - https://www.fpga4fun.com/HDMI.html
// - https://github.com/lawrie/ulx3s_examples/blob/master/hdmi/tmds_encoder.v
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//
//  A copy of the license full text is included in
//  the distribution, please refer to it for details.

import('hdmi_clock.v')
import('differential_pair.v')
import('hdmi_differential_pairs.v')

// ----------------------------------------------------

algorithm tmds_encoder(
  input   uint8  data,
  input   uint2  ctrl,
  input   uint1  data_or_ctrl,
  output  uint10 tmds
) <autorun> {

  uint9 q_m             = 0;
  int5  dc_bias         = 0;

  // tracks 'number on ones' in input
  uint4 num_ones        := data[0,1] + data[1,1] + data[2,1] + data[3,1]
                         + data[4,1] + data[5,1] + data[6,1] + data[7,1];
  // tracks 'numbers of ones minus number of zeros' in internal byte
  int5  diff_ones_zeros := q_m[0,1] + q_m[1,1] + q_m[2,1] + q_m[3,1]
                         + q_m[4,1] + q_m[5,1] + q_m[6,1] + q_m[7,1] - 6d4;

  // XOR chain on input
  int1  xored1          := data[1,1] ^ data[0,1];
  int1  xored2          := data[2,1] ^ xored1;
  int1  xored3          := data[3,1] ^ xored2;
  int1  xored4          := data[4,1] ^ xored3;
  int1  xored5          := data[5,1] ^ xored4;
  int1  xored6          := data[6,1] ^ xored5;
  int1  xored7          := data[7,1] ^ xored6;

  // XNOR chain on input
  int1  xnored1         := ~(data[1,1] ^ data[0,1]);
  int1  xnored2         := ~(data[2,1] ^ xnored1);
  int1  xnored3         := ~(data[3,1] ^ xnored2);
  int1  xnored4         := ~(data[4,1] ^ xnored3);
  int1  xnored5         := ~(data[5,1] ^ xnored4);
  int1  xnored6         := ~(data[6,1] ^ xnored5);
  int1  xnored7         := ~(data[7,1] ^ xnored6);

  always {
    // choice of encoding scheme (xor / xnor)
    if ((num_ones > 4) || (num_ones == 4 && data[0,1] == 0)) {
      q_m = { 1b0 , {xnored7,xnored6,xnored5,xnored4,xnored3,xnored2,xnored1} , data[0,1] };
    } else {
      q_m = { 1b1 , {xored7,xored6,xored5,xored4,xored3,xored2,xored1} , data[0,1] };
    }
    if (data_or_ctrl) {
      // output data
      if (dc_bias == 0 || diff_ones_zeros == 0) {
        tmds      = {~q_m[8,1] , q_m[8,1], (q_m[8,1] ? q_m[0,8] : ~q_m[0,8])};
        if (q_m[8,1] == 0) {
          dc_bias = dc_bias - diff_ones_zeros;
        } else {
          dc_bias = dc_bias + diff_ones_zeros;
        }
      } else {
        if (  (dc_bias > 0 && diff_ones_zeros > 0)
           || (dc_bias < 0 && diff_ones_zeros < 0) ) {
          tmds    = {1b1, q_m[8,1], ~q_m[0,8] };
          dc_bias = dc_bias + q_m[8,1] - diff_ones_zeros;
        } else {
          tmds    = {1b0,q_m};
          dc_bias = dc_bias - (~q_m[8,1]) + diff_ones_zeros;
        }
      }
    } else {
      // output control
      switch (ctrl) {
        case 2b00: { tmds = 10b1101010100; }
        case 2b01: { tmds = 10b0010101011; }
        case 2b10: { tmds = 10b0101010100; }
        case 2b11: { tmds = 10b1010101011; }
      }
      dc_bias = 0;
    }
  }

}

// ----------------------------------------------------

algorithm hdmi_ddr_shifter(
  input   uint10 data_r,
  input   uint10 data_g,
  input   uint10 data_b,
  output  uint8  p_outbits,
  output  uint8  n_outbits,
) <autorun> {
  uint3  mod5    = 0;
  uint10 shift_r = 0;
  uint10 shift_g = 0;
  uint10 shift_b = 0;
  uint2  clkbits = 0;
  always {
    shift_r   = (mod5 == 0) ?  data_r : shift_r[2,8];
    shift_g   = (mod5 == 0) ?  data_g : shift_g[2,8];
    shift_b   = (mod5 == 0) ?  data_b : shift_b[2,8];
    clkbits   = (mod5[0,2] < 2) ? 2b11 : ( (mod5 > 2) ? 2b00 : 2b01 );
    p_outbits = { clkbits , shift_b[0,2] , shift_g[0,2] , shift_r[0,2] };
    n_outbits = {~clkbits ,~shift_b[0,2] ,~shift_g[0,2] ,~shift_r[0,2] };
    mod5      = (mod5 == 4) ? 0 : (mod5 + 1);
  }
}

// ----------------------------------------------------

// Expects to run at 25 MHz (hdmi pixel clock)
algorithm hdmi(
  output  uint10 x,
  output  uint10 y,
  output  uint1  active,
  output  uint1  vblank,
  output! uint4  gpdi_dp,
  output! uint4  gpdi_dn,
  input   uint8  red,
  input   uint8  green,
  input   uint8  blue,
) <autorun> {

  uint10 cntx  = 0;
  uint10 cnty  = 0;

  uint1  hsync = 0;
  uint1  vsync = 0;

  // pll for tmds
  uint1  half_hdmi_clk = uninitialized;
  hdmi_clock pll(
    clk      <: clock,              //  25 MHz
    half_hdmi_clk :> half_hdmi_clk, // 125 MHz (half 250MHz HDMI, double data rate output)
  );

  uint2  null_ctrl  = 0;
  uint2  sync_ctrl  = 0;
  uint10 tmds_red   = 0;
  uint10 tmds_green = 0;
  uint10 tmds_blue  = 0;

  uint8  latch_red   = 0;
  uint8  latch_green = 0;
  uint8  latch_blue  = 0;
  uint2  prev_sync_ctrl = 0;
  uint1  prev_active    = 0;

  // encoders
  // => we use <:: to bind values from cycle start (ignoring changes during current cycle)
  tmds_encoder tmdsR(
    data        <:: latch_red,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_red
  );
  tmds_encoder tmdsG(
    data        <:: latch_green,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_green
  );
  tmds_encoder tmdsB(
    data        <:: latch_blue,
    ctrl        <:: prev_sync_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_blue
  );

  // shifter
  uint8 crgb_pos = 0;
  uint8 crgb_neg = 0;
  hdmi_ddr_shifter shift<@half_hdmi_clk>(
    data_r  <: tmds_red,
    data_g  <: tmds_green,
    data_b  <: tmds_blue,
    p_outbits :> crgb_pos,
    n_outbits :> crgb_neg,
  );

  hdmi_differential_pairs hdmi_out(
    clock   <: half_hdmi_clk,
    pos     <: crgb_pos,
    neg     <: crgb_neg,
    out_pos :> gpdi_dp,
    out_neg :> gpdi_dn );

  always {

    // record previous state of sync_ctrl and active,
    // we receive the r,b,g value for the x,y set below with a one cycle latency
    // these are then latched for the following cycle
    // thus we have to delay corresponding sync and active two cycles
    prev_sync_ctrl = sync_ctrl;
    prev_active    = active;

    // synchronization bits
    hsync          = (cntx > 655) && (cntx < 752);
    vsync          = (cnty > 489) && (cnty < 492);
    sync_ctrl      = {vsync,hsync};
    // output active area
    active         = (cntx < 640) && (cnty < 480);
    // output vblank
    vblank         = (cnty >= 480);
    // output x,y
    x              = (cntx < 640) ? cntx : 0;
    y              = (cnty >= 480) ? 0 : cnty;
    // => we will get color result on next cycle

    // update coordinates
    cnty        = (cntx == 799) ? (cnty == 524 ? 0 : (cnty + 1)) : cnty;
    cntx        = (cntx == 799) ? 0 : (cntx + 1);

    // latch r,b,g received at this cycle, for previous coord
    // will be fed into HDMI encoders next cycle
    latch_red   = red;
    latch_green = green;
    latch_blue  = blue;

  }
}

// ----------------------------------------------------

// @sylefeb, 2020-10-08, simple UART in Silice
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

// UART config



// sender

// -> interface

group uart_out
{
  uint8 data_in = 0,
  uint1 data_in_ready = 0,
  uint1 busy = 0,
}

interface io_uart_out
{
  input  data_in,
  input  data_in_ready,
  output busy,
}

// -> algorithm

algorithm uart_sender(
  io_uart_out  io,
  output uint1 uart_tx
) <autorun> {
  
  uint10 interval      = 217;
  uint10 counter       = 0;

  uint11 transmit      = 0;

  always {    

    if (transmit > 1) {
      // keep transmitting
      if (counter == 0) {
        // keep going
        uart_tx  = transmit[0,1];
        transmit = {1b0,transmit[1,10]}; // goes to zero when done
      }
      counter = (counter == interval) ? 0 : (counter + 1);
    } else {
      // done
      uart_tx = 1;
      io.busy = 0;
      if (io.data_in_ready) {
        // start transmitting
        io.busy  = 1;
        transmit = {1b1,1b0,io.data_in,1b0};
      }
    }
  }

  uart_tx = 1;

}

// receiver

// -> interface

group uart_in
{
  uint8 data_out = 0,
  uint1 data_out_ready = 0,
}

interface io_uart_in
{
  output data_out,
  output data_out_ready,
}

// -> algorithm

algorithm uart_receiver(
  io_uart_in  io,
  input uint1 uart_rx
) <autorun> {
  
  uint10 interval      = 217;
  uint10 half_interval = 109;
  uint10 counter       = 0;

  uint4  receiving     = 0;
  uint10 received      = 0;

  uint1  latched_rx    = 0;

  always {     

    io.data_out_ready = 0; // maintain low

    if (receiving == 0) {
      if (latched_rx == 0) {
        // start receiving
        receiving = 10; // expecting 10 bits: start - data x8 - stop
        received  =  0;
        counter   = half_interval; // wait half-period
      }
    } else {
      if (counter == 0) { // right in the middle
        received  = {latched_rx,received[1,9]}; // read uart rx
        receiving = receiving - 1;
        counter   = interval;
        if (receiving == 0) {
          // done
          io.data_out       = received[1,8];
          io.data_out_ready = 1;
        }
      } else {
        counter   = counter - 1;
      }
    }

    latched_rx = uart_rx;

  }

}

// SL @sylefeb 2020-08
//
// Simple SDcard controller
// only supports SDHC/SDXC
//
// Stays in slow xfer mode
//
// Timings for   25 MHz
// Tested ok at  50 MHz
// Tested ok at 100 MHz
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

group sdcardio {
  uint32 addr_sector = 0,
  uint1  read_sector = 0,
  uint1  ready       = 0,
}

interface sdcardio_ctrl {
  input!  addr_sector,
  input!  read_sector,
  output  ready,
}

algorithm sdcard(
  output  uint1  sd_clk,
  output  uint1  sd_mosi,
  output  uint1  sd_csn,
  input   uint1  sd_miso,
  // read io
  sdcardio_ctrl  io,
  // storage
  simple_dualbram_port1 store
) <autorun> {
  
  // assert(sizeof(io.addr_sector) == 32);
  
  subroutine send(
    input  uint48   cmd,
    readwrites      sd_clk,
    writes          sd_mosi
  ) {
    uint16 count = 0;
    uint48 shift = uninitialized;
    shift        = cmd;
    while (count < 24576) { // 48 clock pulses @~400 kHz (assumes 50 MHz clock)
      if ((count&255) == 255) {      
        sd_clk  = ~sd_clk;
        if (!sd_clk) {
          sd_mosi = shift[47,1];
          shift   = {shift[0,47],1b0};
        }
      }
      count = count + 1;
    }
    sd_mosi = 1;
  }
  
  subroutine read(
    input  uint6    len,
    input  uint1    wait,
    output uint40   answer,
    input  uint8    rate,
    readwrites      sd_clk,
    writes          sd_mosi,
    reads           sd_miso
  ) {  
    uint16 count = 0;
    uint6  n     = 0;
    answer       = 40hffffffffff;
    while ( // will only stop on sd_clk == 0
      (wait && answer[len-1,1]) || ((!wait) && n < len)
    ) { // read answer
      if ((count&rate) == rate) { // swap clock
        sd_clk  = ~sd_clk;
        if (!sd_clk) {
          n       = n + 1;
          answer  = {answer[0,39],sd_miso};
        }
      }
      count = count + 1;      
    }
  }
  
  uint24 count  = 0;
  uint40 status = 0;
  uint48 cmd0   = 48b010000000000000000000000000000000000000010010101;
  uint48 cmd8   = 48b010010000000000000000000000000011010101010000111;
  uint48 cmd55  = 48b011101110000000000000000000000000000000000000001;
  uint48 acmd41 = 48b011010010100000000000000000000000000000000000001;
  uint48 cmd16  = 48b010100000000000000000000000000100000000000010101;
  uint48 cmd17  = 48b010100010000000000000000000000000000000001010101;
  //                 01ccccccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrr1
  
  uint1  do_read_sector = 0;
  uint32 do_addr_sector = 0;
  
  store.wenable1 := 1; // writes
  
  always {
    
    if (io.read_sector) {
      do_read_sector = 1;
      do_addr_sector = io.addr_sector;
      io.ready = 0;
    }

  }
  
  sd_mosi = 1;
  sd_csn  = 1;
  sd_clk  = 0;

  // wait 2 msec (power up), @50 MHz
  count = 0;
  while (count < 100000) { count = count + 1; }
  
  // request SPI mode  
  count   = 0;
  while (count < 40960) { // 74+ clock pulses @~400 kHz (assumes 50 MHz clock)
    if ((count&255) == 255) {
      sd_clk = ~sd_clk;
    }
    count = count + 1;
  }

  sd_csn         = 0; 
  store.addr1    = 0;
  
  // init
  () <- send <- (cmd0);
  (status) <- read <- (8,1,255);
  
  () <- send <- (cmd8);
  (status) <- read <- (40,1,255);

  while (1) {
    () <- send <- (cmd55);
    (status) <- read <- (8,1,255);
    () <- send <- (acmd41);
    (status) <- read <- (8,1,255);
    if (status[0,8] == 0) {
      break;
    }
  }

  () <- send <- (cmd16);
  (status) <- read <- (8,1,255);

  io.ready = 1;  
  
  // ready to work
  while (1) {
    
    if (do_read_sector) {
      do_read_sector = 0;

      // read some!
      () <- send <- ({cmd17[40,8],do_addr_sector,cmd17[0,8]});

      (status) <- read <- (8,1,3); // response

      if (status[0,8] == 8h00) {
        (status) <- read <- (1,1,3); // start token
        
        store.addr1 = 0;
        (store.wdata1) <- read <- (8,0,3); // bytes  
        while (store.addr1 < 511) {
          (store.wdata1) <- read <- (8,0,3); // bytes          
          store.addr1 = store.addr1 + 1;
        }        
        (status) <- read <- (16,1,3); // CRC
        
        io.ready = 1;

      } else {
      
        io.ready = 1;

      }
    }
    
  }
  
}

// ------------------------- 

// -----------------------------------------------------------
// @sylefeb A SDRAM controller in Silice
//
// writes single bytes
// reads bursts of 8 x 16 bits
//
// Expects a 16 bits wide SDRAM interface

// AS4C32M16SB (e.g. some ULX3S)
// 4 banks, 8192 rows, 1024 columns, 16 bits words
// ============== addr ================================
//   25 24 | 23 -------- 11 | 10 ----- 1 | 0
//   bank  |     row        |   column   | byte (H/L)
// ====================================================

// IS42S16160G (e.g. some ULX3S)
// 4 banks, 8192 rows,  512 columns, 16 bits words
// ============== addr ================================
//   25 24 | 22 -------- 10 |  9 ----- 1 | 0
//   bank  |     row        |   column   | byte (H/L)
// ====================================================

// AS4C16M16SA (.e.g some MiSTer SDRAM)
// 4 banks, 8192 rows,  512 columns, 16 bits words
// ============== addr ================================
//   25 24 | 22 -------- 10 |  9 ----- 1 | 0
//   bank  |     row        |   column   | byte (H/L)
// ====================================================

//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.


import('inout16_set.v')

import('inout16_ff_ulx3s.v')
import('out1_ff_ulx3s.v')
import('out2_ff_ulx3s.v')
import('out13_ff_ulx3s.v')



// -----------------------------------------------------------

// SDRAM, raw data exchange (1 byte write, 16 bytes read)
group sdram_raw_io
{
  uint26  addr       = 0,  // addressable bytes (internally deals with 16 bits wide sdram)
  uint1   rw         = 0,
  uint8   data_in    = 0,  //   8 bits write
  uint128 data_out   = 0,  // 128 bits read (8x burst of 16 bits)
  uint1   busy       = 1,
  uint1   in_valid   = 0,
  uint1   out_valid  = 0
}

// SDRAM, byte data exchange
// emulates a simple byte rw interface
// reads are cached (burst length)

group sdram_byte_io
{
  uint26  addr       = 0,  // addressable bytes
  uint1   rw         = 0,
  uint8   data_in    = 0,  // write byte
  uint8   data_out   = 0,  // read byte
  uint1   busy       = 1,
  uint1   in_valid   = 0,
  uint1   out_valid  = 0
}

// => NOTE how sdram_raw_io and sdram_byte_io are compatible in terms of named members
//         this allows using the same interface for both

// Interfaces

// interface for user
interface sdram_user {
  output  addr,
  output  rw,
  output  data_in,
  output  in_valid,
  input   data_out,
  input   busy,
  input   out_valid,
}

// interface for provider
interface sdram_provider {
  input   addr,
  input   rw,
  input   data_in,
  output  data_out,
  output  busy,
  input   in_valid,
  output  out_valid
}

// -----------------------------------------------------------

circuitry command(
  output sdram_cs,output sdram_ras,output sdram_cas,output sdram_we,input cmd)
{
  sdram_cs  = cmd[3,1];
  sdram_ras = cmd[2,1];
  sdram_cas = cmd[1,1];
  sdram_we  = cmd[0,1];
}

// -----------------------------------------------------------

algorithm sdram_controller(
        // sdram pins
        // => we use immediate (combinational) outputs as these are registered 
        //    explicitely using dedicqted primitives when available / implemented
        output! uint1   sdram_cle,
        output! uint1   sdram_cs,
        output! uint1   sdram_cas,
        output! uint1   sdram_ras,
        output! uint1   sdram_we,
        output! uint2   sdram_dqm,
        output! uint2   sdram_ba,
        output! uint13  sdram_a,
        // data bus
        inout   uint16  sdram_dq,
        // interface
        sdram_provider sd,
) <autorun>
{

  // SDRAM commands
  uint4 CMD_UNSELECTED    = 4b1000;
  uint4 CMD_NOP           = 4b0111;
  uint4 CMD_ACTIVE        = 4b0011;
  uint4 CMD_READ          = 4b0101;
  uint4 CMD_WRITE         = 4b0100;
  uint4 CMD_TERMINATE     = 4b0110;
  uint4 CMD_PRECHARGE     = 4b0010;
  uint4 CMD_REFRESH       = 4b0001;
  uint4 CMD_LOAD_MODE_REG = 4b0000;

  uint1   reg_sdram_cle = uninitialized;
  uint1   reg_sdram_cs  = uninitialized;
  uint1   reg_sdram_cas = uninitialized;
  uint1   reg_sdram_ras = uninitialized;
  uint1   reg_sdram_we  = uninitialized;
  uint2   reg_sdram_dqm = uninitialized;
  uint2   reg_sdram_ba  = uninitialized;
  uint13  reg_sdram_a   = uninitialized;
  uint16  reg_dq_o      = 0;
  uint1   reg_dq_en     = 0;



  uint16 dq_i      = 0;


  inout16_ff_ulx3s ioset(
    clock           <:  clock,
    io_pin          <:> sdram_dq,
    io_write        <:: reg_dq_o,
    io_read         :>  dq_i,
    io_write_enable <:: reg_dq_en
  );

  out1_ff_ulx3s  off_sdram_cle(clock <: clock, pin :> sdram_cle, d <:: reg_sdram_cle);
  out1_ff_ulx3s  off_sdram_cs (clock <: clock, pin :> sdram_cs , d <:: reg_sdram_cs );
  out1_ff_ulx3s  off_sdram_cas(clock <: clock, pin :> sdram_cas, d <:: reg_sdram_cas);
  out1_ff_ulx3s  off_sdram_ras(clock <: clock, pin :> sdram_ras, d <:: reg_sdram_ras);
  out1_ff_ulx3s  off_sdram_we (clock <: clock, pin :> sdram_we , d <:: reg_sdram_we );
  out2_ff_ulx3s  off_sdram_dqm(clock <: clock, pin :> sdram_dqm, d <:: reg_sdram_dqm);
  out2_ff_ulx3s  off_sdram_ba (clock <: clock, pin :> sdram_ba , d <:: reg_sdram_ba );
  out13_ff_ulx3s off_sdram_a  (clock <: clock, pin :> sdram_a  , d <:: reg_sdram_a  );


  uint4  cmd = 7;
  
  uint1  work_done   = 0;

  uint1  work_todo   = 0;
  uint13 row         = 0;
  uint2  bank        = 0;
  uint10 col         = 0;
  uint8  data        = 0;
  uint1  do_rw       = 0;
  uint1  byte        = 0;


  uint10 refresh_count = 750;
  
  // wait for incount cycles, incount >= 3
  subroutine wait(input uint16 incount)
  {
    // NOTE: waits 3 more than incount
    // +1 for sub entry,
    // +1 for sub exit,
    // +1 for proper loop length
    uint16 count = uninitialized;
    count = incount;
    while (count > 0) {
      count = count - 1;      
    }
  }
  


  sd.out_valid := 0;
  
  always { // always block tracks in_valid
  
    cmd = CMD_NOP;
    (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
    if (sd.in_valid) {
      // -> copy inputs
      bank      = sd.addr[24, 2]; // bits 24-25
      row       = sd.addr[10, 13];
      col       = sd.addr[                      1, 9];
      byte      = sd.addr[ 0, 1];
      data      = sd.data_in;
      do_rw     = sd.rw;    
      // -> signal work to do
      work_todo = 1;
      // -> signal busy
      sd.busy     = 1;
    }
    if (work_done) {
      work_done = 0;
      sd.busy   = work_todo;
    }
  }
  
  // start busy during init
  sd.busy   = 1;

  // pre-init, wait before enabling clock
  reg_sdram_cle = 0;
  () <- wait <- (10100);
  reg_sdram_cle = 1;

  // init
  reg_sdram_a  = 0;
  reg_sdram_ba = 0;
  reg_dq_en    = 0;
  () <- wait <- (10100);
  
  // precharge all
  cmd      = CMD_PRECHARGE;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);  
  reg_sdram_a  = {2b0,1b1,10b0};
  () <- wait <- (0);
  
  // refresh 1
  cmd     = CMD_REFRESH;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);  
  () <- wait <- (4);
  
  // refresh 2
  cmd     = CMD_REFRESH;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd); 
  () <- wait <- (4);
  
  // load mod reg
  cmd      = CMD_LOAD_MODE_REG;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);  
  reg_sdram_ba = 0;
  reg_sdram_a  = {3b000, 1b1, 2b00, 3b011/*CAS*/, 1b0, 3b011 /*burst x8*/};
  () <- wait <- (0);

  reg_sdram_ba = 0;
  reg_sdram_a  = 0;
  cmd      = CMD_NOP;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);  
  refresh_count = 750;
  
  // init done
  work_done     = 1;
  
  while (1) {

    // refresh?
    if (refresh_count == 0) {

      // -> precharge all
      cmd      = CMD_PRECHARGE;
      (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);      
      reg_sdram_a  = {2b0,1b1,10b0};
      () <- wait <- (0);

      // refresh
      cmd           = CMD_REFRESH;
      (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
      // wait
      () <- wait <- (4);
      // -> reset count
      refresh_count = 750;  

    } else {

      refresh_count = refresh_count - 1;

      if (work_todo) {
        work_todo = 0;
        
        // -> activate
        reg_sdram_ba = bank;
        reg_sdram_a  = row;
        cmd          = CMD_ACTIVE;
        (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
++:
++:
        
        // write or read?
        if (do_rw) {
          // __display("<sdram: write %x>",data);
          // write
          cmd       = CMD_WRITE;
          (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
          reg_dq_en     = 1;
          reg_sdram_a   = {2b0, 1b1/*auto-precharge*/, col};
          reg_dq_o      = {data,data};
          reg_sdram_dqm = {~byte,byte};
          // can accept work
          work_done      = 1;
++:       // wait one cycle to enforce tWR
        } else {
          // read
          cmd         = CMD_READ;
          (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
          reg_dq_en       = 0;
          reg_sdram_dqm   = 2b0;
          reg_sdram_a     = {2b0, 1b1/*auto-precharge*/, col};
          // wait CAS cycles
++:
++:
++:
++: // dq_i latency
++:
          // burst 8 x 16 bytes
          {
            uint8 read_cnt = 0;
            while (read_cnt < 8) {
              sd.data_out[{read_cnt,4b0000},16] = dq_i;
              read_cnt      = read_cnt + 1;
              work_done     = (read_cnt[3,1]); // done
              sd.out_valid  = (read_cnt[3,1]); // data_out is available
            }
          }
        }
        
++: // enforce tRP
++:
++:

      } // work_todo
    } // refresh

  }
}

// -----------------------------------------------------------

// Implements a simplified byte memory interface
//
// Assumptions:
//  * !!IMPORTANT!! assumes no writes ever occur into a cached read
//  * busy     == 1 => in_valid  = 0
//  * in_valid == 1 & rw == 1 => in_valid == 0 until out_valid == 1
//
algorithm sdram_byte_readcache(
  sdram_provider sdb,
  sdram_user     sdr,
) <autorun> {

  // cached reads
  uint128 cached         = uninitialized;
  uint26  cached_addr    = 26h3FFFFFF;

  uint2   busy           = 1;
  
  always {

    // maintain busy for one clock to
    // account for one cycle latency
    // of latched outputs to chip
    sdb.busy = busy[0,1];
    if (sdr.busy == 0) {
      busy = {1b0,busy[1,1]};
    }

    if (sdb.in_valid) {
      if (sdb.rw == 0) { // reading
        if (sdb.addr[4,22] == cached_addr[4,22]) {
          // in cache!
          sdb.data_out  = cached >> {sdb.addr[0,4],3b000};
          // -> signal availability
          sdb.out_valid = 1;
          // no request
          sdr.in_valid  = 0;
        } else {
          sdb.busy      = 1;
          busy          = 2b11;
          // record addr to cache
          cached_addr   = sdb.addr;
          // issue read
          sdr.rw        = 0;
          sdr.addr      = {cached_addr[4,22],4b0000};
          sdr.in_valid  = 1;
          // no output
          sdb.out_valid = 0;
        }
      } else { // writing
        sdb.busy      = 1;
        busy          = 2b11;
        // issue write
        sdr.rw        = 1;
        sdr.addr      = sdb.addr;
        sdr.data_in   = sdb.data_in;
        sdr.in_valid  = 1; 
        // no output
        sdb.out_valid = 0;
      }
    } else {
      if (sdr.out_valid) {
        // data is available
        // -> fill cache
        cached        = sdr.data_out;
        // -> extract byte
        sdb.data_out  = cached >> {cached_addr[0,4],3b000};
        // -> signal availability
        sdb.out_valid = 1;
        // no request
        sdr.in_valid = 0;
      } else {
        // no output
        sdb.out_valid = 0;
        // no request
        sdr.in_valid  = 0;
      }
    }

  }

}

// ------------------------- 
// Three-way arbitrer for SDRAM
// sd0 has highest priority, then sd1, then sd2

algorithm sdram_switcher_3way(
  sdram_provider sd0,
  sdram_provider sd1,
  sdram_provider sd2,
  sdram_user     sd
) {

  sameas(sd0) buffered_sd0;
  sameas(sd1) buffered_sd1;
  sameas(sd2) buffered_sd2;
  
  uint2 reading   = 2b11;
  uint1 writing   = 0;
  uint3 in_valids = uninitialized;

  sd0.out_valid := 0; // pulses high when ready
  sd1.out_valid := 0; // pulses high when ready
  sd2.out_valid := 0; // pulses high when ready
  sd .in_valid  := 0; // pulses high when ready
  
  always {
    
    in_valids = {buffered_sd2.in_valid , buffered_sd1.in_valid , buffered_sd0.in_valid};

    // buffer requests
    if (buffered_sd0.in_valid == 0 && sd0.in_valid == 1) {
      buffered_sd0.addr       = sd0.addr;
      buffered_sd0.rw         = sd0.rw;
      buffered_sd0.data_in    = sd0.data_in;
      buffered_sd0.in_valid   = 1;
    }
    if (buffered_sd1.in_valid == 0 && sd1.in_valid == 1) {
      buffered_sd1.addr       = sd1.addr;
      buffered_sd1.rw         = sd1.rw;
      buffered_sd1.data_in    = sd1.data_in;
      buffered_sd1.in_valid   = 1;
    }
    if (buffered_sd2.in_valid == 0 && sd2.in_valid == 1) {
      buffered_sd2.addr       = sd2.addr;
      buffered_sd2.rw         = sd2.rw;
      buffered_sd2.data_in    = sd2.data_in;
      buffered_sd2.in_valid   = 1;
    }
    // check if read operations terminated
    switch (reading) {
    case 0 : { 
      if (sd.out_valid == 1) {
        // done
        sd0.data_out  = sd.data_out;
        sd0.out_valid = 1;
        reading       = 2b11;
        buffered_sd0.in_valid = 0;
      }
    }
    case 1 : { 
      if (sd.out_valid == 1) {
        // done
        sd1.data_out  = sd.data_out;
        sd1.out_valid = 1;
        reading       = 2b11;
        buffered_sd1.in_valid = 0;
      }
    }
    case 2 : { 
      if (sd.out_valid == 1) {
        // done
        sd2.data_out  = sd.data_out;
        sd2.out_valid = 1;
        reading       = 2b11;
        buffered_sd2.in_valid = 0;
      }
    }
    default: { 
      if (writing) { // when writing we wait on cycle before resuming, 
        writing = 0; // ensuring the sdram controler reports busy properly
      } else {
        // -> sd0 (highest priority)
        if (   sd.busy == 0
            && in_valids[0,1] == 1) {
          sd.addr     = buffered_sd0.addr;
          sd.rw       = buffered_sd0.rw;
          sd.data_in  = buffered_sd0.data_in;
          sd.in_valid = 1;
          if (buffered_sd0.rw == 0) { 
            reading               = 0; // reading, wait for answer
          } else {
            writing = 1;
            buffered_sd0.in_valid = 0; // done if writing
          }
        }
        if (   sd.busy == 0 
            && in_valids[0,1] == 0 
            && in_valids[1,1] == 1) {
          sd.addr     = buffered_sd1.addr;
          sd.rw       = buffered_sd1.rw;
          sd.data_in  = buffered_sd1.data_in;
          sd.in_valid = 1;        
          if (buffered_sd1.rw == 0) { 
            reading               = 1; // reading, wait for answer
          } else {
            writing = 1;
            buffered_sd1.in_valid = 0; // done if writing
          }
        }
        if (   sd.busy == 0 
            && in_valids[0,1] == 0
            && in_valids[1,1] == 0
            && in_valids[2,1] == 1) {
          sd.addr     = buffered_sd2.addr;
          sd.rw       = buffered_sd2.rw;
          sd.data_in  = buffered_sd2.data_in;
          sd.in_valid = 1;        
          if (buffered_sd2.rw == 0) { 
            reading               = 2; // reading, wait for answer
          } else {
            writing = 1;
            buffered_sd2.in_valid = 0; // done if writing
          }
        } 
      }
    }
    } // switch
    // interfaces are busy while their request is being processed
    sd0.busy = buffered_sd0.in_valid;
    sd1.busy = buffered_sd1.in_valid;
    sd2.busy = buffered_sd2.in_valid;
  } // always
}

// -------------------------
// wrapper for sdram from design running hafl-speed clock
// the wrapper runs full speed, the design using it half-speed
algorithm sdram_half_speed_access(
  sdram_provider sdh,
  sdram_user     sd
) <autorun> {

  sameas(sdh) buffered_sdh;
  
  uint1 reading   = 0;
  uint1 writing   = 0;
  uint1 in_valid  = uninitialized;

  uint1 half_clock = 0;
  uint2 out_valid  = 0;

  sdh.out_valid := 0; // pulses high when ready
  sd .in_valid  := 0; // pulses high when ready
  
  always {
    
    in_valid = buffered_sdh.in_valid;

    // buffer requests
    if (half_clock) { // read only on slow clock
      if (buffered_sdh.in_valid == 0 && sdh.in_valid == 1) {
        buffered_sdh.addr       = sdh.addr;
        buffered_sdh.rw         = sdh.rw;
        buffered_sdh.data_in    = sdh.data_in;
        buffered_sdh.in_valid   = 1;
      }
    }
    // update out_valid
    out_valid = out_valid >> 1;
    // check if read operations terminated
    if (reading) {
      if (sd.out_valid == 1) {
        // done
        sdh.data_out  = sd.data_out;
        out_valid     = 2b11;
        reading       = 0;
        buffered_sdh.in_valid = 0;
      }
    } else { 
      if (writing) { // when writing we wait on cycle before resuming, 
        writing = 0; // ensuring the sdram controler reports busy properly
      } else {
        if (   sd.busy == 0 && in_valid == 1  ) {
          sd.addr     = buffered_sdh.addr;
          sd.rw       = buffered_sdh.rw;
          sd.data_in  = buffered_sdh.data_in;
          sd.in_valid = 1;
          if (buffered_sdh.rw == 0) { 
            reading               = 1; // reading, wait for answer
          } else {
            writing = 1;
            buffered_sdh.in_valid = 0; // done if writing
          }
        }
      }
    } // reading
    // interface is busy while its request is being processed
    sdh.busy      = buffered_sdh.in_valid;
    // two-cycle out valid
    sdh.out_valid = out_valid[0,1];
    // half clock
    half_clock    = ~ half_clock;
  } // always

}

// -----------------------------------------------------------


// Multiplexed Display Includes
algorithm multiplex_display(
    input   uint10 pix_x,
    input   uint10 pix_y,
    input   uint1  pix_active,
    input   uint1  pix_vblank,
    output! uint8 pix_red,
    output! uint8 pix_green,
    output! uint8 pix_blue,

    // BACKGROUND
    input uint2 background_r,
    input uint2 background_g,
    input uint2 background_b,

    // TILEMAP
    input uint2 tilemap_r,
    input uint2 tilemap_g,
    input uint2 tilemap_b,
    input uint1 tilemap_display,

    // LOWER SPRITES
    input uint2 lower_sprites_r,
    input uint2 lower_sprites_g,
    input uint2 lower_sprites_b,
    input uint1 lower_sprites_display,

    // BITMAP
    input uint2 bitmap_r,
    input uint2 bitmap_g,
    input uint2 bitmap_b,
    input uint1 bitmap_display,

    // UPPER SPRITES
    input uint2 upper_sprites_r,
    input uint2 upper_sprites_g,
    input uint2 upper_sprites_b,
    input uint1 upper_sprites_display,

    // CHARACTER MAP
    input uint2 character_map_r,
    input uint2 character_map_g,
    input uint2 character_map_b,
    input uint1 character_map_display,

    // TERMINAL
    input uint2 terminal_r,
    input uint2 terminal_g,
    input uint2 terminal_b,
    input uint1 terminal_display
) <autorun> {
    // Output defaults to 0
    pix_red   := 0;
    pix_green := 0;
    pix_blue  := 0;

    // Draw the screen
    while (1) {
        // wait until pix_active THEN BACKGROUND -> TILEMAP -> LOWER SPRITES -> BITMAP -> UPPER SPRITES -> CHARACTER MAP -> TERMINAL
        if( pix_active ) {
            // Select the 2 bit r g or b and expand to 8 bit r g or b
            pix_red = ( terminal_display ) ? { {4{terminal_r}} } :
                        ( character_map_display ) ? { {4{character_map_r}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_r}} } :
                        ( bitmap_display ) ? { {4{bitmap_r}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_r}} } :
                        ( tilemap_display ) ? { {4{tilemap_r}} } :
                        { {4{background_r}} };
            pix_green = ( terminal_display ) ? { {4{terminal_g}} } :
                        ( character_map_display ) ? { {4{character_map_g}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_g}} } :
                        ( bitmap_display ) ? { {4{bitmap_g}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_g}} } :
                        ( tilemap_display ) ? { {4{tilemap_g}} } :
                        { {4{background_g}} };
            pix_blue = ( terminal_display ) ? { {4{terminal_b}} } :
                        ( character_map_display ) ? { {4{character_map_b}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_b}} } :
                        ( bitmap_display ) ? { {4{bitmap_b}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_b}} } :
                        ( tilemap_display ) ? { {4{tilemap_b}} } :
                        { {4{background_b}} };
        } // pix_active
    }
}

// Create 1hz (1 second counter, also can output the baseline 50MHz counter)
algorithm pulse1hz(
    output  uint16  counter1hz,
    input   uint1   resetCounter
) <autorun> {
    uint26  counter50mhz = 0;
    counter1hz = 0;

    while (1) {
        if( resetCounter == 1) {
            counter1hz = 0;
            counter50mhz = 0;
        } else {
            counter1hz = ( counter50mhz == 50000000 ) ? counter1hz + 1 : counter1hz;
            counter50mhz = ( counter50mhz == 50000000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// Create 1khz (1 milli-second counter)
algorithm pulse1khz(
    output  uint16  counter1khz,
    input   uint16  resetCount,
    input   uint1   resetCounter
) <autorun> {
    uint16 counter50mhz = 0;

    while (1) {
        if( resetCounter == 1 ) {
            counter1khz = resetCount;
            counter50mhz = 0;
        } else {
            counter1khz = ( counter1khz == 0 ) ? 0 : ( counter50mhz == 50000 ) ? counter1khz - 1 : counter1khz;
            counter50mhz = ( counter50mhz == 50000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// 16 bit random number generator
// Translation into Silice of LFSR_Plus.v
algorithm random(
    output  uint16  g_noise_out,
    output  uint16  u_noise_out,
    input   uint1   resetRandom
) <autorun> {
    uint16  rand_out = 0;
    uint16  rand_ff = 24b011000110111011010011101;
    uint18  rand_en_ff = 24b001100010011011101100101;
    uint16  temp_u_noise3 = 0;
    uint16  temp_u_noise2 = 0;
    uint16  temp_u_noise1 = 0;
    uint16  temp_u_noise0 = 0;
    uint16  temp_g_noise_nxt = uninitialized;

    g_noise_out := ( rand_en_ff[17,1] ) ? temp_g_noise_nxt : ( rand_en_ff[10,1] ) ? rand_out : g_noise_out;
    u_noise_out := ( rand_en_ff[17,1] ) ? rand_out : u_noise_out;

    while(1) {
        if( resetRandom ) {
            rand_en_ff = 24b001100010011011101100101;
            rand_ff = 24b011000110111011010011101;
            rand_out = 0;
            temp_u_noise3 = 0;
            temp_u_noise2 = 0;
            temp_u_noise1 = 0;
            temp_u_noise0 = 0;
            g_noise_out = 0;
            u_noise_out = 0;
        } else {
            rand_en_ff = {(rand_en_ff[7,1] ^ rand_en_ff[0,1]) , rand_en_ff[1,17]};
            rand_ff = { ( rand_ff[5,1] ^ rand_ff[3,1] ^ rand_ff[2,1] ^ rand_ff[0,1]) , rand_ff[1,15] };
            rand_out = rand_ff;
            temp_u_noise3 = { rand_out[15,1], rand_out[15,1], rand_out[2,13] };
            temp_u_noise2 = temp_u_noise3;
            temp_u_noise1 = temp_u_noise2;
            temp_u_noise0 = temp_u_noise1;
            temp_g_noise_nxt = ( rand_en_ff[9,1] ) ? __signed(temp_u_noise3) + __signed(temp_u_noise2) + __signed(temp_u_noise1) + __signed(temp_u_noise0) + __signed(g_noise_out) :
                                                    __signed(temp_u_noise3) + __signed(temp_u_noise2) + __signed(temp_u_noise1) + __signed(temp_u_noise0);
        }
    }
}

algorithm terminal(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   terminal_display,

    input   uint8   terminal_character,
    input   uint1   terminal_write,
    input   uint1   showterminal,
    input   uint1   showcursor,
    input   uint1   timer1hz,
    output  uint1   terminal_active
) <autorun> {
    // Character ROM 8x8 x 256
    brom uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // 80 x 4 character buffer for the input/output terminal
    simple_dualport_bram uint8 terminal[640] = uninitialized;
    simple_dualport_bram uint8 terminal_copy[640] = uninitialized;

    // Initial cursor position in the terminal, bottom left
    uint7 terminal_x = 0;
    uint3 terminal_y = 7;

    // Character position on the terminal x 0-79, y 0-7 * 80 ( fetch it one pixel ahead of the actual x pixel, so it is always ready )
    uint7 xterminalpos := ( pix_active ? pix_x + 2 : 0 ) >> 3;
    uint10 yterminalpos := (( pix_vblank ? 0 : pix_y - 416 ) >> 3) * 80;

    // Determine if cursor, and if cursor is flashing
    uint1 is_cursor := ( xterminalpos == terminal_x ) && ( ( ( pix_y - 416) >> 3 ) == terminal_y );

    // Derive the x and y coordinate within the current 8x8 terminal character block x 0-7, y 0-7
    uint3 xinterminal := (pix_x) & 7;
    uint3 yinterminal := (pix_y) & 7;

    // Derive the actual pixel in the current terminal
    uint1 terminalpixel := characterGenerator8x8.rdata[7 - xinterminal,1];

    // Terminal active (scroll) flag and temporary storage for scrolling
    uint10 terminal_scroll = 0;
    uint10 terminal_scroll_character = 0;

    // Setup the reading of the terminal memory
    terminal.addr0 := xterminalpos + yterminalpos;

    // Setup the writing to the terminal memory
    terminal.wenable1 := 1;
    terminal_copy.wenable1 := 1;

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr :=  terminal.rdata0 * 8 + yinterminal;

    // Default to transparent and active pixels always blue
    terminal_display := pix_active && showterminal && (pix_y > 415);
    pix_red := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_green := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_blue := 3;

    // Render the terminal
    while(1) {
        if( terminal_write ) {
            // Display character
            switch( terminal_character ) {
                case 8: {
                    // BACKSPACE, move back one character
                    if( terminal_x != 0 ) {
                        terminal_x = terminal_x - 1;
                        terminal.addr1 = terminal_x + terminal_y * 80;
                        terminal.wdata1 = 0;
                        terminal_copy.addr1 = terminal_x + terminal_y * 80;
                        terminal_copy.wdata1 = 0;
                    }
                }
                case 10: {
                    // LINE FEED, scroll
                    terminal_active = 1;
                }
                case 13: {
                    // CARRIAGE RETURN
                    terminal_x = 0;
                }
                default: {
                    // Display character
                    terminal.addr1 = terminal_x + terminal_y * 80;
                    terminal.wdata1 = terminal_character;
                    terminal_copy.addr1 = terminal_x + terminal_y * 80;
                    terminal_copy.wdata1 = terminal_character;
                    terminal_active = ( terminal_x == 79 ) ? 1 : 0;
                    terminal_x = ( terminal_x == 79 ) ? 0 : terminal_x + 1;
                }
            }
        } else {
            if( terminal_active ) {
                // SCROLL
                terminal_scroll = 0;
                ++:
                while( terminal_scroll < 560 ) {
                    // Retrieve character on the next line
                    terminal_copy.addr0 = terminal_scroll + 80;
                    ++:
                    terminal_scroll_character = terminal_copy.rdata0;
                    ++:
                    // Write retrieved character
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = terminal_scroll_character;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = terminal_scroll_character;

                    //++:
                    terminal_scroll = terminal_scroll + 1;
                }

                // BLANK LAST LINE
                while( terminal_scroll < 640 ) {
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = 0;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = 0;

                    terminal_scroll = terminal_scroll + 1;
                }

                terminal_active = 0;
            }
        }
    }
}

bitfield charactermapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint8   character
}

algorithm character_map(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   character_map_display,

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint5   tpu_y,
    input   uint8   tpu_character,
    input   uint6   tpu_foreground,
    input   uint7   tpu_background,
    input   uint3   tpu_write,

    output  uint1   tpu_active
) <autorun> {
    // Character ROM 8x16
    brom uint8 characterGenerator8x16[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h81, 8ha5, 8h81, 8h81, 8hbd, 8h99, 8h81, 8h81, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8hff, 8hdb, 8hff, 8hff, 8hc3, 8he7, 8hff, 8hff, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h6c, 8hfe, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8he7, 8he7, 8he7, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h7e, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h1e, 8h0e, 8h1a, 8h32, 8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h33, 8h3f, 8h30, 8h30, 8h30, 8h30, 8h70, 8hf0, 8he0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8h63, 8h7f, 8h63, 8h63, 8h63, 8h63, 8h67, 8he7, 8he6, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8hdb, 8h3c, 8he7, 8h3c, 8hdb, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h80, 8hc0, 8he0, 8hf0, 8hf8, 8hfe, 8hf8, 8hf0, 8he0, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h02, 8h06, 8h0e, 8h1e, 8h3e, 8hfe, 8h3e, 8h1e, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8hdb, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h1b, 8h1b, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h7c, 8hc6, 8h60, 8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h28, 8h6c, 8hfe, 8h6c, 8h28, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h38, 8h7c, 8h7c, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8h7c, 8h7c, 8h38, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h24, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h7c, 8hc6, 8hc2, 8hc0, 8h7c, 8h06, 8h06, 8h86, 8hc6, 8h7c, 8h18, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hc2, 8hc6, 8h0c, 8h18, 8h30, 8h60, 8hc6, 8h86, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h30, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h18, 8h0c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h18, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h02, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hd6, 8hd6, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h38, 8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h06, 8h3c, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h0c, 8h0c, 8h1e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hfc, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h60, 8hc0, 8hc0, 8hfc, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h06, 8h06, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h06, 8h06, 8h0c, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h0c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hde, 8hde, 8hde, 8hdc, 8hc0, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h66, 8h66, 8h66, 8h66, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf8, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hde, 8hc6, 8hc6, 8h66, 8h3a, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he6, 8h66, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf0, 8h60, 8h60, 8h60, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hde, 8h7c, 8h0c, 8h0e, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h60, 8h38, 8h0c, 8h06, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h7e, 8h5a, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8hee, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8h6c, 8h7c, 8h38, 8h38, 8h7c, 8h6c, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h86, 8h0c, 8h18, 8h30, 8h60, 8hc2, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h80, 8hc0, 8he0, 8h70, 8h38, 8h1c, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h78, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc0, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h0c, 8h0c, 8h3c, 8h6c, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h6c, 8h76, 8h66, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h06, 8h06, 8h00, 8h0e, 8h06, 8h06, 8h06, 8h06, 8h06, 8h06, 8h66, 8h66, 8h3c, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hec, 8hfe, 8hd6, 8hd6, 8hd6, 8hd6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8h0c, 8h1e, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8h60, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h30, 8h30, 8h36, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8h6c, 8h38, 8h38, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8hf8, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hcc, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h18, 8h18, 8h18, 8h70, 8h18, 8h18, 8h18, 8h18, 8h0e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h70, 8h18, 8h18, 8h18, 8h0e, 8h18, 8h18, 8h18, 8h18, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h0c, 8h06, 8h7c, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h38, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h60, 8h60, 8h66, 8h3c, 8h0c, 8h06, 8h3c, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h66, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h38, 8h6c, 8h38, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h00, 8hfe, 8h66, 8h60, 8h7c, 8h60, 8h60, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8h76, 8h36, 8h7e, 8hd8, 8hd8, 8h6e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3e, 8h6c, 8hcc, 8hcc, 8hfe, 8hcc, 8hcc, 8hcc, 8hcc, 8hce, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8h78, 8h00,
    8h00, 8hc6, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h18, 8h3c, 8h66, 8h60, 8h60, 8h60, 8h66, 8h3c, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8he6, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hf8, 8hcc, 8hcc, 8hf8, 8hc4, 8hcc, 8hde, 8hcc, 8hcc, 8hcc, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0e, 8h1b, 8h18, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8h70, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h76, 8hdc, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h30, 8h00, 8h30, 8h30, 8h60, 8hc0, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8h06, 8h06, 8h06, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h60, 8hdc, 8h86, 8h0c, 8h18, 8h3e, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hce, 8h9e, 8h3e, 8h06, 8h06, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h36, 8h6c, 8hd8, 8h6c, 8h36, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hd8, 8h6c, 8h36, 8h6c, 8hd8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8hd8, 8hd8, 8hd8, 8hdc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8hd8, 8hcc, 8hc6, 8hc6, 8hc6, 8hcc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8hc6, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfe, 8hc6, 8h60, 8h30, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7e, 8h18, 8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h6c, 8h6c, 8h6c, 8hee, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h30, 8h18, 8h0c, 8h3e, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hdb, 8hdb, 8hdb, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h03, 8h06, 8h7e, 8hdb, 8hdb, 8hf3, 8h7e, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h30, 8h60, 8h60, 8h7c, 8h60, 8h60, 8h60, 8h30, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h7e, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0f, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h6c, 8h3c, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hd8, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h70, 8hd8, 8h30, 8h60, 8hc8, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00


    };

    // 80 x 30 character buffer
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint21 charactermap[2400] = { 21b100000000000000000000, pad(21b100000000000000000000) };

    // Character position on the screen x 0-79, y 0-29 * 80 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    uint8 xcharacterpos := ( pix_active ?  pix_x + 2 : 0 ) >> 3;
    uint12 ycharacterpos := (( pix_vblank ? 0 : pix_y ) >> 4) * 80;

    // Derive the x and y coordinate within the current 8x16 character block x 0-7, y 0-15
    uint3 xincharacter := (pix_x) & 7;
    uint4 yincharacter := (pix_y) & 15;

    // Derive the actual pixel in the current character
    uint1 characterpixel := characterGenerator8x16.rdata[7 - xincharacter,1];

    // TPU character position
    uint7 tpu_active_x = 0;
    uint5 tpu_active_y = 0;

    // CS Counter
    uint12  tpu_cs_addr = uninitialized;

    // Set up reading of the charactermap
    charactermap.addr0 := xcharacterpos + ycharacterpos;

    // BRAM write access for the TPU
    charactermap.wenable1 := 1;

    // Setup the reading of the characterGenerator8x16 ROM
    characterGenerator8x16.addr :=  charactermapentry(charactermap.rdata0).character * 16 + yincharacter;

    // RENDER - Default to transparent
    character_map_display := pix_active && (( characterpixel ) || ( ~charactermapentry(charactermap.rdata0).alpha ));
    pix_red := characterpixel ? charactermap.rdata0[12,2] : charactermap.rdata0[18,2];
    pix_green := characterpixel ? charactermap.rdata0[10,2] : charactermap.rdata0[16,2];
    pix_blue := characterpixel ? charactermap.rdata0[8,2] : charactermap.rdata0[14,2];

    // Default to 0,0 and transparent
    charactermap.addr1 = 0; charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };

    while(1) {
        switch( tpu_active ) {
            case 0: {
                switch( tpu_write ) {
                    case 1: {
                        // Set cursor position
                        tpu_active_x = tpu_x;
                        tpu_active_y = tpu_y;
                    }
                    case 2: {
                        // Write character,foreground, background to current cursor position and move onto next character position
                        charactermap.addr1 = tpu_active_x + tpu_active_y * 80;
                        charactermap.wdata1 = { tpu_background, tpu_foreground, tpu_character };

                        tpu_active_y = ( tpu_active_x == 79 ) ? ( tpu_active_y == 29 ) ? 0 : tpu_active_y + 1 : tpu_active_y;
                        tpu_active_x = ( tpu_active_x == 79 ) ? 0 : tpu_active_x + 1;
                    }
                    case 3: {
                        // Start tpucs!
                        tpu_active_x = 0;
                        tpu_active_y = 0;
                        tpu_active = 1;
                        tpu_cs_addr = 0;
                        charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };
                    }
                }
            }

            // TPU CS
            case 1: {
                while( tpu_cs_addr < 2400 ) {
                    charactermap.addr1 = tpu_cs_addr;
                    tpu_cs_addr = tpu_cs_addr + 1;
                }
                ++:
                tpu_active = 0;
            }
        }
    }
}

algorithm bitmap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   bitmap_display,

    // Hardware scrolling
    input   uint3   bitmap_write_offset,
    output  uint10  x_offset,
    output  uint10  y_offset,

    // Pixel reader
    input   int16   bitmap_x_read,
    input   int16   bitmap_y_read,
    output  uint7   bitmap_colour_read,

    simple_dualbram_port0 bitmap
) <autorun> {
    // Pixel x and y fetching ( adjusting for offset )
    uint10  x_plus_one := ( pix_x + x_offset + 1 ) > 639 ? ( pix_x + x_offset + 1 ) - 639 : ( pix_x + x_offset + 1 );
    uint10  y_line := pix_vblank ? y_offset : ( ( pix_y + y_offset ) > 479 ? ( pix_y + y_offset ) - 479 : ( pix_y + y_offset ) );
    uint10  x_pixel := pix_active ? x_plus_one : x_offset;

    // Pixel being read?
    bitmap_colour_read := ( pix_x == bitmap_x_read ) && ( pix_y == bitmap_y_read ) ? bitmap.rdata0 : bitmap_colour_read;

    // Setup the address in the bitmap for the pixel being rendered
    // Use pre-fetching of the next pixel ready for the next cycle
    bitmap.addr0 := x_pixel + ( y_line * 640 );

    // RENDER - Default to transparent
    bitmap_display := pix_active && ~bitmap.rdata0[6,1];
    pix_red := bitmap.rdata0[4,2];
    pix_green := bitmap.rdata0[2,2];
    pix_blue := bitmap.rdata0[0,2];

    while(1) {
        switch( bitmap_write_offset ) {
            case 1: {
                x_offset = ( x_offset == 639 ) ? 0 : x_offset + 1;
            }
            case 2: {
                y_offset = ( y_offset == 479 ) ? 0 : y_offset + 1;
            }
            case 3: {
                x_offset = ( x_offset == 0 ) ? 639 : x_offset - 1;
            }
            case 4: {
                y_offset = ( y_offset == 0 ) ? 479 : y_offset - 1;
            }
            case 5: {
                x_offset = 0;
                y_offset = 0;
            }
        }
   }
}

algorithm bitmapwriter (
    // GPU to SET and GET pixels
    input   int11   bitmap_x_write,
    input   int11   bitmap_y_write,
    input   uint7   bitmap_colour_write,
    input   uint1   bitmap_write,

    input   uint10  x_offset,
    input   uint10  y_offset,

    simple_dualbram_port1 bitmap
) <autorun> {
    // Pixel x and y for writing ( adjusting for offset )
    uint10  x_write_pixel := ( bitmap_x_write + x_offset ) > 639 ? ( bitmap_x_write + x_offset ) - 639 : ( bitmap_x_write + x_offset );
    uint10  y_write_pixel := ( bitmap_y_write + y_offset ) > 479 ? ( bitmap_y_write + y_offset ) - 479 : ( bitmap_y_write + y_offset );

    // Write in range?
    uint1 write_pixel := (bitmap_x_write >= 0 ) && (bitmap_x_write < 640) && (bitmap_y_write >= 0) && (bitmap_y_write <= 479) && bitmap_write;

    // Bitmap write access for the GPU - Only enable when x and y are in range
    bitmap.wenable1 := 1;

    while(1) {
        if( write_pixel == 1 ) {
            bitmap.addr1 = x_write_pixel + y_write_pixel * 640;
            bitmap.wdata1 = bitmap_colour_write;
        }
    }
}

// Vector Block
// Stores blocks of upto 16 vertices which can be sent to the GPU for line drawing
// Each vertices represents a delta from the centre of the vector
// Deltas are stored as 6 bit 2's complement range -31 to 0 to 31
// Each vertices has an active flag, processing of a vector block stops when the active flag is 0
// Each vector block has a centre x and y coordinate and a colour { rrggbb } when drawn

bitfield vectorentry {
    uint1   active,
    uint1   dxsign,
    uint5   dx,
    uint1   dysign,
    uint5   dy
}

algorithm vectors(
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,

    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   vector_block_active,

    // Communication with the GPU
    output  int11 gpu_x,
    output  int11 gpu_y,
    output  uint7 gpu_colour,
    output  int11 gpu_param0,
    output  int11 gpu_param1,
    output  uint4 gpu_write,

    input  uint1 gpu_active
) <autorun> {
    // 32 vector blocks each of 16 vertices
    simple_dualport_bram uint13 vertex[512] = uninitialised;

    // Extract deltax and deltay for the present vertices
    int11 deltax := { {6{vectorentry(vertex.rdata0).dxsign}}, vectorentry(vertex.rdata0).dx };
    int11 deltay := { {6{vectorentry(vertex.rdata0).dysign}}, vectorentry(vertex.rdata0).dy };

    // Vertices being processed, plus first coordinate of each line
    uint5 block_number = uninitialised;
    uint5 vertices_number = uninitialised;
    int11 start_x = uninitialised;
    int11 start_y = uninitialised;

    // Set read and write address for the vertices
    vertex.addr0 := block_number * 16 + vertices_number;
    vertex.addr1 := vertices_writer_block * 16 + vertices_writer_vertex;
    vertex.wdata1 := { vertices_writer_active, __unsigned(vertices_writer_xdelta), __unsigned(vertices_writer_ydelta) };
    vertex.wenable1 := 1;

    gpu_write := 0;

    vector_block_active = 0;
    vertices_number = 0;

    while(1) {
        if( draw_vector ) {
            block_number = vector_block_number;
            gpu_colour = vector_block_colour;
            vertices_number = 0;
            vector_block_active = 1;
            ++:
            start_x = vector_block_xc + deltax;
            start_y = vector_block_yc + deltay;
            vertices_number = 1;
            ++:
            while( vectorentry(vertex.rdata0).active && ( vertices_number < 16 ) ) {
                gpu_x = start_x;
                gpu_y = start_y;
                gpu_param0 = vector_block_xc + deltax;
                gpu_param1 = vector_block_yc + deltay;

                while( gpu_active ) {}

                gpu_write = 3;

                // Move onto the next of the vertices
                start_x = vector_block_xc + deltax;
                start_y = vector_block_yc + deltay;
                vertices_number = vertices_number + 1;
                ++:
            }
            vector_block_active = 0;
        }
    }
}

algorithm gpu(
    // GPU to SET and GET pixels
    output! int11 bitmap_x_write,
    output! int11 bitmap_y_write,
    output! uint7 bitmap_colour_write,
    output! uint1 bitmap_write,

    // From j1eforth
    input   int11 gpu_x,
    input   int11 gpu_y,
    input   uint8 gpu_colour,
    input   int16 gpu_param0,
    input   int16 gpu_param1,
    input   int16 gpu_param2,
    input   int16 gpu_param3,
    input   uint4 gpu_write,

    // For setting blit1 tile bitmaps
    input   uint5   blit1_writer_tile,
    input   uint4   blit1_writer_line,
    input   uint16  blit1_writer_bitmap,

    // VECTOR BLOCK
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,
    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   gpu_active,
    output  uint1   vector_block_active
) <autorun> {
    // 32 x 16 x 16 1 bit tilemap for blit1tilemap
    simple_dualport_bram uint16 blit1tilemap[ 512 ] = uninitialized;

    // GPU work variable storage
    // Present GPU pixel and colour
    int11 gpu_active_x = uninitialized;
    int11 gpu_active_y = uninitialized;
    uint7 gpu_active_colour = uninitialized;

    // Temporary storage for GPU operations with meaningful names centre coordinates, end coordinates, width, height, deltas, radius, etc
    int11 gpu_xc = uninitialized;
    int11 gpu_yc = uninitialized;
    int11 gpu_x1 = uninitialized;
    int11 gpu_y1 = uninitialized;
    int11 gpu_x2 = uninitialized;
    int11 gpu_y2 = uninitialized;
    int11 gpu_dx = uninitialized;
    int11 gpu_sx = uninitialized;
    int11 gpu_dy = uninitialized;
    int11 gpu_sy = uninitialized;
    int11 gpu_min_x = uninitialized;
    int11 gpu_max_x = uninitialized;
    int11 gpu_min_y = uninitialized;
    int11 gpu_max_y = uninitialized;
    int11 gpu_numerator = uninitialized;
    int11 gpu_numerator2 = uninitialized;
    int11 gpu_count = uninitialized;
    int11 gpu_max_count = uninitialized;
    uint6 gpu_tile = uninitialized;

    // Filled triangle calculations
    // Is the point sx,sy inside the triangle given by active_x,active_y x1,y1 x2,y2?
    uint1 w0 = uninitialized;
    uint1 w1 = uninitialized;
    uint1 w2 = uninitialized;

    // GPU inputs, copied to according to Forth, VECTOR or DISPLAY LISTS
    int11   x = uninitialized;
    int11   y = uninitialized;
    int16   param0 = uninitialized;
    int16   param1 = uninitialized;
    int16   param2 = uninitialized;
    int16   param3 = uninitialized;
    uint4   write = uninitialized;

    // GPU <-> VECTOR DRAWER Communication
    int11 v_gpu_x = uninitialised;
    int11 v_gpu_y = uninitialised;
    uint7 v_gpu_colour = uninitialised;
    int11 v_gpu_param0 = uninitialised;
    int11 v_gpu_param1 = uninitialised;
    uint4 v_gpu_write = uninitialised;

    vectors vector_drawer (
        vector_block_number <: vector_block_number,
        vector_block_colour <: vector_block_colour,
        vector_block_xc <: vector_block_xc,
        vector_block_yc <: vector_block_yc,
        draw_vector <: draw_vector,
        vertices_writer_block <: vertices_writer_block,
        vertices_writer_vertex <: vertices_writer_vertex,
        vertices_writer_xdelta <: vertices_writer_xdelta,
        vertices_writer_ydelta <: vertices_writer_ydelta,
        vertices_writer_active <: vertices_writer_active,

        vector_block_active :> vector_block_active,

        gpu_x :> v_gpu_x,
        gpu_y :> v_gpu_y,
        gpu_colour :> v_gpu_colour,
        gpu_param0 :> v_gpu_param0,
        gpu_param1 :> v_gpu_param1,
        gpu_write :> v_gpu_write,
        gpu_active <: gpu_active
    );

    // blit1tilemap read access for the blit1tilemap
    blit1tilemap.addr0 := gpu_tile * 16 + gpu_active_y;

    // blit1tilemap write access for the GPU to load tilemaps
    blit1tilemap.addr1 := blit1_writer_tile * 16 + blit1_writer_line;
    blit1tilemap.wdata1 := blit1_writer_bitmap;
    blit1tilemap.wenable1 := 1;

    bitmap_write := 0;
    bitmap_colour_write := gpu_active_colour;

    while(1) {
        if( ( v_gpu_write != 0 ) || ( gpu_write != 0 ) ) {
            if( v_gpu_write != 0 ) {
                x = v_gpu_x;
                y = v_gpu_y;
                gpu_active_colour = v_gpu_colour;
                param0 = v_gpu_param0;
                param1 = v_gpu_param1;
                write = v_gpu_write;
            } else {
                if( gpu_write != 0 ) {
                    x = gpu_x;
                    y = gpu_y;
                    gpu_active_colour = gpu_colour;
                    param0 = gpu_param0;
                    param1 = gpu_param1;
                    param2 = gpu_param2;
                    param3 = gpu_param3;
                    write = gpu_write;
                } else {
                    write = 0;
                }
            }

            ++:

            switch( write ) {
                case 1: {
                    // Setup writing a pixel colour to x,y
                    // Done directly, does not activate the GPU
                    bitmap_x_write = x;
                    bitmap_y_write = y;
                    bitmap_write = 1;
                }

                case 2: {
                    // Setup drawing a rectangle from x,y to param0,param1 in colour
                    // Ensures that works left to right, top to bottom
                    // Cut out pixels out of 0 <= x <= 639 , 0 <= y <= 479
                    gpu_active_x = ( x < param0 ) ? ( x < 0 ? 0 : x ) : ( param0 < 0 ? 0 : param0 );                // left
                    gpu_active_y = ( y < param1 ) ? ( y < 0 ? 0 : y ) : ( param1 < 0 ? 0 : param1 );                // top
                    gpu_x1 = ( x < param0 ) ? ( x < 0 ? 0 : x )  : ( param0 < 0 ? 0 : param0 );                     // left - for next line
                    gpu_max_x = ( x < param0 ) ? ( param0 > 639 ? 639 : param0 ) : ( x > 639 ? 639 : x );              // right - at end of line
                    gpu_max_y = ( y < param1 ) ? ( param1 > 479 ? 479 : param1 ) : ( y > 479 ? 479 : y );              // bottom - at end of rectangle
                    gpu_active = 1;

                    ++:

                    while( gpu_active_y <= gpu_max_y ) {
                        while( gpu_active_x <= gpu_max_x ) {
                            bitmap_x_write = gpu_active_x;
                            bitmap_y_write = gpu_active_y;
                            bitmap_write = 1;
                            gpu_active_x = gpu_active_x + 1;
                        }
                        gpu_active_x = gpu_x1;
                        gpu_active_y = gpu_active_y + 1;
                    }
                    gpu_active = 0;
                }

                case 3: {
                    // Setup drawing a line from x,y to param0,param1 in colour
                    // Ensure LEFT to RIGHT
                    gpu_active_x = ( x < param0 ) ? x : param0;
                    gpu_active_y = ( x < param0 ) ? y : param1;

                    // Absolute DELTAs
                    gpu_dx = ( param0 < x ) ? x - param0 : param0 - x;
                    gpu_dy = ( param1 < y ) ? y - param1 : param1 - y;

                    // Shift X is always POSITIVE
                    gpu_sx = 1;

                    // Shift Y is NEGATIVE or POSITIVE
                    gpu_sy = ( x < param0 ) ? ( ( y < param1 ) ? 1 : -1 ) : ( ( y < param1 ) ? -1 : 1 );

                    gpu_count = 0;
                    gpu_active = 1;

                    ++:

                    gpu_numerator = ( gpu_dx > gpu_dy ) ? ( gpu_dx >> 1 ) : -( gpu_dy >> 1 );
                    gpu_max_count = ( gpu_dx > gpu_dy ) ? gpu_dx : gpu_dy;

                    ++:

                    while( gpu_count <= gpu_max_count ) {
                        bitmap_x_write = gpu_active_x;
                        bitmap_y_write = gpu_active_y;
                        bitmap_write = 1;

                        gpu_numerator2 = gpu_numerator;

                        ++:

                        if ( gpu_numerator2 > (-gpu_dx) ) {
                            gpu_numerator = gpu_numerator - gpu_dy;
                            gpu_active_x = gpu_active_x + gpu_sx;
                        }

                        ++:

                        if( gpu_numerator2 < gpu_dy ) {
                            gpu_numerator = gpu_numerator + gpu_dx;
                            gpu_active_y = gpu_active_y + gpu_sy;
                        }

                        gpu_count = gpu_count + 1;
                    }

                    gpu_active = 0;
                }

                case 4: {
                    // Setup drawing a circle centre x,y or radius param0 in colour
                    gpu_active_x = 0;
                    gpu_active_y = ( ( param0 < 0 ) ? -param0 : param0 );
                    gpu_xc = x;
                    gpu_yc = y;
                    gpu_numerator = 3 - ( 2 * ( ( param0 < 0 ) ? -param0 : param0 ) );

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y >= gpu_active_x ) {
                        bitmap_x_write = gpu_xc + gpu_active_x;
                        bitmap_y_write = gpu_yc + gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_x;
                        bitmap_y_write = gpu_yc + gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_x;
                        bitmap_y_write = gpu_yc - gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_x;
                        bitmap_y_write = gpu_yc - gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_y;
                        bitmap_y_write = gpu_yc + gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_y;
                        bitmap_y_write = gpu_yc + gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_y;
                        bitmap_y_write = gpu_yc - gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_y;
                        bitmap_y_write = gpu_yc - gpu_active_x;
                        bitmap_write = 1;

                        gpu_active_x = gpu_active_x + 1;

                        if( gpu_numerator > 0 ) {
                            gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                            gpu_active_y = gpu_active_y - 1;
                        } else {
                            gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                        }
                    }

                    gpu_active = 0;
                }

                case 5: {
                    // Setup 1 bit 16x16 blitter starting at x,y in colour of tile param0
                    gpu_active_x = 0;
                    gpu_active_y = 0;
                    gpu_x1 = x;
                    gpu_y1 = y;
                    gpu_max_x = 16;
                    gpu_max_y = 16;
                    gpu_tile = param0;

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y < gpu_max_y ) {
                        while( gpu_active_x < gpu_max_x ) {
                            if( blit1tilemap.rdata0[15 -gpu_active_x,1] ) {
                                bitmap_x_write = gpu_x1 + gpu_active_x;
                                bitmap_y_write = gpu_y1 + gpu_active_y;
                                bitmap_write = 1;
                            }
                            gpu_active_x = gpu_active_x + 1;
                        }
                        gpu_active_x = 0;
                        gpu_active_y = gpu_active_y + 1;
                    }

                    gpu_active = 0;
                }

                case 6: {
                    // Setup drawing a filled circle centre x,y or radius param0 in colour
                    // Minimum radius is 4, radius is always positive
                    gpu_active_x = 0;
                    gpu_active_y = ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) );
                    gpu_xc = x;
                    gpu_yc = y;
                    gpu_count = ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) );
                    gpu_numerator = 3 - ( 2 * ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) ) );

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y >= gpu_active_x ) {
                        while( gpu_count != 0 ) {
                            bitmap_x_write = gpu_xc + gpu_active_x;
                            bitmap_y_write = gpu_yc + gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_active_x;
                            bitmap_y_write = gpu_yc - gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_active_x;
                            bitmap_y_write = gpu_yc + gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_active_x;
                            bitmap_y_write = gpu_yc - gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_count;
                            bitmap_y_write = gpu_yc + gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_count;
                            bitmap_y_write = gpu_yc + gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_count;
                            bitmap_y_write = gpu_yc - gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_count;
                            bitmap_y_write = gpu_yc - gpu_active_x;
                            bitmap_write = 1;

                            gpu_count = gpu_count - 1;
                        }

                        gpu_active_x = gpu_active_x + 1;

                        if( gpu_numerator > 0 ) {
                            gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                            gpu_active_y = gpu_active_y - 1;
                            gpu_count = gpu_active_y - 1;
                        } else {
                            gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                            gpu_count = gpu_active_y;
                        }
                    }

                    bitmap_x_write = gpu_xc;
                    bitmap_y_write = gpu_yc;
                    bitmap_write = 1;

                    gpu_active = 0;
                }

                case 7: {
                    // Setup drawing a filled triangle x,y param0, param1, param2, param3
                    gpu_active_x = x;
                    gpu_active_y = y;
                    gpu_x1 = param0;
                    gpu_y1 = param1;
                    gpu_x2 = param2;
                    gpu_y2 = param3;

                    gpu_active = 1;

                    ++:

                    // Find minimum and maximum of x, x1 and x2 for the bounding box
                    // Find minimum and maximum of y, y1 and y2 for the bounding box
                    gpu_min_x = ( gpu_active_x < gpu_x1 ) ? ( ( gpu_active_x < gpu_x2 ) ? gpu_active_x : gpu_x2 ) : ( ( gpu_x1 < gpu_x2 ) ? gpu_x1: gpu_x2 );
                    gpu_min_y = ( gpu_active_y < gpu_y1 ) ? ( ( gpu_active_y < gpu_y2 ) ? gpu_active_y : gpu_y2 ) : ( ( gpu_y1 < gpu_y2 ) ? gpu_y1: gpu_y2 );
                    gpu_max_x = ( gpu_active_x > gpu_x1 ) ? ( ( gpu_active_x > gpu_x2 ) ? gpu_active_x : gpu_x2 ) : ( ( gpu_x1 > gpu_x2 ) ? gpu_x1 : gpu_x2 );
                    gpu_max_y = ( gpu_active_y > gpu_y1 ) ? ( ( gpu_active_y > gpu_y2 ) ? gpu_active_y : gpu_y2 ) : ( ( gpu_y1 > gpu_y2 ) ? gpu_y1 : gpu_y2 );

                    ++:

                    // Clip to the screen edge
                    gpu_min_x = ( gpu_min_x < 0 ) ? 0 : gpu_min_x;
                    gpu_min_y = ( gpu_min_y < 0 ) ? 0 : gpu_min_y;
                    gpu_max_x = ( gpu_min_x > 639 ) ? 639 : gpu_max_x;
                    gpu_max_y = ( gpu_min_y > 479 ) ? 479 : gpu_max_y;

                    ++:

                    // Find the point closest to the top of the screen
                    if( gpu_y1 < gpu_active_y ) {
                        gpu_active_x = gpu_x1;
                        gpu_active_y = gpu_y1;
                        gpu_x1 = gpu_active_x;
                        gpu_y1 = gpu_active_y;
                    }

                    ++:

                    if( gpu_y2 < gpu_active_y ) {
                        gpu_active_x = gpu_x2;
                        gpu_active_y = gpu_y2;
                        gpu_x2 = gpu_active_x;
                        gpu_y2 = gpu_active_y;
                    }

                    ++:

                    // Point order is top of screen then down to the right
                    if( gpu_x1 < gpu_x2 ) {
                        gpu_x2 = gpu_x1;
                        gpu_y2 = gpu_y1;
                        gpu_x1 = gpu_x2;
                        gpu_y1 = gpu_y2;
                    }

                    ++:

                    // Start at the top left
                    gpu_sx = gpu_min_x;
                    gpu_sy = gpu_min_y;
                    gpu_dx = 1;
                    gpu_count = 0;

                    ++:

                    while( gpu_sy <= gpu_max_y ) {
                        ++:

                        // Edge calculations to determine if inside the triangle - converted to DSP blocks
                        w0 = (( gpu_x2 - gpu_x1 ) * ( gpu_sy - gpu_y1 ) - ( gpu_y2 - gpu_y1 ) * ( gpu_sx - gpu_x1 )) >= 0;
                        w1 = (( gpu_active_x - gpu_x2 ) * ( gpu_sy - gpu_y2 ) - ( gpu_active_y - gpu_y2 ) * ( gpu_sx - gpu_x2 )) >= 0;
                        w2 = (( gpu_x1 - gpu_active_x ) * ( gpu_sy - gpu_active_y ) - ( gpu_y1 - gpu_active_y ) * ( gpu_sx - gpu_active_x )) >= 0;

                        ++:

                        bitmap_x_write = gpu_sx;
                        bitmap_y_write = gpu_sy;
                        bitmap_write = ( w0 && w1 && w2 );

                        gpu_count = ( w0 && w1 && w2 ) ? 1 : gpu_count;

                        ++:

                        if( ( gpu_count == 1 ) && ~( w0 && w1 && w2 ) ) {
                            // Exited the triangle, move to the next line
                            gpu_count = 0;
                            gpu_sy = gpu_sy + 1;
                            if( ( gpu_max_x - gpu_sx ) < ( gpu_sx - gpu_min_x ) ) {
                                // Closer to the right
                                gpu_sx = gpu_max_x;
                                gpu_dx = -1;
                            } else {
                                // Closer to the left
                                gpu_sx = gpu_min_x;
                                gpu_dx = 1;
                            }
                        } else {
                            switch( gpu_dx ) {
                                case 1: {
                                    if( gpu_sx < gpu_max_x ) {
                                        gpu_sx = gpu_sx + 1;
                                    } else {
                                        gpu_dx = -1;
                                        gpu_count = 0;
                                        gpu_sy = gpu_sy + 1;
                                    }
                                }
                                default: {
                                    if( gpu_sx > gpu_min_x ) {
                                        gpu_sx = gpu_sx - 1;
                                    } else {
                                        gpu_dx = 1;
                                        gpu_count = 0;
                                        gpu_sy = gpu_sy + 1;
                                    }
                                }
                            }
                        }
                    }

                    gpu_active = 0;
                }

                case 8: {
                    // Setup 1 bit 16x16 blitter starting at x,y in colour of tile param0
                    // Drawn DOUBLE SIZE
                    gpu_active_x = 0;
                    gpu_active_y = 0;
                    gpu_x1 = x;
                    gpu_y1 = y;
                    gpu_y2 = 0;
                    gpu_max_x = 32;
                    gpu_max_y = 16;
                    gpu_tile = param0;

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y < gpu_max_y ) {
                        while( gpu_active_x < gpu_max_x ) {
                            while( gpu_y2 < 2 ) {
                                if( blit1tilemap.rdata0[15 - ( gpu_active_x >> 1 ),1] ) {
                                    bitmap_x_write = gpu_x1 + gpu_active_x;
                                    bitmap_y_write = gpu_y1 + ( gpu_active_y << 1 ) + gpu_y2;
                                    bitmap_write = 1;
                                }
                                gpu_y2 = gpu_y2 + 1;
                            }
                            gpu_active_x = gpu_active_x + 1;
                            gpu_y2 = 0;
                        }
                        gpu_active_x = 0;
                        gpu_active_y = gpu_active_y + 1;
                    }

                    gpu_active = 0;
                }

                default: { gpu_active = 0; }
            }
        }
    }
}

algorithm background(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,

    input uint16 staticGenerator,

    input uint6 backgroundcolour,
    input uint6 backgroundcolour_alt,
    input uint4 backgroundcolour_mode,
    input uint3 background_write
) <autorun> {
    uint6 background = 0;
    uint6 background_alt = 0;
    uint4 background_mode = 0;

    // Variables for SNOW (from @sylefeb)
    int10   dotpos = 0;
    int2    speed = 0;
    int2    inv_speed = 0;
    int12   rand_x = 0;
    int32   frame = 0;

    // Default to black
    pix_red := 0;
    pix_green := 0;
    pix_blue := 0;

    while(1) {
        // UPDATE BACKGROUND GENERATOR PARAMETERS
        switch( background_write ) {
            case 1: { background = backgroundcolour; }
            case 2: { background_alt = backgroundcolour_alt; }
            case 3: { background_mode = backgroundcolour_mode; }
        }

        // Increment frame number for the snow/star field
        frame = ( ( pix_x == 639 ) && ( pix_y == 470 ) ) ? frame + 1 : frame;

        // RENDER
        if( pix_active ) {
            switch( background_mode ) {
                case 0: {
                    // SOLID
                    pix_red = colour6(background).red;
                    pix_green = colour6(background).green;
                    pix_blue = colour6(background).blue;
                }
                case 1: {
                    // SMALL checkerboard
                    switch( { pix_x[0,1], pix_y[0,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 2: {
                    // MEDIUM checkerboard
                    switch( { pix_x[1,1], pix_y[1,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 3: {
                    // LARGE checkerboard
                    switch( { pix_x[2,1], pix_y[2,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 4: {
                    // HUGE checkerboard
                    switch( { pix_x[3,1], pix_y[3,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 5: {
                    // 8 colour rainbow
                    switch( pix_y[6,3] ) {
                        case 3b000: { pix_red = 2; }
                        case 3b001: { pix_red = 3; }
                        case 3b010: { pix_red = 3; pix_green = 2; }
                        case 3b011: { pix_red = 3; pix_green = 3; }
                        case 3b100: { pix_green = 3; }
                        case 3b101: { pix_blue = 3; }
                        case 3b110: { pix_red = 1; pix_blue = 2; }
                        case 3b111: { pix_red = 1; pix_green = 2; pix_blue = 3; }
                    }
                }
                case 6: {
                    // Static
                    pix_red = staticGenerator[0,2];
                    pix_green = staticGenerator[0,2];
                    pix_blue = staticGenerator[0,2];
                }
                case 7: {
                    // SNOW (from @sylefeb)
                    rand_x = ( pix_x == 0)  ? 1 : rand_x * 31421 + 6927;
                    speed  = rand_x[10,2];
                    dotpos = ( frame >> speed ) + rand_x;
                        pix_red   = (pix_y == dotpos) ? colour6(background).red : colour6(background_alt).red;
                        pix_green = (pix_y == dotpos) ? colour6(background).green : colour6(background_alt).green;
                        pix_blue  = (pix_y == dotpos) ? colour6(background).blue : colour6(background_alt).blue;
                }
            }
        }
    }
}

bitfield spriteupdate {
    uint1   y_act,              // 1 - kill when off screen, 0 - wrap
    uint1   x_act,              // 1 - kill when off screen, 0 - wrap
    uint1   tile_act,           // 1 - increase the tile number
    uint1   dysign,             // dy - 2's complement update for the y coordinate
    uint4   dy,
    uint1   dxsign,             // dx - 2's complement update for the x coordinate
    uint4   dx
}

algorithm sprite_layer(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   sprite_layer_display,

    // For setting sprite characteristics
    input   uint4   sprite_set_number,
    input   uint1   sprite_set_active,
    input   uint1   sprite_set_double,
    input   uint6   sprite_set_colour,
    input   int11   sprite_set_x,
    input   int11   sprite_set_y,
    input   uint3   sprite_set_tile,
    // Flag to set the above
    input   uint4   sprite_layer_write,

    // For reading sprite characteristics for sprite_set_number
    output uint1   sprite_read_active,
    output uint1   sprite_read_double,
    output uint6   sprite_read_colour,
    output int11   sprite_read_x,
    output int11   sprite_read_y,
    output uint3   sprite_read_tile,

    input   uint16  sprite_update,

    // FULL collision detection
    // (1) Bitmap, (2) Tile Map, (3) Other Sprite Layer
    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
        output uint16 collision_0,
        output uint16 collision_1,
        output uint16 collision_2,
        output uint16 collision_3,
        output uint16 collision_4,
        output uint16 collision_5,
        output uint16 collision_6,
        output uint16 collision_7,
        output uint16 collision_8,
        output uint16 collision_9,
        output uint16 collision_10,
        output uint16 collision_11,
        output uint16 collision_12,

    // For setting sprite tile bitmaps
    input   uint4   sprite_writer_sprite,
    input   uint7   sprite_writer_line,
    input   uint16  sprite_writer_bitmap,
    input   uint1   sprite_writer_active

) <autorun> {
    // Storage for the sprites
    // Stored as registers as needed instantly
    uint1   sprite_active[13] = uninitialised;
    uint1   sprite_double[13] = uninitialised;
    int11   sprite_x[13] = uninitialised;
    int11   sprite_y[13] = uninitialised;
    uint6   sprite_colour[13] = uninitialised;
    uint3   sprite_tile_number[13] = uninitialised;

    uint1   output_collisions = 0;

        // Sprite Tiles
        simple_dualport_bram uint16 tiles_0[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_0 := sprite_double[0] ? 32 : 16;
        uint1 xinrange_0 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[0]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[0] + spritesize_0 ) );
        uint1 yinrange_0 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[0]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[0] + spritesize_0 ) );
        uint1 pix_visible_0 := sprite_active[0] && xinrange_0 && yinrange_0 && ( tiles_0.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[0] ) >>> sprite_double[0] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_0 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_1[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_1 := sprite_double[1] ? 32 : 16;
        uint1 xinrange_1 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[1]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[1] + spritesize_1 ) );
        uint1 yinrange_1 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[1]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[1] + spritesize_1 ) );
        uint1 pix_visible_1 := sprite_active[1] && xinrange_1 && yinrange_1 && ( tiles_1.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[1] ) >>> sprite_double[1] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_1 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_2[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_2 := sprite_double[2] ? 32 : 16;
        uint1 xinrange_2 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[2]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[2] + spritesize_2 ) );
        uint1 yinrange_2 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[2]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[2] + spritesize_2 ) );
        uint1 pix_visible_2 := sprite_active[2] && xinrange_2 && yinrange_2 && ( tiles_2.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[2] ) >>> sprite_double[2] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_2 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_3[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_3 := sprite_double[3] ? 32 : 16;
        uint1 xinrange_3 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[3]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[3] + spritesize_3 ) );
        uint1 yinrange_3 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[3]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[3] + spritesize_3 ) );
        uint1 pix_visible_3 := sprite_active[3] && xinrange_3 && yinrange_3 && ( tiles_3.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[3] ) >>> sprite_double[3] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_3 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_4[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_4 := sprite_double[4] ? 32 : 16;
        uint1 xinrange_4 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[4]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[4] + spritesize_4 ) );
        uint1 yinrange_4 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[4]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[4] + spritesize_4 ) );
        uint1 pix_visible_4 := sprite_active[4] && xinrange_4 && yinrange_4 && ( tiles_4.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[4] ) >>> sprite_double[4] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_4 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_5[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_5 := sprite_double[5] ? 32 : 16;
        uint1 xinrange_5 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[5]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[5] + spritesize_5 ) );
        uint1 yinrange_5 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[5]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[5] + spritesize_5 ) );
        uint1 pix_visible_5 := sprite_active[5] && xinrange_5 && yinrange_5 && ( tiles_5.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[5] ) >>> sprite_double[5] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_5 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_6[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_6 := sprite_double[6] ? 32 : 16;
        uint1 xinrange_6 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[6]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[6] + spritesize_6 ) );
        uint1 yinrange_6 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[6]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[6] + spritesize_6 ) );
        uint1 pix_visible_6 := sprite_active[6] && xinrange_6 && yinrange_6 && ( tiles_6.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[6] ) >>> sprite_double[6] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_6 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_7[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_7 := sprite_double[7] ? 32 : 16;
        uint1 xinrange_7 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[7]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[7] + spritesize_7 ) );
        uint1 yinrange_7 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[7]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[7] + spritesize_7 ) );
        uint1 pix_visible_7 := sprite_active[7] && xinrange_7 && yinrange_7 && ( tiles_7.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[7] ) >>> sprite_double[7] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_7 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_8[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_8 := sprite_double[8] ? 32 : 16;
        uint1 xinrange_8 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[8]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[8] + spritesize_8 ) );
        uint1 yinrange_8 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[8]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[8] + spritesize_8 ) );
        uint1 pix_visible_8 := sprite_active[8] && xinrange_8 && yinrange_8 && ( tiles_8.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[8] ) >>> sprite_double[8] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_8 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_9[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_9 := sprite_double[9] ? 32 : 16;
        uint1 xinrange_9 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[9]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[9] + spritesize_9 ) );
        uint1 yinrange_9 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[9]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[9] + spritesize_9 ) );
        uint1 pix_visible_9 := sprite_active[9] && xinrange_9 && yinrange_9 && ( tiles_9.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[9] ) >>> sprite_double[9] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_9 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_10[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_10 := sprite_double[10] ? 32 : 16;
        uint1 xinrange_10 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[10]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[10] + spritesize_10 ) );
        uint1 yinrange_10 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[10]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[10] + spritesize_10 ) );
        uint1 pix_visible_10 := sprite_active[10] && xinrange_10 && yinrange_10 && ( tiles_10.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[10] ) >>> sprite_double[10] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_10 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_11[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_11 := sprite_double[11] ? 32 : 16;
        uint1 xinrange_11 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[11]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[11] + spritesize_11 ) );
        uint1 yinrange_11 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[11]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[11] + spritesize_11 ) );
        uint1 pix_visible_11 := sprite_active[11] && xinrange_11 && yinrange_11 && ( tiles_11.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[11] ) >>> sprite_double[11] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_11 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_12[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_12 := sprite_double[12] ? 32 : 16;
        uint1 xinrange_12 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[12]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[12] + spritesize_12 ) );
        uint1 yinrange_12 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[12]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[12] + spritesize_12 ) );
        uint1 pix_visible_12 := sprite_active[12] && xinrange_12 && yinrange_12 && ( tiles_12.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[12] ) >>> sprite_double[12] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_12 = uninitialised;

    // Expand Sprite Update Deltas
    int11   deltax := { ( spriteupdate( sprite_update ).dxsign ? 7b1111111 : 7b0000000 ), spriteupdate( sprite_update ).dx };
    int11   deltay := { ( spriteupdate( sprite_update ).dysign ? 7b1111111 : 7b0000000 ), spriteupdate( sprite_update ).dy };

    // Sprite update helpers
    int11   sprite_offscreen_negative ::= sprite_double[ sprite_set_number ] ? -32 : -16;
    int11   sprite_to_negative ::= sprite_double[ sprite_set_number ] ? -31 : -15;
    uint1   sprite_offscreen_x ::= ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_x[ sprite_set_number ] ) > __signed(640) );
    uint1   sprite_offscreen_y ::= ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_y[ sprite_set_number ] ) > __signed(480) );

        // Set read and write address for the tiles
        tiles_0.addr0 := sprite_tile_number[0] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[0] ) >>> sprite_double[0] );
        tiles_0.wenable1 := 1;

        collision_0 := ( output_collisions ) ? detect_collision_0 : collision_0;
        // Set read and write address for the tiles
        tiles_1.addr0 := sprite_tile_number[1] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[1] ) >>> sprite_double[1] );
        tiles_1.wenable1 := 1;

        collision_1 := ( output_collisions ) ? detect_collision_1 : collision_1;
        // Set read and write address for the tiles
        tiles_2.addr0 := sprite_tile_number[2] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[2] ) >>> sprite_double[2] );
        tiles_2.wenable1 := 1;

        collision_2 := ( output_collisions ) ? detect_collision_2 : collision_2;
        // Set read and write address for the tiles
        tiles_3.addr0 := sprite_tile_number[3] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[3] ) >>> sprite_double[3] );
        tiles_3.wenable1 := 1;

        collision_3 := ( output_collisions ) ? detect_collision_3 : collision_3;
        // Set read and write address for the tiles
        tiles_4.addr0 := sprite_tile_number[4] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[4] ) >>> sprite_double[4] );
        tiles_4.wenable1 := 1;

        collision_4 := ( output_collisions ) ? detect_collision_4 : collision_4;
        // Set read and write address for the tiles
        tiles_5.addr0 := sprite_tile_number[5] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[5] ) >>> sprite_double[5] );
        tiles_5.wenable1 := 1;

        collision_5 := ( output_collisions ) ? detect_collision_5 : collision_5;
        // Set read and write address for the tiles
        tiles_6.addr0 := sprite_tile_number[6] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[6] ) >>> sprite_double[6] );
        tiles_6.wenable1 := 1;

        collision_6 := ( output_collisions ) ? detect_collision_6 : collision_6;
        // Set read and write address for the tiles
        tiles_7.addr0 := sprite_tile_number[7] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[7] ) >>> sprite_double[7] );
        tiles_7.wenable1 := 1;

        collision_7 := ( output_collisions ) ? detect_collision_7 : collision_7;
        // Set read and write address for the tiles
        tiles_8.addr0 := sprite_tile_number[8] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[8] ) >>> sprite_double[8] );
        tiles_8.wenable1 := 1;

        collision_8 := ( output_collisions ) ? detect_collision_8 : collision_8;
        // Set read and write address for the tiles
        tiles_9.addr0 := sprite_tile_number[9] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[9] ) >>> sprite_double[9] );
        tiles_9.wenable1 := 1;

        collision_9 := ( output_collisions ) ? detect_collision_9 : collision_9;
        // Set read and write address for the tiles
        tiles_10.addr0 := sprite_tile_number[10] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[10] ) >>> sprite_double[10] );
        tiles_10.wenable1 := 1;

        collision_10 := ( output_collisions ) ? detect_collision_10 : collision_10;
        // Set read and write address for the tiles
        tiles_11.addr0 := sprite_tile_number[11] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[11] ) >>> sprite_double[11] );
        tiles_11.wenable1 := 1;

        collision_11 := ( output_collisions ) ? detect_collision_11 : collision_11;
        // Set read and write address for the tiles
        tiles_12.addr0 := sprite_tile_number[12] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[12] ) >>> sprite_double[12] );
        tiles_12.wenable1 := 1;

        collision_12 := ( output_collisions ) ? detect_collision_12 : collision_12;

    // Default to transparent
    sprite_layer_display := 0;

    // Sprite details reader
    sprite_read_active := sprite_active[ sprite_set_number ];
    sprite_read_double := sprite_double[ sprite_set_number ];
    sprite_read_colour := sprite_colour[ sprite_set_number ];
    sprite_read_x := sprite_x[ sprite_set_number ];
    sprite_read_y := sprite_y[ sprite_set_number ];
    sprite_read_tile := sprite_tile_number[ sprite_set_number ];

    while(1) {
        // RENDER + COLLISION DETECTION
        if( pix_vblank ) {
            if( ~output_collisions ) {
                // RESET collision detection
                    detect_collision_0 = 0;
                    detect_collision_1 = 0;
                    detect_collision_2 = 0;
                    detect_collision_3 = 0;
                    detect_collision_4 = 0;
                    detect_collision_5 = 0;
                    detect_collision_6 = 0;
                    detect_collision_7 = 0;
                    detect_collision_8 = 0;
                    detect_collision_9 = 0;
                    detect_collision_10 = 0;
                    detect_collision_11 = 0;
                    detect_collision_12 = 0;
            } else {
                output_collisions = 0;
            }
        } else {
            if( pix_active ) {
                    if(  ( pix_visible_0 ) ) {
                        pix_red = sprite_colour[0][4,2];
                        pix_green = sprite_colour[0][2,2];
                        pix_blue = sprite_colour[0][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_0 = detect_collision_0 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_1 ) ) {
                        pix_red = sprite_colour[1][4,2];
                        pix_green = sprite_colour[1][2,2];
                        pix_blue = sprite_colour[1][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_1 = detect_collision_1 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_2 ) ) {
                        pix_red = sprite_colour[2][4,2];
                        pix_green = sprite_colour[2][2,2];
                        pix_blue = sprite_colour[2][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_2 = detect_collision_2 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_3 ) ) {
                        pix_red = sprite_colour[3][4,2];
                        pix_green = sprite_colour[3][2,2];
                        pix_blue = sprite_colour[3][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_3 = detect_collision_3 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_4 ) ) {
                        pix_red = sprite_colour[4][4,2];
                        pix_green = sprite_colour[4][2,2];
                        pix_blue = sprite_colour[4][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_4 = detect_collision_4 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_5 ) ) {
                        pix_red = sprite_colour[5][4,2];
                        pix_green = sprite_colour[5][2,2];
                        pix_blue = sprite_colour[5][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_5 = detect_collision_5 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_6 ) ) {
                        pix_red = sprite_colour[6][4,2];
                        pix_green = sprite_colour[6][2,2];
                        pix_blue = sprite_colour[6][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_6 = detect_collision_6 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_7 ) ) {
                        pix_red = sprite_colour[7][4,2];
                        pix_green = sprite_colour[7][2,2];
                        pix_blue = sprite_colour[7][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_7 = detect_collision_7 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_8 ) ) {
                        pix_red = sprite_colour[8][4,2];
                        pix_green = sprite_colour[8][2,2];
                        pix_blue = sprite_colour[8][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_8 = detect_collision_8 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_9 ) ) {
                        pix_red = sprite_colour[9][4,2];
                        pix_green = sprite_colour[9][2,2];
                        pix_blue = sprite_colour[9][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_9 = detect_collision_9 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_10 ) ) {
                        pix_red = sprite_colour[10][4,2];
                        pix_green = sprite_colour[10][2,2];
                        pix_blue = sprite_colour[10][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_10 = detect_collision_10 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_11 ) ) {
                        pix_red = sprite_colour[11][4,2];
                        pix_green = sprite_colour[11][2,2];
                        pix_blue = sprite_colour[11][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_11 = detect_collision_11 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_12 ) ) {
                        pix_red = sprite_colour[12][4,2];
                        pix_green = sprite_colour[12][2,2];
                        pix_blue = sprite_colour[12][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_12 = detect_collision_12 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }

                // Output collision detection
                output_collisions = ( pix_x == 639 ) && ( pix_y == 479 );
            }
        }

        // WRITE BITMAP TO SPRITE TILE
        if( sprite_writer_active ) {
            switch( sprite_writer_sprite ) {
                    case 0: {
                        tiles_0.addr1 = sprite_writer_line;
                        tiles_0.wdata1 = sprite_writer_bitmap;
                    }
                    case 1: {
                        tiles_1.addr1 = sprite_writer_line;
                        tiles_1.wdata1 = sprite_writer_bitmap;
                    }
                    case 2: {
                        tiles_2.addr1 = sprite_writer_line;
                        tiles_2.wdata1 = sprite_writer_bitmap;
                    }
                    case 3: {
                        tiles_3.addr1 = sprite_writer_line;
                        tiles_3.wdata1 = sprite_writer_bitmap;
                    }
                    case 4: {
                        tiles_4.addr1 = sprite_writer_line;
                        tiles_4.wdata1 = sprite_writer_bitmap;
                    }
                    case 5: {
                        tiles_5.addr1 = sprite_writer_line;
                        tiles_5.wdata1 = sprite_writer_bitmap;
                    }
                    case 6: {
                        tiles_6.addr1 = sprite_writer_line;
                        tiles_6.wdata1 = sprite_writer_bitmap;
                    }
                    case 7: {
                        tiles_7.addr1 = sprite_writer_line;
                        tiles_7.wdata1 = sprite_writer_bitmap;
                    }
                    case 8: {
                        tiles_8.addr1 = sprite_writer_line;
                        tiles_8.wdata1 = sprite_writer_bitmap;
                    }
                    case 9: {
                        tiles_9.addr1 = sprite_writer_line;
                        tiles_9.wdata1 = sprite_writer_bitmap;
                    }
                    case 10: {
                        tiles_10.addr1 = sprite_writer_line;
                        tiles_10.wdata1 = sprite_writer_bitmap;
                    }
                    case 11: {
                        tiles_11.addr1 = sprite_writer_line;
                        tiles_11.wdata1 = sprite_writer_bitmap;
                    }
                    case 12: {
                        tiles_12.addr1 = sprite_writer_line;
                        tiles_12.wdata1 = sprite_writer_bitmap;
                    }
            }
        }

        // SET ATTRIBUTES + PERFORM UPDATE
        switch( sprite_layer_write ) {
            case 1: { sprite_active[ sprite_set_number ] = sprite_set_active; }
            case 2: { sprite_tile_number[ sprite_set_number ] = sprite_set_tile; }
            case 3: { sprite_colour[ sprite_set_number ] = sprite_set_colour; }
            case 4: { sprite_x[ sprite_set_number ] = sprite_set_x; }
            case 5: { sprite_y[ sprite_set_number ] = sprite_set_y; }
            case 6: { sprite_double[ sprite_set_number ] = sprite_set_double; }
            case 10: {
                // Perform sprite update
                if( spriteupdate( sprite_update ).tile_act ) {
                    sprite_tile_number[ sprite_set_number ] = sprite_tile_number[ sprite_set_number ] + 1;
                }

                if( spriteupdate( sprite_update ).x_act || spriteupdate( sprite_update ).y_act) {
                    sprite_active[ sprite_set_number ] = ( sprite_offscreen_x || sprite_offscreen_y ) ? 0 : sprite_active[ sprite_set_number ];
                }

                sprite_x[ sprite_set_number ] = sprite_offscreen_x ? ( ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ?__signed(640) : sprite_to_negative ) :
                                                sprite_x[ sprite_set_number ] + deltax;

                sprite_y[ sprite_set_number ] = sprite_offscreen_y ? ( ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ? __signed(480) : sprite_to_negative ) :
                                                sprite_y[ sprite_set_number ] + deltay;
            }
        }
    }
}

bitfield tilemapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint5   tilenumber
}

algorithm tilemap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   tilemap_display,

    // Set TM at x, y, character with foreground and background
    input uint6 tm_x,
    input uint6 tm_y,
    input uint5 tm_character,
    input uint6 tm_foreground,
    input uint7 tm_background,
    input uint1 tm_write,

    // For setting tile bitmaps
    input   uint5   tile_writer_tile,
    input   uint4   tile_writer_line,
    input   uint16  tile_writer_bitmap,

    // For scrolling/wrapping
    input   uint4   tm_scrollwrap,
    output  uint4   tm_lastaction,
    output  uint3   tm_active
) <autorun> {
    // Tile Map 32 x 16 x 16
    simple_dualport_bram uint16 tiles16x16[ 512 ] = { 0, pad(0) };

    // 42 x 32 tile map, allows for pixel scrolling with border { 7 bits background, 6 bits foreground, 5 bits tile number }
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint18 tiles[1344] = { 18b100000000000000000, pad(18b100000000000000000) };
    simple_dualport_bram uint18 tiles_copy[1344] = { 18b100000000000000000, pad(18b100000000000000000) };

    // Scroll position - -15 to 0 to 15
    // -15 or 15 will trigger appropriate scroll when next moved in that direction
    int5    tm_offset_x = 0;
    int5    tm_offset_y = 0;

    // Scroller/Wrapper storage
    uint1   tm_scroll = uninitialized;
    uint6   x_cursor = uninitialized;
    uint6   y_cursor = uninitialized;
    uint11  y_cursor_addr = uninitialized;
    uint18  new_tile = uninitialized;
    uint18  scroll_tile = uninitialized;

    // CS address
    uint11  tmcsaddr = uninitialized;

    // Character position on the screen x 0-41, y 0-31 * 42 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    // Adjust for the offsets, effective 0 point margin is ( 1,1 ) to ( 40,30 ) with a 1 tile border
    uint11  xtmpos :=  ( pix_active ? pix_x + ( 11d18 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) : ( 11d16 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) ) >> 4;
    uint11  ytmpos := (( pix_vblank ? ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) : pix_y + ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) ) >> 4) * 42;

    // Derive the x and y coordinate within the current 16x16 tilemap block x 0-7, y 0-15
    // Needs adjusting for the offsets
    uint4   xintm := { 1b0, (pix_x) & 15 } + tm_offset_x;
    uint4   yintm := { 1b0, (pix_y) & 15 } + tm_offset_y;

    // Derive the actual pixel in the current character
    uint1   tmpixel := tiles16x16.rdata0[15 - xintm,1];

    // Set up reading of the tilemap
    tiles.addr0 := xtmpos + ytmpos;
    tiles.wenable1 := 1;
    tiles_copy.wenable1 := 1;

    // Setup the reading and writing of the tiles16x16
    tiles16x16.addr0 :=  tilemapentry(tiles.rdata0).tilenumber * 16 + yintm;
    tiles16x16.addr1 := tile_writer_tile * 16 + tile_writer_line;
    tiles16x16.wdata1 := tile_writer_bitmap;
    tiles16x16.wenable1 := 1;

    // RENDER - Default to transparent
    tilemap_display := pix_active && ( ( tmpixel ) || ( ~tilemapentry(tiles.rdata0).alpha ) );
    pix_red := tmpixel ? tiles.rdata0[9,2] : tiles.rdata0[15,2];
    pix_green := tmpixel ? tiles.rdata0[7,2] : tiles.rdata0[13,2];
    pix_blue := tmpixel ?  tiles.rdata0[5,2] : tiles.rdata0[11,2];

    // Default to 0,0 and transparent
    tiles.addr1 = 0; tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
    tiles_copy.addr1 = 0; tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };

    while(1) {
        // Write character to the tilemap
        if( tm_write == 1 ) {
            tiles.addr1 = tm_x + tm_y * 42;
            tiles.wdata1 = { tm_background, tm_foreground, tm_character };
            tiles_copy.addr1 = tm_x + tm_y * 42;
            tiles_copy.wdata1 = { tm_background, tm_foreground, tm_character };
        }

        switch( tm_active ) {
            case 0: {
                // Perform Scrolling/Wrapping
                switch( tm_scrollwrap ) {
                    // LEFT
                    case 1: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 2: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 3;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 3: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 2;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 4: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 4;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }
                    // LEFT
                    case 5: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 6: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 3;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 7: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 2;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 8: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 4;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // CLEAR
                    case 9: {
                        tm_active = 5;
                        tm_lastaction = 9;
                    }
                }
            }

            // SCROLL/WRAP LEFT
            case 1: {
                y_cursor = 0;
                y_cursor_addr = 0;
                ++:
                while( y_cursor < 32 ) {
                    x_cursor = 0;
                    tiles_copy.addr0 = y_cursor_addr;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( x_cursor < 42 ) {
                        tiles_copy.addr0 = ( x_cursor + 1 ) + y_cursor_addr;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        x_cursor = x_cursor + 1;
                    }
                    ++:
                    tiles.addr1 = ( 41 ) + y_cursor_addr;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = ( 41 ) + y_cursor_addr;
                    tiles_copy.wdata1 = new_tile;
                    y_cursor = y_cursor + 1;
                    y_cursor_addr = y_cursor_addr + 42;
                }
                ++:
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP RIGHT
            case 2: {
                y_cursor = 0;
                y_cursor_addr = 0;
                ++:
                while( y_cursor < 32 ) {
                    x_cursor = 41;
                    tiles_copy.addr0 = 41 + y_cursor_addr;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( x_cursor > 0 ) {
                        tiles_copy.addr0 = ( x_cursor - 1 ) + y_cursor_addr;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        x_cursor = x_cursor - 1;
                    }
                    ++:
                    tiles.addr1 = y_cursor_addr;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = y_cursor_addr;
                    tiles_copy.wdata1 = new_tile;
                    y_cursor = y_cursor + 1;
                    y_cursor_addr = y_cursor_addr + 42;
                }
                ++:
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP UP
            case 3: {
                x_cursor = 0;
                ++:
                while( x_cursor < 42 ) {
                    y_cursor = 0;
                    y_cursor_addr = 0;
                    tiles_copy.addr0 = x_cursor;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( y_cursor < 31 ) {
                        tiles_copy.addr0 = x_cursor + y_cursor_addr + 42;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        y_cursor = y_cursor + 1;
                        y_cursor_addr = y_cursor_addr + 42;
                    }
                    tiles.addr1 = x_cursor + 1302;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = x_cursor + 1302;
                    tiles_copy.wdata1 = new_tile;
                    x_cursor = x_cursor + 1;
                }
                ++:
                tm_offset_y = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP DOWN
            case 4: {
                x_cursor = 0;
                ++:
                while( x_cursor < 42 ) {
                    y_cursor = 0;
                    y_cursor_addr = 1302;
                    tiles_copy.addr0 = x_cursor;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( y_cursor > 0 ) {
                        tiles_copy.addr0 = x_cursor + y_cursor_addr - 42;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        y_cursor = y_cursor - 1;
                        y_cursor_addr = y_cursor_addr - 42;
                    }
                    tiles.addr1 = x_cursor;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = x_cursor;
                    tiles_copy.wdata1 = new_tile;
                    x_cursor = x_cursor + 1;
                }
                ++:
                tm_offset_y = 0;
                tm_active = 0;
            }

            // CLEAR
            case 5: {
                tmcsaddr = 0;
                tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                ++:
                while( tmcsaddr < 1344 ) {
                    tiles.addr1 = tmcsaddr;
                    tiles_copy.addr1 = tmcsaddr;
                    tmcsaddr = tmcsaddr + 1;
                }
                ++:

                tm_offset_x = 0;
                tm_offset_y = 0;
                tm_active = 0;
            }
        }
    }
}

// Runs at 50MHz
algorithm apu(
    // Waveform selected 0 = square, 1 = sawtooth, 2 = triangle, 3 = sine wave, 4 = noise
    input   uint4   waveform,
    // Note selected 0 = silence, 1 - x = Deep C through to Double High D (gives 64 distint notes)
    input   uint7   note,

    // Duration in ms, 1000 = 1 second,
    input   uint16  duration,
    output! uint1   audio_active,

    // Activate the APU (select the channel, 1, 2 or 3(?) )
    input   uint1   apu_write,

    output! uint4   audio_output,

    input uint16 staticGenerator
) <autorun> {
    // 32 step points per waveform
    brom uint4 waveformtable[512] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,

        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6

        ,pad(1)
    };

    // Calculated as 25MHz / note frequency / 32 to give 32 step points per note
    brom uint16 frequencytable[128] = {
        0,
        47778, 45097, 42566, 40177, 37922, 35793, 33784, 31888, 30098, 28409, 26815, 25310,     // 1 = C 2 or Deep C
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 13 = C 3
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 25 = C 4 or Middle C
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 37 = C 5 or Tenor C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 49 = C 6 or Soprano C
        1493, 1409, 1330, pad(1024)                                                             // 61 = C 7 or Double High C
    };

    uint4   selected_waveform = uninitialized;
    uint7   selected_note = uninitialized;
    uint16  selected_duration = uninitialized;

    uint5   point = uninitialized;
    uint16  counter50mhz = uninitialized;
    uint16  counter1khz = uninitialized;

    waveformtable.addr := selected_waveform * 32 + point;
    frequencytable.addr := selected_note;

    audio_active := ( selected_duration > 0);

    while(1) {
        if( ( selected_duration != 0 ) && ( counter50mhz == 0 ) ) {
            audio_output = ( selected_waveform == 4 ) ? staticGenerator : waveformtable.rdata;
        }

        if( apu_write != 0 ) {
            // Latch the selected note, waveform and duration
            selected_waveform = waveform;
            selected_note = note;
            selected_duration = duration;
            point = 0;
            counter50mhz = 0;
            counter1khz = 50000;
        } else {
            if( selected_duration != 0 ) {
                counter50mhz = ( counter50mhz != 0 ) ? counter50mhz - 1 : frequencytable.rdata;
                point = ( counter50mhz != 0 ) ? point : point + 1;
                counter1khz = ( counter1khz != 0 ) ? counter1khz - 1 : 50000;
                selected_duration = ( counter1khz != 0 ) ? selected_duration : selected_duration - 1;
            }
        }
    }
}

// Hardware Accelerated Multiplication and Division
// UNSIGNED / SIGNED 32 by 32 bit division giving 32 bit remainder and quotient

algorithm divideremainder (
    input   uint32  dividend,
    input   uint32  divisor,
    input   uint1   dosigned,

    input   uint1   start,
    output  uint1   active,

    output  uint32  quotient,
    output  uint32  remainder
) <autorun> {
    uint32  dividend_copy = uninitialized;
    uint32  divisor_copy = uninitialized;

    uint1   resultsign = uninitialized;
    uint6   bit = uninitialized;
    uint6   count = uninitialized;

    active = 0;

    while(1) {
        if( start ) {
            active = 1;
            bit = 31;


            if( divisor == 0 ) {
                // DIVISON by ZERO
                quotient = 32hffffffff;
                remainder = dividend;
                active = 0;
            } else {
                quotient = 0;
                remainder = 0;

                dividend_copy = dosigned ? ( dividend[31,1] ? -dividend : dividend ) : dividend;
                divisor_copy = dosigned ?  ( divisor[31,1] ? -divisor : divisor ) :divisor;
                resultsign = dosigned ?  dividend[31,1] != divisor[31,1] : 0;

                ++:

                while( bit != 63 ) {
                    if( __unsigned({ remainder[0,31], dividend_copy[bit,1] }) >= __unsigned(divisor_copy) ) {
                        remainder = __unsigned({ remainder[0,31], dividend_copy[bit,1] }) - __unsigned(divisor_copy);
                        quotient[bit,1] = 1;
                    } else {
                        remainder = { remainder[0,31], dividend_copy[bit,1] };
                    }
                    bit = bit - 1;
                }

                ++:

                quotient = resultsign ? -quotient : quotient;
                active = 0;
            }
        }
    }
}

// UNSIGNED / SIGNED 32 by 32 bit multiplication giving 64 bit product
// DSP BLOCKS

algorithm multiplicationDSP (
    input   uint32  factor_1,
    input   uint32  factor_2,
    input   uint2   dosigned,

    input   uint1   start,
    output  uint1   active,

    output  uint64  product
) <autorun> {
    uint32  factor_1_copy := ( dosigned == 0 ) ? factor_1 : ( ( factor_1[31,1] ) ? -factor_1 : factor_1 );
    uint32  factor_2_copy := ( dosigned != 1 ) ? factor_2 : ( ( factor_2[31,1] ) ? -factor_2 : factor_2 );

    // CALCULATION AB * CD
    uint18  A := { 2b0, factor_1_copy[16,16] };
    uint18  B := { 2b0, factor_1_copy[0,16] };
    uint18  C := { 2b0, factor_2_copy[16,16] };
    uint18  D := { 2b0, factor_2_copy[0,16] };

    uint1   resultsign := ( dosigned == 0 ) ? 0 : ( ( dosigned == 1 ) ? ( factor_1[31,1] != factor_2[31,1] ) : factor_1[31,1] );

    while(1) {
        if( start ) {
            active = 1;
            ++:
            product = D*B + { D*A, 16b0 } + { C*B, 16b0 } + { C*A, 32b0 };
            ++:
            product = resultsign ? -product : product;
            active = 0;
        }
    }
}

// SIGNED ADDITION / SUBTRACTION
algorithm additionsubtraction (
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   immediateValue,

    input   uint7   opCode,
    input   uint7   function7,

    output  int32   result,
) <autorun> {
    result := sourceReg1 + ( opCode[5,1] ? ( function7[5,1] ? -( sourceReg2 ) : sourceReg2 ) : immediateValue );

    while(1) {
    }
}

// SHIFT OPERATIONS - LOGICAL and ARITHMETIC
algorithm shifter (
    input   int32   sourceReg1,
    input   int32   sourceReg2,

    input   uint32  instruction,
    input   uint7   opCode,
    input   uint7   function7,

    output  int32   shiftLEFT,
    output  int32   shiftRIGHTA,
    output  int32   shiftRIGHTL,
) <autorun> {
    shiftLEFT :=  __unsigned(sourceReg1) << ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );
    shiftRIGHTA := __signed(sourceReg1) >>> ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );
    shiftRIGHTL := __unsigned(sourceReg1) >> ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );

    while(1) {
    }
}

// BINARY LOGIC OPERATIONS
algorithm logical (
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   immediateValue,

    input   uint7   opCode,

    output  int32   AND,
    output  int32   OR,
    output  int32   XOR
) <autorun> {
    AND := sourceReg1 & ( opCode[5,1] ? sourceReg2 : immediateValue );
    OR := sourceReg1 | ( opCode[5,1] ? sourceReg2 : immediateValue );
    XOR := sourceReg1 ^ ( opCode[5,1] ? sourceReg2 : immediateValue );

    while(1) {
    }
}

// COMPARISONS
algorithm comparison (
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   int32   immediateValue,
    input   uint32  instruction,

    output  uint1   SLT,
    output  uint1   SLTI,
    output  uint1   SLTU,
    output  uint1   SLTUI
) <autorun> {
    SLT := __signed( sourceReg1 ) < __signed(sourceReg2) ? 1 : 0;
    SLTI := __signed( sourceReg1 ) < __signed(immediateValue) ? 1 : 0;
    SLTU := ( Rtype(instruction).sourceReg1 == 0 ) ? ( ( sourceReg2 != 0 ) ? 1 : 0 ) : ( ( __unsigned( sourceReg1 ) < __unsigned( sourceReg2 ) ) ? 1 : 0 );
    SLTUI := ( immediateValue == 1 ) ? ( ( sourceReg1 == 0 ) ? 1 : 0 ) : ( ( __unsigned( sourceReg1 ) < __unsigned( immediateValue ) ) ? 1 : 0 );

    while(1) {
    }
}

// BRANCH COMPARISIONS
algorithm branchcomparison (
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    input   uint3   function3,
    output  uint1   takeBranch
) <autorun> {
    while(1) {
        switch( function3 ) {
            case 3b000: { takeBranch = ( sourceReg1 == sourceReg2 ) ? 1 : 0; }
            case 3b001: { takeBranch = ( sourceReg1 != sourceReg2 ) ? 1 : 0; }
            case 3b100: { takeBranch = ( __signed(sourceReg1) < __signed(sourceReg2) ) ? 1 : 0; }
            case 3b101: { takeBranch = ( __signed(sourceReg1) >= __signed(sourceReg2) )  ? 1 : 0; }
            case 3b110: { takeBranch = ( __unsigned(sourceReg1) < __unsigned(sourceReg2) ) ? 1 : 0; }
            case 3b111: { takeBranch = ( __unsigned(sourceReg1) >= __unsigned(sourceReg2) ) ? 1 : 0; }
            default: { takeBranch = 0; }
        }
    }
}

// 7 bit colour either ALPHA (background or lower layer) or red, green, blue { Arrggbb }
bitfield colour7 {
    uint1   alpha,
    uint2   red,
    uint2   green,
    uint2   blue
}

// 6 bit colour red, green, blue { rrggbb }
bitfield colour6 {
    uint2   red,
    uint2   green,
    uint2   blue
}

// Simplify access to high/low word
bitfield words {
    uint16  hword,
    uint16  lword
}

// Simplify access to high/low byte
bitfield bytes {
    uint8   byte1,
    uint8   byte0
}

// Simplify access to 4bit nibbles (used to extract shift left/right amount)
bitfield nibbles {
    uint4   nibble3,
    uint4   nibble2,
    uint4   nibble1,
    uint4   nibble0
}

algorithm memmap_io (
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // SDCARD
    output! uint1   sd_clk,
    output! uint1   sd_mosi,
    output! uint1   sd_csn,
    input   uint1   sd_miso,

    // HDMI
    output! uint8   video_r,
    output! uint8   video_g,
    output! uint8   video_b,
    input   uint1   vblank,
    input   uint1   pix_active,
    input   uint10  pix_x,
    input   uint10  pix_y,

    // CLOCKS
    input   uint1   clock_50mhz,
    input   uint1   clock_25mhz,
    input   uint1   video_clock,
    input   uint1   gpu_clock,
    input   uint1   video_reset,

    // Memory access
    input   uint16  memoryAddress,
    input   uint16  writeData,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    output! uint16  readData,
) <autorun> {
    // 1hz timers (p1hz used for systemClock, timer1hz for user purposes)
    uint16 systemClock = uninitialized;
    pulse1hz p1hz <@clock_50mhz> (
        counter1hz :> systemClock,
    );
    pulse1hz timer1hz <@clock_50mhz> ( );

    // 1khz timers (sleepTimer used for sleep command, timer1khz for user purposes)
    pulse1khz sleepTimer <@clock_50mhz> ( );
    pulse1khz timer1khz <@clock_50mhz> ( );

    // RNG random number generator
    uint16 staticGenerator = 0;
    random rng <@clock_50mhz> (
        g_noise_out :> staticGenerator,
    );

    // UART tx and rx
    // UART written in Silice by https://github.com/sylefeb/Silice
    uart_out uo;
    uart_sender usend <@clock_25mhz> (
        io      <:> uo,
        uart_tx :>  uart_tx
    );
    uart_in ui;
    uart_receiver urecv <@clock_25mhz> (
        io      <:> ui,
        uart_rx <:  uart_rx
    );

    // CREATE DISPLAY LAYERS
    // BACKGROUND
    uint2   background_r = uninitialized;
    uint2   background_g = uninitialized;
    uint2   background_b = uninitialized;
    background background_generator <@video_clock,!video_reset>  (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> background_r,
        pix_green  :> background_g,
        pix_blue   :> background_b,
        staticGenerator <: staticGenerator
    );

    // TILEMAP
    uint2   tilemap_r = uninitialized;
    uint2   tilemap_g = uninitialized;
    uint2   tilemap_b = uninitialized;
    uint1   tilemap_display = uninitialized;

    tilemap tile_map <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> tilemap_r,
        pix_green  :> tilemap_g,
        pix_blue   :> tilemap_b,
        tilemap_display :> tilemap_display,
    );

    // Bitmap Window
    uint2   bitmap_r = uninitialized;
    uint2   bitmap_g = uninitialized;
    uint2   bitmap_b = uninitialized;
    uint10  x_offset = uninitialized;
    uint10  y_offset = uninitialized;
    // From GPU to set a pixel
    uint1   bitmap_display = uninitialized;
    int11   bitmap_x_write = uninitialized;
    int11   bitmap_y_write = uninitialized;
    uint7   bitmap_colour_write = uninitialized;
    uint1   bitmap_write = uninitialized;

    // 640 x 480 x 7 bit { Arrggbb } colour bitmap
    simple_dualport_bram uint7 bitmap<@video_clock,@gpu_clock>[ 307200 ] = uninitialized;
    bitmap bitmap_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> bitmap_r,
        pix_green  :> bitmap_g,
        pix_blue   :> bitmap_b,
        bitmap_display :> bitmap_display,
        x_offset :> x_offset,
        y_offset :> y_offset,
        bitmap <:> bitmap
    );
    bitmapwriter pixel_writer <@gpu_clock> (
        bitmap_x_write <: bitmap_x_write,
        bitmap_y_write <: bitmap_y_write,
        bitmap_colour_write <: bitmap_colour_write,
        bitmap_write <: bitmap_write,
        x_offset <: x_offset,
        y_offset <: y_offset,
        bitmap <:> bitmap
    );

    // Lower Sprite Layer - Between BACKGROUND and BITMAP
    // Upper Sprite Layer - Between BITMAP and CHARACTER MAP
    uint2   lower_sprites_r = uninitialized;
    uint2   lower_sprites_g = uninitialized;
    uint2   lower_sprites_b = uninitialized;
    uint1   lower_sprites_display = uninitialized;
    uint2   upper_sprites_r = uninitialized;
    uint2   upper_sprites_g = uninitialized;
    uint2   upper_sprites_b = uninitialized;
    uint1   upper_sprites_display = uninitialized;

    sprite_layer lower_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> lower_sprites_r,
        pix_green  :> lower_sprites_g,
        pix_blue   :> lower_sprites_b,
        sprite_layer_display :> lower_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: upper_sprites_display
    );

    sprite_layer upper_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> upper_sprites_r,
        pix_green  :> upper_sprites_g,
        pix_blue   :> upper_sprites_b,
        sprite_layer_display :> upper_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: lower_sprites_display
    );

    // Character Map Window
    uint2   character_map_r = uninitialized;
    uint2   character_map_g = uninitialized;
    uint2   character_map_b = uninitialized;
    uint1   character_map_display = uninitialized;

    character_map character_map_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> character_map_r,
        pix_green  :> character_map_g,
        pix_blue   :> character_map_b,
        character_map_display :> character_map_display
    );

    // Terminal window at the bottom of the screen
    uint2   terminal_r = uninitialized;
    uint2   terminal_g = uninitialized;
    uint2   terminal_b = uninitialized;
    uint1   terminal_display = uninitialized;

    terminal terminal_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> terminal_r,
        pix_green  :> terminal_g,
        pix_blue   :> terminal_b,
        terminal_display :> terminal_display,
        timer1hz   <: systemClock
    );

    // Combine the display layers for display
    multiplex_display display <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> video_r,
        pix_green  :> video_g,
        pix_blue   :> video_b,

        background_r <: background_r,
        background_g <: background_g,
        background_b <: background_b,

        tilemap_r <: tilemap_r,
        tilemap_g <: tilemap_g,
        tilemap_b <: tilemap_b,
        tilemap_display <: tilemap_display,

        lower_sprites_r <: lower_sprites_r,
        lower_sprites_g <: lower_sprites_g,
        lower_sprites_b <: lower_sprites_b,
        lower_sprites_display <: lower_sprites_display,

        bitmap_r <: bitmap_r,
        bitmap_g <: bitmap_g,
        bitmap_b <: bitmap_b,
        bitmap_display <: bitmap_display,

        upper_sprites_r <: upper_sprites_r,
        upper_sprites_g <: upper_sprites_g,
        upper_sprites_b <: upper_sprites_b,
        upper_sprites_display <: upper_sprites_display,

        character_map_r <: character_map_r,
        character_map_g <: character_map_g,
        character_map_b <: character_map_b,
        character_map_display <: character_map_display,

        terminal_r <: terminal_r,
        terminal_g <: terminal_g,
        terminal_b <: terminal_b,
        terminal_display <: terminal_display
    );

    // Left and Right audio channels
    // Sync'd with video_clock
    apu apu_processor_L <@clock_50mhz> (
        staticGenerator <: staticGenerator,
        audio_output :> audio_l
    );
    apu apu_processor_R <@clock_50mhz> (
        staticGenerator <: staticGenerator,
        audio_output :> audio_r
    );

    gpu gpu_processor <@video_clock,!video_reset> (
        bitmap_x_write :> bitmap_x_write,
        bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write,
        bitmap_write :> bitmap_write,
    );

    // SDCARD - Code for the SDCARD from @sylefeb
    simple_dualport_bram uint8 sdbuffer[512] = uninitialized;

    sdcardio sdcio;
    sdcard sd(
        // pins
        sd_clk      :> sd_clk,
        sd_mosi     :> sd_mosi,
        sd_csn      :> sd_csn,
        sd_miso     <: sd_miso,
        // io
        io          <:> sdcio,
        // bram port
        store       <:> sdbuffer
    );

    // UART input FIFO (4096 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartInBuffer[4096] = uninitialized;
    uint13  uartInBufferNext = 0;
    uint13  uartInBufferTop = 0;

    // UART output FIFO (16 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartOutBuffer[256] = uninitialized;
    uint8   uartOutBufferNext = 0;
    uint8   uartOutBufferTop = 0;
    uint8   newuartOutBufferTop = 0;

    // register buttons
    uint7 reg_btns = 0;
    reg_btns ::= btns;

    // UART Buffers
    uartInBuffer.wenable1  := 1;  // always write on port 1
    uartInBuffer.addr0     := uartInBufferNext; // FIFO reads on next
    uartInBuffer.addr1     := uartInBufferTop;  // FIFO writes on top

    uartOutBuffer.wenable1 := 1; // always write on port 1
    uartOutBuffer.addr0    := uartOutBufferNext; // FIFO reads on next
    uartOutBuffer.addr1    := uartOutBufferTop;  // FIFO writes on top

    // Setup the UART
    uo.data_in_ready := 0; // maintain low

    // SDCARD Commands
    sdcio.read_sector := 0;

    // RESET Timer Co-Processor Controls
    p1hz.resetCounter := 0;
    sleepTimer.resetCounter := 0;
    timer1hz.resetCounter := 0;
    timer1khz.resetCounter := 0;
    rng.resetRandom := 0;

    // RESET Co-Processor Controls
    background_generator.background_write := 0;
    tile_map.tm_write := 0;
    tile_map.tm_scrollwrap := 0;
    lower_sprites.sprite_layer_write := 0;
    lower_sprites.sprite_writer_active := 0;
    bitmap_window.bitmap_write_offset := 0;
    gpu_processor.gpu_write := 0;
    gpu_processor.draw_vector := 0;
    upper_sprites.sprite_layer_write := 0;
    upper_sprites.sprite_writer_active := 0;
    character_map_window.tpu_write := 0;
    terminal_window.terminal_write := 0;
    apu_processor_L.apu_write := 0;
    apu_processor_R.apu_write := 0;

    // UART input and output buffering
    uartInBuffer.wdata1  := ui.data_out;
    uartInBufferTop      := ( ui.data_out_ready ) ? uartInBufferTop + 1 : uartInBufferTop;

    uo.data_in      := uartOutBuffer.rdata0;
    uo.data_in_ready     := (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy );
    uartOutBufferNext := ( (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy ) ) ? uartOutBufferNext + 1 : uartOutBufferNext;

    // Setup the terminal
    terminal_window.showterminal = 1;
    terminal_window.showcursor = 1;

    while(1) {
        // Update UART output buffer top if character has been put into buffer
        uartOutBufferTop = newuartOutBufferTop;

        // READ IO Memory
        if( memoryRead ) {
            switch( memoryAddress ) {
                // UART, LEDS, BUTTONS and CLOCK
                case 16h8000: { readData = { 8b0, uartInBuffer.rdata0 }; uartInBufferNext = uartInBufferNext + 1; }
                case 16h8004: { readData = { 14b0, ( uartOutBufferTop + 1 == uartOutBufferNext ), ( uartInBufferNext != uartInBufferTop )}; }
                case 16h8008: { readData = { 9b0, reg_btns[0,7] }; }
                case 16h800c: { readData = leds; }
                case 16h8010: { readData = systemClock; }

                // BACKGROUND

                // TILE MAP
                case 16h8230: { readData = tile_map.tm_lastaction; }
                case 16h8234: { readData = tile_map.tm_active; }

                // LOWER SPRITE LAYER
                case 16h8304: { readData = lower_sprites.sprite_read_active; }
                case 16h8308: { readData = lower_sprites.sprite_read_tile; }
                case 16h830c: { readData = lower_sprites.sprite_read_colour; }
                case 16h8310: { readData = lower_sprites.sprite_read_x[10,1] ? 16hf800 : 16h0000 | lower_sprites.sprite_read_x; }
                case 16h8314: { readData = lower_sprites.sprite_read_y[10,1] ? 16hf800 : 16h0000 | lower_sprites.sprite_read_y; }
                case 16h8318: { readData = lower_sprites.sprite_read_double; }

                case 16h8330: { readData = lower_sprites.collision_0; }
                case 16h8332: { readData = lower_sprites.collision_1; }
                case 16h8334: { readData = lower_sprites.collision_2; }
                case 16h8336: { readData = lower_sprites.collision_3; }
                case 16h8338: { readData = lower_sprites.collision_4; }
                case 16h833a: { readData = lower_sprites.collision_5; }
                case 16h833c: { readData = lower_sprites.collision_6; }
                case 16h833e: { readData = lower_sprites.collision_7; }
                case 16h8340: { readData = lower_sprites.collision_8; }
                case 16h8342: { readData = lower_sprites.collision_9; }
                case 16h8344: { readData = lower_sprites.collision_10; }
                case 16h8346: { readData = lower_sprites.collision_11; }
                case 16h8348: { readData = lower_sprites.collision_12; }

                // GPU and BITMAP
                case 16h841c: { readData = gpu_processor.gpu_active; }
                case 16h8448: { readData = gpu_processor.vector_block_active; }
                case 16h8470: { readData = bitmap_window.bitmap_colour_read; }

                // UPPER SPRITE LAYER
                case 16h8504: { readData = upper_sprites.sprite_read_active; }
                case 16h8508: { readData = upper_sprites.sprite_read_tile; }
                case 16h850c: { readData = upper_sprites.sprite_read_colour; }
                case 16h8510: { readData = upper_sprites.sprite_read_x[10,1] ? 16hf800 : 16h0000 | upper_sprites.sprite_read_x; }
                case 16h8514: { readData = upper_sprites.sprite_read_y[10,1] ? 16hf800 : 16h0000 | upper_sprites.sprite_read_y; }
                case 16h8518: { readData = upper_sprites.sprite_read_double; }

                case 16h8530: { readData = upper_sprites.collision_0; }
                case 16h8532: { readData = upper_sprites.collision_1; }
                case 16h8534: { readData = upper_sprites.collision_2; }
                case 16h8536: { readData = upper_sprites.collision_3; }
                case 16h8538: { readData = upper_sprites.collision_4; }
                case 16h853a: { readData = upper_sprites.collision_5; }
                case 16h853c: { readData = upper_sprites.collision_6; }
                case 16h853e: { readData = upper_sprites.collision_7; }
                case 16h8540: { readData = upper_sprites.collision_8; }
                case 16h8542: { readData = upper_sprites.collision_9; }
                case 16h8544: { readData = upper_sprites.collision_10; }
                case 16h8546: { readData = upper_sprites.collision_11; }
                case 16h8548: { readData = upper_sprites.collision_12; }

                // CHARACTER MAP
                case 16h8614: { readData = character_map_window.tpu_active; }

                // TERMINAL
                case 16h8700: { readData = terminal_window.terminal_active; }

                // AUDIO
                case 16h8808: { readData = apu_processor_L.audio_active; }
                case 16h8818: { readData = apu_processor_R.audio_active; }

                // TIMERS and RNG
                case 16h8900: { readData = rng.g_noise_out; }
                case 16h8904: { readData = rng.u_noise_out; }
                case 16h8910: { readData = timer1hz.counter1hz; }
                case 16h8920: { readData = timer1khz.counter1khz; }
                case 16h8930: { readData = sleepTimer.counter1khz; }

                // SDCARD
                case 16h8f00: { readData = sdcio.ready; }
                case 16h8f10: { readData = sdbuffer.rdata0; }

                // VBLANK
                case 16h8ff0: { readData = vblank; }
            }
        }

        // WRITE IO Memory
        if( memoryWrite ) {
            switch( memoryAddress ) {
                // UART, LEDS
                case 16h8000: { uartOutBuffer.wdata1 = writeData[0,8]; newuartOutBufferTop = uartOutBufferTop + 1; }
                case 16h800c: { leds = writeData; }

                // BACKGROUND
                case 16h8100: { background_generator.backgroundcolour = writeData; background_generator.background_write = 1; }
                case 16h8104: { background_generator.backgroundcolour_alt = writeData; background_generator.background_write = 2; }
                case 16h8108: { background_generator.backgroundcolour_mode = writeData; background_generator.background_write = 3; }

                // TILE MAP
                case 16h8200: { tile_map.tm_x = writeData; }
                case 16h8204: { tile_map.tm_y = writeData; }
                case 16h8208: { tile_map.tm_character = writeData; }
                case 16h820c: { tile_map.tm_background = writeData; }
                case 16h8210: { tile_map.tm_foreground = writeData; }
                case 16h8214: { tile_map.tm_write = 1; }

                case 16h8220: { tile_map.tile_writer_tile = writeData; }
                case 16h8224: { tile_map.tile_writer_line = writeData; }
                case 16h8228: { tile_map.tile_writer_bitmap = writeData; }

                case 16h8230: { tile_map.tm_scrollwrap = writeData; }

                // LOWER SPRITE LAYER
                case 16h8300: { lower_sprites.sprite_set_number = writeData; }
                case 16h8304: { lower_sprites.sprite_set_active = writeData; lower_sprites.sprite_layer_write = 1; }
                case 16h8308: { lower_sprites.sprite_set_tile = writeData; lower_sprites.sprite_layer_write = 2; }
                case 16h830c: { lower_sprites.sprite_set_colour = writeData; lower_sprites.sprite_layer_write = 3; }
                case 16h8310: { lower_sprites.sprite_set_x = writeData; lower_sprites.sprite_layer_write = 4; }
                case 16h8314: { lower_sprites.sprite_set_y = writeData; lower_sprites.sprite_layer_write = 5; }
                case 16h8318: { lower_sprites.sprite_set_double = writeData; lower_sprites.sprite_layer_write = 6; }
                case 16h831c: { lower_sprites.sprite_update = writeData; lower_sprites.sprite_layer_write = 10; }

                case 16h8320: { lower_sprites.sprite_writer_sprite = writeData; }
                case 16h8324: { lower_sprites.sprite_writer_line = writeData; }
                case 16h8328: { lower_sprites.sprite_writer_bitmap = writeData; lower_sprites.sprite_writer_active = 1; }

                // GPU and BITMAP
                case 16h8400: { gpu_processor.gpu_x = writeData; }
                case 16h8404: { gpu_processor.gpu_y = writeData; }
                case 16h8408: { gpu_processor.gpu_colour = writeData; }
                case 16h840c: { gpu_processor.gpu_param0 = writeData; }
                case 16h8410: { gpu_processor.gpu_param1 = writeData; }
                case 16h8414: { gpu_processor.gpu_param2 = writeData; }
                case 16h8418: { gpu_processor.gpu_param3 = writeData; }
                case 16h841c: { gpu_processor.gpu_write = writeData; }

                case 16h8420: { gpu_processor.vector_block_number = writeData; }
                case 16h8424: { gpu_processor.vector_block_colour = writeData; }
                case 16h8428: { gpu_processor.vector_block_xc = writeData; }
                case 16h842c: { gpu_processor.vector_block_yc = writeData; }
                case 16h8430: { gpu_processor.draw_vector = 1; }

                case 16h8434: { gpu_processor.vertices_writer_block = writeData; }
                case 16h8438: { gpu_processor.vertices_writer_vertex = writeData; }
                case 16h843c: { gpu_processor.vertices_writer_xdelta = writeData; }
                case 16h8440: { gpu_processor.vertices_writer_ydelta = writeData; }
                case 16h8444: { gpu_processor.vertices_writer_active = writeData; }

                case 16h8450: { gpu_processor.blit1_writer_tile = writeData; }
                case 16h8454: { gpu_processor.blit1_writer_line = writeData; }
                case 16h8458: { gpu_processor.blit1_writer_bitmap = writeData; }

                case 16h8460: { bitmap_window.bitmap_write_offset = writeData; }

                case 16h8470: { bitmap_window.bitmap_x_read = writeData; }
                case 16h8474: { bitmap_window.bitmap_y_read = writeData; }

                // UPPER SPRITE LAYER
                case 16h8500: { upper_sprites.sprite_set_number = writeData; }
                case 16h8504: { upper_sprites.sprite_set_active = writeData; upper_sprites.sprite_layer_write = 1; }
                case 16h8508: { upper_sprites.sprite_set_tile = writeData; upper_sprites.sprite_layer_write = 2; }
                case 16h850c: { upper_sprites.sprite_set_colour = writeData; upper_sprites.sprite_layer_write = 3; }
                case 16h8510: { upper_sprites.sprite_set_x = writeData; upper_sprites.sprite_layer_write = 4; }
                case 16h8514: { upper_sprites.sprite_set_y = writeData; upper_sprites.sprite_layer_write = 5; }
                case 16h8518: { upper_sprites.sprite_set_double = writeData; upper_sprites.sprite_layer_write = 6; }
                case 16h851c: { upper_sprites.sprite_update = writeData; upper_sprites.sprite_layer_write = 10; }

                case 16h8520: { upper_sprites.sprite_writer_sprite = writeData; }
                case 16h8524: { upper_sprites.sprite_writer_line = writeData; }
                case 16h8528: { upper_sprites.sprite_writer_bitmap = writeData; upper_sprites.sprite_writer_active = 1; }

                // CHARACTER MAP
                case 16h8600: { character_map_window.tpu_x = writeData; }
                case 16h8604: { character_map_window.tpu_y = writeData; }
                case 16h8608: { character_map_window.tpu_character = writeData; }
                case 16h860c: { character_map_window.tpu_background = writeData; }
                case 16h8610: { character_map_window.tpu_foreground = writeData; }
                case 16h8614: { character_map_window.tpu_write = writeData; }

                // TERMINAL
                case 16h8700: { terminal_window.terminal_character = writeData; terminal_window.terminal_write = 1; }
                case 16h8704: { terminal_window.showterminal = writeData; }

                // AUDIO
                case 16h8800: { apu_processor_L.waveform = writeData; }
                case 16h8804: { apu_processor_L.note = writeData; }
                case 16h8808: { apu_processor_L.duration = writeData; }
                case 16h880c: { apu_processor_L.apu_write = writeData; }
                case 16h8810: { apu_processor_R.waveform = writeData; }
                case 16h8814: { apu_processor_R.note = writeData; }
                case 16h8818: { apu_processor_R.duration = writeData; }
                case 16h881c: { apu_processor_R.apu_write = writeData; }

                // TIMERS and RNG
                case 16h8900: { rng.resetRandom = 1; }
                case 16h8910: { timer1hz.resetCounter = 1; }
                case 16h8920: { timer1khz.resetCount = writeData; timer1khz.resetCounter = 1; }
                case 16h8930: { sleepTimer.resetCount = writeData; sleepTimer.resetCounter = 1; }

                // SDCARD
                case 16h8f00: { sdcio.read_sector = 1; }
                case 16h8f04: { sdcio.addr_sector[16,16] = writeData; }
                case 16h8f08: { sdcio.addr_sector[0,16] = writeData; }
                case 16h8f10: { sdbuffer.addr0 = writeData; }
            }
        }

    } // while(1)
}


import('../common/ulx3s_clk_risc_ice_v.v')
import('../common/ulx3s_clk_risc_ice_v_2.v')
import('../common/reset_conditioner.v')

// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV32I processor

// RISC-V BASE INSTRUCTION BITFIELDS
bitfield    Btype {
    uint1   immediate_bits_12,
    uint6   immediate_bits_10_5,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint4   immediate_bits_4_1,
    uint1   immediate_bits_11,
    uint7   opcode
}

bitfield    Itype {
    uint12  immediate,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    ItypeSHIFT {
    uint7   function7,
    uint5   shiftCount,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    Jtype {
    uint1   immediate_bits_20,
    uint10  immediate_bits_10_1,
    uint1   immediate_bits_11,
    uint8   immediate_bits_19_12,
    uint5   destReg,
    uint7   opcode
}

bitfield    Rtype {
    uint7   function7,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opCode
}

bitfield Stype {
    uint7   immediate_bits_11_5,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint5   immediate_bits_4_0,
    uint7   opcode
}

bitfield Utype {
    uint20  immediate_bits_31_12,
    uint5   destReg,
    uint7   opCode
}

// COMPRESSED Risc-V Instruction Bitfields
bitfield    CBalu {
    uint3   function3,
    uint1   ib_5,
    uint2   function2,
    uint3   rd_alt,
    uint2   logical2,
    uint3   rs2_alt,
    uint2   opcode
}
bitfield    CBalu50 {
    uint3   function3,
    uint1   ib_5,
    uint2   function2,
    uint3   rd_alt,
    uint5   ib_4_0,
    uint2   opcode
}
bitfield    CB {
    uint3   function3,
    uint1   offset_8,
    uint2   offset_4_3,
    uint3   rs1_alt,
    uint2   offset_7_6,
    uint2   offset_2_1,
    uint1   offset_5,
    uint2   opcode
}

bitfield    CI {
    uint3   function3,
    uint1   ib_5,
    uint5   rd,
    uint3   ib_4_2,
    uint2   ib_7_6,
    uint2   opcode
}
bitfield    CI50 {
    uint3   function3,
    uint1   ib_5,
    uint5   rd,
    uint5   ib_4_0,
    uint2   opcode
}
bitfield    CI94 {
    uint3   function3,
    uint1   ib_9,
    uint5   rd,
    uint1   ib_4,
    uint1   ib_6,
    uint2   ib_8_7,
    uint1   ib_5,
    uint2   opcode
}
bitfield    CIu94 {
    uint3   function3,
    uint2   ib_5_4,
    uint4   ib_9_6,
    uint1   ib_2,
    uint1   ib_3,
    uint3   rd_alt,
    uint2   opcode
}
bitfield    CIlui {
    uint3   function3,
    uint1   ib_17,
    uint5   rd,
    uint5   ib_16_12,
    uint2   opcode
}

bitfield    CJ {
    uint3   function3,
    uint1   ib_11,
    uint1   ib_4,
    uint2   ib_9_8,
    uint1   ib_10,
    uint1   ib_6,
    uint1   ib_7,
    uint3   ib_3_1,
    uint1   ib_5,
    uint2   opcode
}

bitfield    CL {
    uint3   function3,
    uint3   ib_5_3,
    uint3   rs1_alt,
    uint1   ib_2,
    uint1   ib_6,
    uint3   rd_alt,
    uint2   opcode
}

bitfield    CR {
    uint4   function4,
    uint5   rs1,
    uint5   rs2,
    uint2   opcode
}

bitfield    CS {
    uint3   function3,
    uint1   ib_5,
    uint2   ib_4_3,
    uint3   rs1_alt,
    uint1   ib_2,
    uint1   ib_6,
    uint3   rs2_alt,
    uint2   opcode
}

bitfield    CSS {
    uint3   function3,
    uint1   ib_5,
    uint3   ib_4_2,
    uint2   ib_7_6,
    uint5   rs2,
    uint2   opcode
}

algorithm main(
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // HDMI OUTPUT
    output  uint4   gpdi_dp,
    output  uint4   gpdi_dn,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // SDCARD
    output! uint1   sd_clk,
    output! uint1   sd_mosi,
    output! uint1   sd_csn,
    input   uint1   sd_miso,

    // SDRAM
    output uint1  sdram_cle,
    output uint2  sdram_dqm,
    output uint1  sdram_cs,
    output uint1  sdram_we,
    output uint1  sdram_cas,
    output uint1  sdram_ras,
    output uint2  sdram_ba,
    output uint13 sdram_a,
    output uint1  sdram_clk,  // sdram chip clock != internal sdram_clock
    inout  uint16 sdram_dq
) {
    // VGA/HDMI Display
    uint1   video_reset = uninitialized;
    uint1   video_clock = uninitialized;
    uint1   pll_lock_CPU = uninitialized;
    uint1   pll_lock_AUX = uninitialized;

    // Generate the 100MHz SDRAM and 25MHz VIDEO clocks
    uint1 clock_timers = uninitialized;
    uint1 clock_gpu = uninitialized;
    uint1 clock_copro = uninitialized;
    uint1 clock_memory = uninitialized;
    uint1 clock_cache = uninitialized;
    ulx3s_clk_risc_ice_v_CPU clk_gen_CPU (
        clkin    <: clock,
        clkCOPRO :> clock_copro,
        clkMEMORY  :> clock_memory,
        clkCACHE :> clock_cache,
        clkSDRAM  :> sdram_clk,
        locked   :> pll_lock_CPU
    );
    ulx3s_clk_risc_ice_v_AUX clk_gen_AUX (
        clkin    <: clock,
        clkTIMER  :> clock_timers,
        clkVIDEO  :> video_clock,
        clkGPU :> clock_gpu,
        locked   :> pll_lock_AUX
    );

    // Video Reset
    reset_conditioner vga_rstcond (
        rcclk <: video_clock ,
        in  <: reset,
        out :> video_reset
    );

    // Status of the screen, if in range, if in vblank, actual pixel x and y
    uint1   vblank = uninitialized;
    uint1   pix_active = uninitialized;
    uint10  pix_x  = uninitialized;
    uint10  pix_y  = uninitialized;

    // VGA or HDMI driver
    uint8   video_r = uninitialized;
    uint8   video_g = uninitialized;
    uint8   video_b = uninitialized;

    hdmi video<@clock,!reset> (
        vblank  :> vblank,
        active  :> pix_active,
        x       :> pix_x,
        y       :> pix_y,
        gpdi_dp :> gpdi_dp,
        gpdi_dn :> gpdi_dn,
        red     <: video_r,
        green   <: video_g,
        blue    <: video_b
    );

    // RISC-V REGISTERS
    simple_dualport_bram int32 registers_1<input!>[64] = { 0, pad(0) };
    simple_dualport_bram int32 registers_2<input!>[64] = { 0, pad(0) };

    // RISC-V PROGRAM COUNTER
    uint32  pc = 0;
    uint1   compressed = uninitialized;
    uint1   floatingpoint = uninitialized;
    uint1   takeBranch = uninitialized;
    uint1   incPC = uninitialized;

    // RISC-V INSTRUCTION and DECODE
    uint32  instruction = uninitialized;
    uint32  nop := { 12b000000000000, 5b00000, 3b000, 5b00000, 7b0010011 };

    uint7   opCode := Utype(instruction).opCode;
    uint3   function3 := Rtype(instruction).function3;
    uint7   function7 := Rtype(instruction).function7;

    // RISC-V SOURCE REGISTER VALUES and IMMEDIATE VALUE and DESTINATION REGISTER ADDRESS
    int32   sourceReg1 := registers_1.rdata0;
    int32   sourceReg2 := registers_2.rdata0;
    int32   immediateValue := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Itype(instruction).immediate };

    // RISC-V ALU RESULTS
    int32   result = uninitialized;
    uint1   writeRegister = uninitialized;

    // RISC-V ADDRESS CALCULATIONS
    uint32  branchOffset := { Btype(instruction).immediate_bits_12 ? 20b11111111111111111111 : 20b00000000000000000000, Btype(instruction).immediate_bits_11, Btype(instruction).immediate_bits_10_5, Btype(instruction).immediate_bits_4_1, 1b0 };
    uint32  jumpOffset := { Jtype(instruction).immediate_bits_20 ? 12b111111111111 : 12b000000000000, Jtype(instruction).immediate_bits_19_12, Jtype(instruction).immediate_bits_11, Jtype(instruction).immediate_bits_10_1, 1b0 };
    uint32  loadAddress := immediateValue + sourceReg1;
    uint32  storeAddress := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Stype(instruction).immediate_bits_11_5, Stype(instruction).immediate_bits_4_0 } + sourceReg1;

    // Setup Memory Mapped I/O
    memmap_io IO_Map (
        leds :> leds,
        btns <: btns,

        // UART
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,

        // AUDIO
        audio_l :> audio_l,
        audio_r :> audio_r,

        // SDCARD
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,

        // HDMI
        video_r :> video_r,
        video_g :> video_g,
        video_b :> video_b,
        vblank <: vblank,
        pix_active <: pix_active,
        pix_x <: pix_x,
        pix_y <: pix_y,

        // CLOCKS
        clock_50mhz <: clock_timers,
        clock_25mhz <: clock,
        video_clock <: video_clock,
        gpu_clock <: clock_gpu,
        video_reset <: video_reset
    );

    // RAM - BRAM ( and eventually SDRAM )
    ramcontrollerBRAM ram <@clock_memory> ();
    ramcontrollerSDRAM sdramcache <@clock_cache> ();

    // SIGN EXTENDER UNIT
    signextender signextenderunit <@clock_copro> (
        function3 <: function3
    );

    // COMPRESSED INSTRUCTION EXPANDER
    compressedexpansion compressedunit <@clock_copro> ();

    // ADDITION/SUBTRACTION, SHIFTER, BINARY LOGIC, MULTIPLICATION and DIVISION units
    additionsubtraction addsubunit <@clock_copro> (
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        opCode <: opCode,
        function7 <: function7
    );
    shifter shiftunit <@clock_copro> (
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        instruction <: instruction,
        opCode <: opCode,
        function7 <: function7
    );
    logical logicalunit <@clock_copro> (
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        opCode <: opCode,
    );
    comparison comparisonunit <@clock_copro> (
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        immediateValue <: immediateValue,
        instruction <: instruction
    );
    divideremainder dividerunit <@clock_copro> (
        dividend <: sourceReg1,
        divisor <: sourceReg2
    );
    multiplicationDSP multiplicationuint <@clock_copro> (
        factor_1 <: sourceReg1,
        factor_2 <: sourceReg2
    );
    branchcomparison branchcomparisonunit <@clock_copro> (
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        function3 <: function3
    );

    // MULTIPLICATION and DIVISION Start Flags
    dividerunit.start := 0;
    multiplicationuint.start := 0;

    // RAM/IO Read/Write Flags
    ram.writeflag := 0;
    sdramcache.readflag := 0;
    sdramcache.writeflag := 0;
    IO_Map.memoryWrite := 0;
    IO_Map.memoryRead := 0;

    // REGISTER Read/Write Flags
    registers_1.addr0 := Rtype(instruction).sourceReg1 + ( floatingpoint ? 32 : 0 );
    registers_1.wenable1 := 1;
    registers_2.addr0 := Rtype(instruction).sourceReg2 + ( floatingpoint ? 32 : 0 );
    registers_2.wenable1 := 1;

    while(1) {
        // RISC-V
        writeRegister = 0;
        takeBranch = 0;
        incPC = 1;
        floatingpoint = 0;

        // FETCH + EXPAND COMPRESSED INSTRUCTIONS
        if( pc[28,1] ) {
            sdramcache.address = pc;
            sdramcache.Icache = 1;
            sdramcache.readflag = 1;
            while( sdramcache.busy ) {}
        } else {
            ram.address = pc;
        }
        ++:
        switch( pc[28,1] ? sdramcache.readdata[0,2] : ram.readdata[0,2] ) {
            default: { compressed = 1; compressedunit.instruction16 = pc[28,1] ? sdramcache.readdata : ram.readdata; instruction = compressedunit.instruction32; }
            case 2b11: {
                compressed = 0;
                instruction = { 16b0, pc[28,1] ? sdramcache.readdata : ram.readdata };
                if( pc[28,1] ) {
                    sdramcache.address = pc + 2;
                    sdramcache.Icache = 1;
                    sdramcache.readflag = 1;
                    while( sdramcache.busy ) {}
                } else {
                    ram.address = pc + 2;
                }
                ++:
                instruction = { pc[28,1] ? sdramcache.readdata : ram.readdata, instruction[0,16] };
            }
        }
        ++:
        ++:

        // DECODE + EXECUTE

        switch( { opCode[6,1], opCode[4,1] } ) {
            case 2b00: {
                // LOAD STORE
                switch( opCode[5,1] ) {
                    case 1b0: {
                        // LOAD executes even if rd == 0 as may be discarding values in a buffer
                        writeRegister = 1;
                        if( ( loadAddress[28,1] == 0 ) && loadAddress[15,1] ) {
                            // I/O
                            IO_Map.memoryAddress = loadAddress[0,16];
                            IO_Map.memoryRead = 1;
                            switch( function3 & 3 ) {
                                case 2b10: { result = { 16h0000, IO_Map.readData }; }
                                default: {
                                    signextenderunit.nosign = IO_Map.readData;
                                    result = signextenderunit.withsign;
                                }
                            }
                        } else {
                            // SDRAM or BRAM
                            if( loadAddress[28,1] ) {
                                sdramcache.address = loadAddress;
                                sdramcache.Icache = 0;
                                sdramcache.readflag = 1;
                                while( sdramcache.busy ) {}
                            } else {
                                ram.address = loadAddress;
                            }
                            ++:
                            switch( function3 & 3 ) {
                                case 2b00: {
                                    signextenderunit.nosign = loadAddress[28,1] ? ( sdramcache.readdata[loadAddress[0,1] ? 8 : 0, 8] ): ( ram.readdata[loadAddress[0,1] ? 8 : 0, 8] );
                                    result = signextenderunit.withsign;
                               }
                                case 2b01: {
                                    signextenderunit.nosign = loadAddress[28,1] ? sdramcache.readdata : ram.readdata;
                                    result = signextenderunit.withsign;
                                }
                                case 2b10: {
                                    result = { 16h0000, loadAddress[28,1] ? sdramcache.readdata : ram.readdata };
                                    if( loadAddress[28,1] ) {
                                        sdramcache.address = loadAddress + 2;
                                        sdramcache.Icache = 0;
                                        sdramcache.readflag = 1;
                                        while( sdramcache.busy ) {}
                                    } else {
                                        ram.address = loadAddress + 2;
                                    }
                                    ++:
                                    result = { loadAddress[28,1] ? sdramcache.readdata : ram.readdata, result[0,16] };
                                }
                            }
                        }
                    }
                    case 1b1: {
                        // STORE
                        if( ( storeAddress[28,1] == 0 ) && storeAddress[15,1] ) {
                            // I/O
                            IO_Map.memoryAddress = storeAddress[0,16];
                            IO_Map.writeData = __unsigned( sourceReg2[0,16] );
                            IO_Map.memoryWrite = 1;
                        } else {
                            // SDRAM or BRAM
                            sdramcache.address = storeAddress;
                            ram.address = storeAddress;
                            switch( function3 & 3 ) {
                                case 2b00: {
                                    // 8 BIT, READ MODIFY WRITE
                                    if( storeAddress[28,1] ) {
                                        sdramcache.Icache = 0;
                                        sdramcache.readflag = 1;
                                        while( sdramcache.busy ) {}
                                        sdramcache.writedata = storeAddress[0,1] ? { sourceReg2[0,8], sdramcache.readdata[0,8] } : { sdramcache.readdata[8,8], sourceReg2[0,8] };
                                        sdramcache.writeflag = 1;
                                    } else {
                                        ++:
                                        ram.writedata = storeAddress[0,1] ? { sourceReg2[0,8], ram.readdata[0,8] } : { ram.readdata[8,8], sourceReg2[0,8] };
                                        ram.writeflag = 1;
                                    }
                                }
                                case 2b01: {
                                   if( storeAddress[28,1] ) {
                                        sdramcache.writedata = sourceReg2[0,16];
                                        sdramcache.writeflag = 1;
                                    } else {
                                        ram.writedata = sourceReg2[0,16];
                                        ram.writeflag = 1;
                                    }
                                }
                                case 2b10: {
                                   if( storeAddress[28,1] ) {
                                        sdramcache.writedata = sourceReg2[0,16];
                                        sdramcache.writeflag = 1;
                                    } else {
                                        ram.writedata = sourceReg2[0,16];
                                        ram.writeflag = 1;
                                    }
                                    ++:
                                   if( storeAddress[28,1] ) {
                                        sdramcache.address = storeAddress + 2;
                                        sdramcache.writedata = sourceReg2[16,16];
                                        sdramcache.writeflag = 1;
                                    } else {
                                        ram.address = storeAddress + 2;
                                        ram.writedata = sourceReg2[16,16];
                                        ram.writeflag = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // AUIPC LUI ALUI ALUR
            case 2b01: {
                writeRegister = 1;

                switch( opCode[2,1] ) {
                    // ALU BASE & M EXTENSION
                    case 1b0: {
                        if( opCode[5,1] && function7[0,1] ) {
                            // M EXTENSION
                            switch( function3[2,1] ) {
                                case 1b0: {
                                    // MULTIPLICATION
                                    multiplicationuint.dosigned =  function3[1,1] ? ( function3[0,1] ? 0 : 2 ) : 1;
                                    multiplicationuint.start = 1;
                                    ++:
                                    while( multiplicationuint.active ) {}
                                    result = ( function3 == 0 ) ? multiplicationuint.product[0,32] : multiplicationuint.product[32,32];
                                }
                                case 1b1: {
                                    // DIVISION / REMAINDER
                                    dividerunit.dosigned = function3[0,1] ? 0 : 1;
                                    dividerunit.start = 1;
                                    ++:
                                    while( dividerunit.active ) {}
                                    result = function3[1,1] ? dividerunit.remainder : dividerunit.quotient;
                                }
                            }
                        } else {
                            // BASE I ALU OPERATIONS
                            switch( function3 ) {
                                case 3b000: { result = addsubunit.result; }
                                case 3b001: { result = shiftunit.shiftLEFT; }
                                case 3b010: { result = ( opCode[5,1] ? comparisonunit.SLT : comparisonunit.SLTI ) ? 32b1 : 32b0; }
                                case 3b011: { result = ( opCode[5,1] ? comparisonunit.SLTU : comparisonunit.SLTUI ) ? 32b1 : 32b0; }
                                case 3b100: { result = logicalunit.XOR; }
                                case 3b101: { result = function7[5,1] ? shiftunit.shiftRIGHTA : shiftunit.shiftRIGHTL; }
                                case 3b110: { result = logicalunit.OR; }
                                case 3b111: { result = logicalunit.AND; }
                            }
                        }
                    }
                    // AUIPC LUI
                    case 1b1: { result = { Utype(instruction).immediate_bits_31_12, 12b0 } + ( opCode[5,1] ? 0 : pc ); }
                }
            }

            case 2b10: {
                // JUMP BRANCH
                switch( opCode[2,1] ) {
                    // BRANCH on CONDITION
                    case 1b0: { takeBranch = branchcomparisonunit.takeBranch; }
                    // JUMP AND LINK / JUMP AND LINK REGISTER
                    case 1b1: { writeRegister = 1; incPC = 0; result = pc + ( compressed ? 2 : 4 ); }
                }
            }

            // FORCE registers to BRAM - NO FLOATING POINT AT PRESENT!
            default: { floatingpoint = 1; }
        }

        ++:

        // WRITE TO REGISTERS
        // NEVER write to registers[0]
        if( writeRegister && ( Rtype(instruction).destReg != 0 ) ) {
            registers_1.addr1 = Rtype(instruction).destReg + ( floatingpoint ? 32 : 0 );
            registers_1.wdata1 = result;
            registers_2.addr1 = Rtype(instruction).destReg + ( floatingpoint ? 32 : 0 );
            registers_2.wdata1 = result;
        }

        // UPDATE PC
        pc = ( incPC ) ? pc + ( ( takeBranch) ? branchOffset : ( compressed ? 2 : 4 ) ) : ( opCode[3,1] ? jumpOffset + pc : loadAddress );
    } // RISC-V
}


// EXPAND RISC-V 16 BIT COMPRESSED INSTRUCTIONS TO THEIR 32 BIT EQUIVALENT

algorithm compressedexpansion (
    input   uint16  instruction16,
    output  uint32  instruction32
) <autorun> {
    while(1) {
        switch( instruction16[0,2] ) {
            case 2b00: {
                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // ADDI4SPN -> addi rd', x2, nzuimm[9:2]
                        // { 000, nzuimm[5:4|9:6|2|3] rd' 00 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32= { 2b0, CIu94(instruction16).ib_9_6, CIu94(instruction16).ib_5_4, CIu94(instruction16).ib_3, CIu94(instruction16).ib_2, 2b00, 5h2, 3b000, {2b01,CIu94(instruction16).rd_alt}, 7b0010011 };
                    }
                    case 3b001: {
                        // FLD
                    }
                    case 3b010: {
                        // LW -> lw rd', offset[6:2](rs1')
                        // { 010 uimm[5:3] rs1' uimm[2][6] rd' 00 } -> { imm[11:0] rs1 010 rd 0000011 }
                        instruction32= { 5b0, CL(instruction16).ib_6, CL(instruction16).ib_5_3, CL(instruction16).ib_2, 2b00, {2b01,CL(instruction16).rs1_alt}, 3b010, {2b01,CL(instruction16).rd_alt}, 7b0000011};
                    }
                    case 3b011: {
                        // FLW
                    }
                    case 3b100: {
                        // reserved
                    }
                    case 3b101: {
                        // FSD
                    }
                    case 3b110: {
                        // SW -> sw rs2', offset[6:2](rs1')
                        // { 110 uimm[5:3] rs1' uimm[2][6] rs2' 00 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                        instruction32= { 5b0, CS(instruction16).ib_6, CS(instruction16).ib_5, {2b01,CS(instruction16).rs2_alt}, {2b01,CS(instruction16).rs1_alt}, 3b010, CS(instruction16).ib_4_3, CS(instruction16).ib_2, 2b0, 7b0100011 };
                    }
                    case 3b111: {
                        // FSW
                    }
                }
            }
            case 2b01: {
                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // ADDI -> addi rd, rd, nzimm[5:0]
                        // { 000 nzimm[5] rs1/rd!=0 nzimm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32= { CI50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CI50(instruction16).ib_4_0, CI50(instruction16).rd, 3b000, CI50(instruction16).rd, 7b0010011 };
                    }
                    case 3b001: {
                        // JAL -> jal x1, offset[11:1]
                        // { 001, imm[11|4|9:8|10|6|7|3:1|5] 01 } -> { imm[20|10:1|11|19:12] rd 1101111 }
                        instruction32= { CJ(instruction16).ib_11, CJ(instruction16).ib_10, CJ(instruction16).ib_9_8, CJ(instruction16).ib_7, CJ(instruction16).ib_6, CJ(instruction16).ib_5, CJ(instruction16).ib_4, CJ(instruction16).ib_3_1, CJ(instruction16).ib_11 ? 9b111111111 : 9b000000000, 5h1, 7b1101111 };
                    }
                    case 3b010: {
                        // LI -> addi rd, x0, imm[5:0]
                        // { 010 imm[5] rd!=0 imm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32= { CI50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CI50(instruction16).ib_4_0, 5h0, 3b000, CI(instruction16).rd, 7b0010011 };
                    }
                    case 3b011: {
                        // LUI / ADDI16SP
                        if( ( CI(instruction16).rd != 0 ) && ( CI(instruction16).rd != 2 ) ) {
                            // LUI -> lui rd, nzuimm[17:12]
                            // { 011 nzimm[17] rd!={0,2} nzimm[16:12] 01 } -> { imm[31:12] rd 0110111 }
                            instruction32= { CIlui(instruction16).ib_17 ? 15b111111111111111 : 15b000000000000000, CIlui(instruction16).ib_16_12, CIlui(instruction16).rd, 7b0110111 };
                        } else {
                            // ADDI16SP -> addi x2, x2, nzimm[9:4]
                            // { 011 nzimm[9] 00010 nzimm[4|6|8:7|5] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                            instruction32= { CI94(instruction16).ib_9 ? 3b111 : 3b000, CI94(instruction16).ib_8_7, CI94(instruction16).ib_6, CI94(instruction16).ib_5, CI94(instruction16).ib_4, 4b0000, 5h2, 3b000, 5h2, 7b0010011 };
                        }
                    }
                    case 3b100: {
                        // MISC-ALU
                        switch( CBalu(instruction16).function2 ) {
                            case 2b00: {
                                // SRLI -> srli rd', rd', shamt[5:0]
                                // { 100 nzuimm[5] 00 rs1'/rd' nzuimm[4:0] 01 } -> { 0000000 shamt rs1 101 rd 0010011 }
                                instruction32= { 7b0000000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b101, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b01: {
                                // SRAI -> srai rd', rd', shamt[5:0]
                                // { 100 nzuimm[5] 01 rs1'/rd' nzuimm[4:0] 01 } -> { 0100000 shamt rs1 101 rd 0010011 }
                                instruction32= { 7b0100000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b101, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b10: {
                                // ANDI -> andi rd', rd', imm[5:0]
                                // { 100 imm[5], 10 rs1'/rd' imm[4:0] 01 } -> { imm[11:0] rs1 111 rd 0010011 }
                                instruction32= { CBalu50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b111, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b11: {
                                // SUB XOR OR AND
                                switch( CBalu(instruction16).logical2 ) {
                                    case 2b00: {
                                        //SUB -> sub rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 00 rs2' 01 } -> { 0100000 rs2 rs1 000 rd 0110011 }
                                        instruction32= { 7b0100000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b000, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b01: {
                                        // XOR -> xor rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 01 rs2' 01 } -> { 0000000 rs2 rs1 100 rd 0110011 }
                                        instruction32= { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b100, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b10: {
                                        // OR -> or rd', rd', rd2'
                                        // { 100 0 11 rs1'/rd' 10 rs2' 01 } -> { 0000000 rs2 rs1 110 rd 0110011 }
                                        instruction32= { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b110, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b11: {
                                        // AND -> and rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 11 rs2' 01 } -> { 0000000 rs2 rs1 111 rd 0110011 }
                                        instruction32= { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b111, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                }
                            }
                        }
                    }
                    case 3b101: {
                        // J -> jal, x0, offset[11:1]
                        // { 101, imm[11|4|9:8|10|6|7|3:1|5] 01 } -> { imm[20|10:1|11|19:12] rd 1101111 }
                        instruction32= { CJ(instruction16).ib_11, CJ(instruction16).ib_10, CJ(instruction16).ib_9_8, CJ(instruction16).ib_7, CJ(instruction16).ib_6, CJ(instruction16).ib_5, CJ(instruction16).ib_4, CJ(instruction16).ib_3_1, CJ(instruction16).ib_11 ? 9b111111111 : 9b000000000, 5h0, 7b1101111 };
                    }
                    case 3b110: {
                        // BEQZ -> beq rs1', x0, offset[8:1]
                        // { 110, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 000 imm[4:1|11] 1100011 }
                        instruction32= { CB(instruction16).offset_8 ? 4b1111 : 4b0000, CB(instruction16).offset_7_6, CB(instruction16).offset_5, 5h0, {2b01,CB(instruction16).rs1_alt}, 3b000, CB(instruction16).offset_4_3, CB(instruction16).offset_2_1, CB(instruction16).offset_8, 7b1100011 };
                    }
                    case 3b111: {
                        // BNEZ -> bne rs1', x0, offset[8:1]
                        // { 111, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 001 imm[4:1|11] 1100011 }
                        instruction32= { CB(instruction16).offset_8 ? 4b1111 : 4b0000, CB(instruction16).offset_7_6, CB(instruction16).offset_5, 5h0, {2b01,CB(instruction16).rs1_alt}, 3b001, CB(instruction16).offset_4_3, CB(instruction16).offset_2_1, CB(instruction16).offset_8, 7b1100011 };
                    }
                }
            }
            case 2b10: {
                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // SLLI -> slli rd, rd, shamt[5:0]
                        // { 000, nzuimm[5], rs1/rd!=0 nzuimm[4:0] 10 } -> { 0000000 shamt rs1 001 rd 0010011 }
                        instruction32= { 7b0000000, CI50(instruction16).ib_4_0, CI50(instruction16).rd, 3b001, CI50(instruction16).rd, 7b0010011 };
                    }
                    case 3b001: {
                        // FLDSP
                    }
                    case 3b010: {
                        // LWSP -> lw rd, offset[7:2](x2)
                        // { 011 uimm[5] rd uimm[4:2|7:6] 10 } -> { imm[11:0] rs1 010 rd 0000011 }
                        instruction32= { 4b0, CI(instruction16).ib_7_6, CI(instruction16).ib_5, CI(instruction16).ib_4_2, 2b0, 5h2 ,3b010, CI(instruction16).rd, 7b0000011 };
                    }
                    case 3b011: {
                        // FLWSP
                    }
                    case 3b100: {
                        // J[AL]R / MV / ADD
                        switch( instruction16[12,1] ) {
                            case 1b0: {
                                // JR / MV
                                if( CR(instruction16).rs2 == 0 ) {
                                    // JR -> jalr x0, rs1, 0
                                    // { 100 0 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                                    instruction32= { 12b0, CR(instruction16).rs1, 3b000, 5h0, 7b1100111 };
                                } else {
                                    // MV -> add rd, x0, rs2
                                    // { 100 0 rd!=0 rs2!=0 10 } -> { 0000000 rs2 rs1 000 rd 0110011 }
                                    instruction32= { 7b0000000, CR(instruction16).rs2, 5h0, 3b000, CR(instruction16).rs1, 7b0110011 };
                                }
                            }
                            case 1b1: {
                                // JALR / ADD
                                if( CR(instruction16).rs2 == 0 ) {
                                    // JALR -> jalr x1, rs1, 0
                                    // { 100 1 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                                    instruction32= { 12b0, CR(instruction16).rs1, 3b000, 5h1, 7b1100111 };
                                } else {
                                    // ADD -> add rd, rd, rs2
                                    // { 100 1 rs1/rd!=0 rs2!=0 10 } -> { 0000000 rs2 rs1 000 rd 0110011 }
                                    instruction32= { 7b0000000, CR(instruction16).rs2, CR(instruction16).rs1, 3b000, CR(instruction16).rs1, 7b0110011 };
                                }
                            }
                        }
                    }
                    case 3b101: {
                        // FSDSP
                    }
                    case 3b110: {
                        // SWSP -> sw rs2, offset[7:2](x2)
                        // { 110 uimm[5][4:2][7:6] rs2 10 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                        instruction32= { 4b0, CSS(instruction16).ib_7_6, CSS(instruction16).ib_5, CSS(instruction16).rs2, 5h2, 3b010, CSS(instruction16).ib_4_2, 2b00, 7b0100011 };
                    }
                    case 3b111: {
                        // FSWSP
                    }
                }
            }
            case 2b11: {
                instruction32= { 16b0, instruction16 };
            }
        }
    }
}

// PERFORM OPTIONAL SIGN EXTENSION FOR 8 BIT AND 16 BIT READS

algorithm signextender (
    input   uint16  nosign,
    output  uint32  withsign,
    input   uint3   function3
) <autorun> {
    while(1) {
        switch( function3 & 3 ) {
            case 2b00: {
                withsign = { ( ( nosign[7,1] & ~function3[2,1] ) ? 24hffffff : 24h000000 ), nosign[0,8] };
            }
            case 2b01: {
                withsign = { ( nosign[15,1] & ~function3[2,1] ) ? 16hffff : 16h0000, nosign };
            }
        }
    }
}

// RAM - BRAM controller and SDRAM controller ( with simple write-through cache )
// MEMORY IS 16 BIT, 8 BIT WRITES HAVE TO BE HANDLED BY THE CPU DOING READ MODIFY WRITE
// NOTES: AT PRESENT NO INTERACTION WITH THE SDRAM, CACHE ACTS AS 4K x 16 bit memory for proof of concept
// LOGIC FOR CACHE HIT AND MISS IN PLACE
// NEEDS A BUSY FLAG FOR WHEN CACHE MISS AND FOR SDRAM WRITES TO TAKE PLACE

algorithm ramcontrollerBRAM (
    input   uint32  address,
    input   uint16  writedata,
    output  uint16  readdata,
    input   uint1   writeflag
) <autorun> {
    // RISC-V RAM and BIOS
    bram uint16 ram<input!>[8192] = {
    16h4137, 16h0000, 16h0097, 16h0000,
    16h80e7, 16h3fc0, 16h0317, 16h0000,
    16h0067, 16h0083, 16h0000, 16h0000,
    16h8082, 16h1637, 16h0000, 16h0613,
    16h5346, 16h0713, 16h03c6, 16h6585,
    16h8593, 16h2fc5, 16h95b2, 16h0693,
    16h0230, 16ha029, 16h0713, 16h03c7,
    16h0a63, 16h00b7, 16h0793, 16hfc47,
    16h8023, 16h00d7, 16h0785, 16h9de3,
    16hfee7, 16hb7ed, 16h6685, 16h8693,
    16h2c06, 16h96b2, 16h87b2, 16h0713,
    16h02a0, 16h8023, 16h00e7, 16h8da3,
    16h02e7, 16h8d23, 16h02e7, 16h8793,
    16h03c7, 16h98e3, 16hfed7, 16h27b7,
    16h0000, 16h8793, 16h77c7, 16h6705,
    16h0713, 16h2847, 16h963a, 16h75fd,
    16h8593, 16hdb85, 16h0713, 16h02a0,
    16h86b3, 16h00b7, 16h8023, 16h00e6,
    16h8e23, 16h02e7, 16h8023, 16h00e7,
    16h0785, 16h97e3, 16hfec7, 16h17b7,
    16h0000, 16h8793, 16h5347, 16h0713,
    16h0450, 16h80a3, 16h00e7, 16h6705,
    16h97ba, 16h0713, 16h0580, 16h80a3,
    16h28e7, 16h8082, 16h715d, 16hc686,
    16hc4a2, 16hc2a6, 16hc0ca, 16hde4e,
    16hdc52, 16hda56, 16hd85a, 16hd65e,
    16hd462, 16hd266, 16hd06a, 16hce6e,
    16hc42a, 16hc62e, 16h17b7, 16h0000,
    16h8793, 16h5347, 16hc23e, 16h479d,
    16hc03e, 16h4d81, 16h0993, 16h02a0,
    16h0c13, 16h0450, 16h0b93, 16h0580,
    16h0b13, 16h0200, 16ha0d9, 16h8263,
    16h0987, 16h9f63, 16h0377, 16h9713,
    16h0104, 16h8741, 16h86e6, 16h1613,
    16h0104, 16h8641, 16h85ea, 16h0513,
    16h03c0, 16h1097, 16h0000, 16h80e7,
    16h94e0, 16ha839, 16h9713, 16h0104,
    16h8741, 16h86e6, 16h1613, 16h0104,
    16h8641, 16h85ea, 16h0513, 16h0300,
    16h1097, 16h0000, 16h80e7, 16h9300,
    16h0905, 16h0421, 16h0442, 16h8041,
    16h04a1, 16h04c2, 16h80c1, 16h0963,
    16h0544, 16h4783, 16h0009, 16h87e3,
    16hfd37, 16he2e3, 16hfaf9, 16h8263,
    16h0367, 16h9fe3, 16hfd57, 16h9713,
    16h0104, 16h8741, 16h86e6, 16h1613,
    16h0104, 16h8641, 16h85ea, 16h450d,
    16h1097, 16h0000, 16h80e7, 16h8f00,
    16hb7c1, 16h9713, 16h0104, 16h8741,
    16h86e6, 16h1613, 16h0104, 16h8641,
    16h85ea, 16h0513, 16h03f0, 16h1097,
    16h0000, 16h80e7, 16h8d20, 16hb74d,
    16h0da1, 16h0dc2, 16hdd93, 16h010d,
    16h4782, 16h07a1, 16h07c2, 16h83c1,
    16hc03e, 16h4792, 16h8793, 16h03c7,
    16hc23e, 16h0793, 16h2800, 16h8063,
    16h02fd, 16h9d13, 16h010d, 16h5d13,
    16h410d, 16h1c83, 16h0001, 16h4912,
    16h449d, 16h4401, 16h0a93, 16h0230,
    16h0a13, 16h1e00, 16hbf9d, 16h47a2,
    16h9593, 16h0037, 16h05c2, 16h81c1,
    16h47b2, 16h9613, 16h0037, 16h0642,
    16h8241, 16h0713, 16h0076, 16h8693,
    16h0075, 16h0742, 16h8741, 16h06c2,
    16h86c1, 16h0642, 16h8641, 16h05c2,
    16h85c1, 16h4531, 16h1097, 16h0000,
    16h80e7, 16h85c0, 16h40b6, 16h4426,
    16h4496, 16h4906, 16h59f2, 16h5a62,
    16h5ad2, 16h5b42, 16h5bb2, 16h5c22,
    16h5c92, 16h5d02, 16h4df2, 16h6161,
    16h8082, 16h7139, 16hde06, 16hdc22,
    16hda26, 16hd84a, 16hd64e, 16hd452,
    16hd256, 16hd05a, 16hce5e, 16hcc62,
    16hca66, 16hc86a, 16hc66e, 16h0513,
    16h0500, 16h0097, 16h0000, 16h80e7,
    16h4140, 16h892a, 16h7793, 16h0015,
    16he791, 16h0913, 16h0015, 16h0942,
    16h5913, 16h0109, 16h0513, 16h03c0,
    16h0097, 16h0000, 16h80e7, 16h3f60,
    16h89aa, 16h7793, 16h0015, 16he791,
    16h0993, 16h0015, 16h09c2, 16hd993,
    16h0109, 16h17b7, 16h0000, 16h1713,
    16h0049, 16h0733, 16h4127, 16h070a,
    16h8793, 16h5347, 16h97ba, 16h97ce,
    16h0713, 16h0200, 16h8023, 16h00e7,
    16h0d13, 16h0200, 16h4b09, 16h1bb7,
    16h0000, 16h8b93, 16h534b, 16h0413,
    16h0230, 16h6c05, 16h0c13, 16h2bfc,
    16h9c5e, 16ha211, 16h89d6, 16h8952,
    16h1063, 16h0595, 16h7e63, 16h035b,
    16h8993, 16hffea, 16h09c2, 16hd993,
    16h0109, 16ha03d, 16h0793, 16h04c0,
    16he263, 16h0347, 16h0913, 16h002a,
    16h0942, 16h5913, 16h0109, 16h89d6,
    16ha821, 16h7263, 16h074b, 16h0913,
    16hffea, 16h0942, 16h5913, 16h0109,
    16h89d6, 16ha019, 16h89d6, 16h8952,
    16h1793, 16h0049, 16h87b3, 16h4127,
    16h078a, 16h97de, 16h97ce, 16hc783,
    16h0007, 16h8163, 16h0487, 16h14fd,
    16h04c2, 16h80c1, 16hcca5, 16h8ace,
    16h8a4a, 16h4511, 16h0097, 16h0000,
    16h80e7, 16h33a0, 16h0fe3, 16hfb65,
    16h66e3, 16hf8ab, 16hd145, 16he963,
    16h015d, 16h8993, 16h002a, 16h09c2,
    16hd993, 16h0109, 16h8952, 16hbf6d,
    16h89d6, 16h8952, 16hbf55, 16h89d6,
    16h8952, 16hb77d, 16h1793, 16h0049,
    16h87b3, 16h4127, 16h078a, 16h97de,
    16h97ce, 16h8023, 16h01a7, 16h0733,
    16h012a, 16h5793, 16h01f7, 16h97ba,
    16hd713, 16h4017, 16h86b3, 16h013a,
    16hd793, 16h01f6, 16h97b6, 16hd693,
    16h4017, 16h1793, 16h0047, 16h8f99,
    16h078a, 16h97de, 16h97b6, 16h8023,
    16h01a7, 16hb751, 16h8693, 16h077b,
    16h4605, 16ha831, 16h0789, 16h8863,
    16h00d7, 16hc703, 16h0007, 16h1be3,
    16hfe87, 16h8626, 16hbfc5, 16h8693,
    16h0786, 16h8563, 16h0186, 16h8793,
    16hfc66, 16hb7e5, 16hee11, 16h85ce,
    16h854a, 16h0097, 16h0000, 16h80e7,
    16hcf20, 16h8ace, 16h8a4a, 16h84ea,
    16h4c8d, 16h0d93, 16h0380, 16hb7b1,
    16h50f2, 16h5462, 16h54d2, 16h5942,
    16h59b2, 16h5a22, 16h5a92, 16h5b02,
    16h4bf2, 16h4c62, 16h4cd2, 16h4d42,
    16h4db2, 16h6121, 16h8082, 16h8082,
    16h1141, 16hc606, 16hc422, 16h1437,
    16h0000, 16h1097, 16h0000, 16h80e7,
    16hd360, 16h4501, 16h1097, 16h0000,
    16h80e7, 16he820, 16h0097, 16h0000,
    16h80e7, 16hbfe0, 16h0097, 16h0000,
    16h80e7, 16he0e0, 16h4585, 16h4505,
    16h0097, 16h0000, 16h80e7, 16hc8c0,
    16h46b1, 16h0613, 16h0400, 16h4581,
    16h4501, 16h1097, 16h0000, 16h80e7,
    16hd180, 16h0513, 16h5104, 16h1097,
    16h0000, 16h80e7, 16hd7a0, 16h0097,
    16h0000, 16h80e7, 16h4740, 16h8909,
    16hd97d, 16h1097, 16h0000, 16h80e7,
    16hcde0, 16hb745, 16hc515, 16h4781,
    16h4629, 16h4309, 16h48a5, 16h76b3,
    16h02c5, 16h882a, 16h5533, 16h02c5,
    16h0733, 16h40f3, 16h972e, 16h8693,
    16h0306, 16h0023, 16h00d7, 16h0785,
    16hf793, 16h0ff7, 16he1e3, 16hff08,
    16h8082, 16hc515, 16h4781, 16h4629,
    16h4311, 16h48a5, 16h76b3, 16h02c5,
    16h882a, 16h5533, 16h02c5, 16h0733,
    16h40f3, 16h972e, 16h8693, 16h0306,
    16h0023, 16h00d7, 16h0785, 16hf793,
    16h0ff7, 16he1e3, 16hff08, 16h8082,
    16hc50d, 16h4781, 16h4829, 16h4625,
    16h76b3, 16h0305, 16h88aa, 16h5533,
    16h0305, 16h0733, 16h40f6, 16h972e,
    16h8693, 16h0306, 16h0023, 16h00d7,
    16h0785, 16hf793, 16h0ff7, 16h61e3,
    16hff16, 16h8082, 16h17b7, 16h0000,
    16ha703, 16h4287, 16h4783, 16h0007,
    16h8b89, 16hffed, 16h17b7, 16h0000,
    16ha783, 16h4247, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha703, 16h3f87,
    16h4783, 16h0007, 16hf793, 16h0ff7,
    16hffe5, 16h17b7, 16h0000, 16ha783,
    16h4007, 16h8023, 16h00a7, 16h47a9,
    16h0363, 16h00f5, 16h8082, 16h1141,
    16hc606, 16h4535, 16h0097, 16h0000,
    16h80e7, 16hfb80, 16h40b2, 16h0141,
    16h8082, 16h1141, 16hc606, 16hc422,
    16h842a, 16h4503, 16h0005, 16hc909,
    16h0097, 16h0000, 16h80e7, 16hf9c0,
    16h0405, 16h4503, 16h0004, 16hf96d,
    16h4529, 16h0097, 16h0000, 16h80e7,
    16hf8a0, 16h40b2, 16h4422, 16h0141,
    16h8082, 16h1141, 16hc606, 16hc422,
    16h842a, 16h4503, 16h0005, 16hc909,
    16h0097, 16h0000, 16h80e7, 16hf6c0,
    16h0405, 16h4503, 16h0004, 16hf96d,
    16h40b2, 16h4422, 16h0141, 16h8082,
    16h1101, 16hce06, 16h27b7, 16h0030,
    16h8793, 16h0207, 16hc63e, 16h006c,
    16h0097, 16h0000, 16h80e7, 16hebc0,
    16h0068, 16h0097, 16h0000, 16h80e7,
    16hfc00, 16h40f2, 16h6105, 16h8082,
    16h1101, 16hce06, 16h27b7, 16h2020,
    16h8793, 16h0207, 16hc43e, 16h0793,
    16h0300, 16h1623, 16h00f1, 16h002c,
    16h0097, 16h0000, 16h80e7, 16heba0,
    16h0028, 16h0097, 16h0000, 16h80e7,
    16hf900, 16h40f2, 16h6105, 16h8082,
    16h1101, 16hce06, 16h17b7, 16h0000,
    16h8793, 16h5287, 16h4394, 16h43d8,
    16hc236, 16hc43a, 16hd703, 16h0087,
    16h1623, 16h00e1, 16hc783, 16h00a7,
    16h0723, 16h00f1, 16h004c, 16h0097,
    16h0000, 16h80e7, 16heaa0, 16h0048,
    16h0097, 16h0000, 16h80e7, 16hf520,
    16h40f2, 16h6105, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h4287, 16hc503,
    16h0007, 16h8905, 16h8082, 16h1141,
    16hc606, 16h0097, 16h0000, 16h80e7,
    16hfec0, 16hdd65, 16h17b7, 16h0000,
    16ha783, 16h4247, 16hc503, 16h0007,
    16h40b2, 16h0141, 16h8082, 16h87aa,
    16h0713, 16h0200, 16h6d63, 16h00a7,
    16h6d63, 16h06a7, 16h1713, 16h0025,
    16h16b7, 16h0000, 16h8693, 16h42c6,
    16h9736, 16h4318, 16h8702, 16h0713,
    16h8005, 16hcf11, 16h6705, 16h0713,
    16h8007, 16h7763, 16h02a7, 16h6711,
    16h0763, 16h00e5, 16h7263, 16h06a7,
    16h6721, 16h1463, 16h04e5, 16h1737,
    16h0000, 16h2703, 16h2b47, 16h5503,
    16h0007, 16h1713, 16h0105, 16h8341,
    16h8513, 16hfff7, 16h8d79, 16h8082,
    16h0713, 16h1000, 16h01e3, 16hfee5,
    16h7a63, 16h00a7, 16h0713, 16he005,
    16h7713, 16hdff7, 16h0742, 16h8341,
    16heb09, 16hb7f1, 16h0713, 16hfc05,
    16h7713, 16hfbf7, 16h0742, 16h8341,
    16hdf5d, 16h1737, 16h0000, 16h2603,
    16h2b87, 16h1737, 16h0000, 16h2683,
    16h2b47, 16h0713, 16h0ff0, 16ha805,
    16h777d, 16h972a, 16h76fd, 16h16fd,
    16h8f75, 16h0742, 16h8341, 16hff71,
    16hbf59, 16h17b7, 16h0000, 16ha783,
    16h2b47, 16hd503, 16h0007, 16h8905,
    16h8082, 16hd503, 16h0006, 16h7513,
    16h0ff5, 16h6963, 16h00f5, 16h7ae3,
    16hfef7, 16h5503, 16h0006, 16h0542,
    16h8141, 16hbfc5, 16h8082, 16h8082,
    16h17b7, 16h0000, 16ha703, 16h2a87,
    16h1023, 16h00a7, 16ha703, 16h2a87,
    16h5783, 16h0007, 16h07c2, 16h83c1,
    16hffe5, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h2ac7, 16h9023, 16h00a7,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h2ac7, 16hd503, 16h0007, 16h0542,
    16h8141, 16h8082, 16h17b7, 16h0000,
    16ha703, 16h2ac7, 16h5783, 16h0007,
    16h07c2, 16h83c1, 16hffe5, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h2b07,
    16hd503, 16h0007, 16h0542, 16h8141,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h2b07, 16h4705, 16h9023, 16h00e7,
    16h8082, 16h7793, 16h0015, 16hcb95,
    16h17b7, 16h0000, 16ha783, 16h2d87,
    16h8023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16h2d47, 16h8023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16h2d07,
    16h9023, 16h00d7, 16h17b7, 16h0000,
    16ha783, 16h2cc7, 16h4705, 16h8023,
    16h00e7, 16h8909, 16hc915, 16h17b7,
    16h0000, 16ha783, 16h2c87, 16h8023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16h2c47, 16h8023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16h2c07, 16h9023,
    16h00d7, 16h17b7, 16h0000, 16ha783,
    16h2bc7, 16h4705, 16h8023, 16h00e7,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16h4187, 16h4783, 16h0007, 16hf793,
    16h0ff7, 16hdfe5, 16h8082, 16h1141,
    16hc606, 16hc422, 16hc226, 16h84aa,
    16h842e, 16h0097, 16h0000, 16h80e7,
    16hfe00, 16h17b7, 16h0000, 16ha783,
    16h40c7, 16hd713, 16h0104, 16h9023,
    16h00e7, 16h17b7, 16h0000, 16ha783,
    16h4107, 16h04c2, 16h80c1, 16h9023,
    16h0097, 16h17b7, 16h0000, 16ha783,
    16h4147, 16h4705, 16h8023, 16h00e7,
    16h0097, 16h0000, 16h80e7, 16hfaa0,
    16h4781, 16h1537, 16h0000, 16h15b7,
    16h0000, 16h0613, 16h2000, 16h9693,
    16h0107, 16h82c1, 16h2703, 16h4085,
    16h1023, 16h00d7, 16ha703, 16h4045,
    16h4683, 16h0007, 16h0733, 16h00f4,
    16h0023, 16h00d7, 16h0785, 16h90e3,
    16hfec7, 16h40b2, 16h4422, 16h4492,
    16h0141, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h41c7, 16h8023, 16h00a7,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h4207, 16hc503, 16h0007, 16h7513,
    16h0ff5, 16h8082, 16h17b7, 16h0000,
    16ha703, 16h2a47, 16h4783, 16h0007,
    16hf793, 16h0ff7, 16hdfe5, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h3f47,
    16h8023, 16h00a7, 16h17b7, 16h0000,
    16ha783, 16h3f07, 16h8023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16h3ec7,
    16h8023, 16h00c7, 16h8082, 16h17b7,
    16h0000, 16ha803, 16h3c07, 16h4783,
    16h0008, 16hf793, 16h0ff7, 16hffe5,
    16h17b7, 16h0000, 16ha783, 16h3e87,
    16h8023, 16h00a7, 16h17b7, 16h0000,
    16ha783, 16h3e47, 16h8023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16h3e07,
    16h8023, 16h00c7, 16h17b7, 16h0000,
    16ha783, 16h3dc7, 16h8023, 16h00d7,
    16h17b7, 16h0000, 16ha783, 16h3d87,
    16h8023, 16h00e7, 16h17b7, 16h0000,
    16ha783, 16h3d47, 16h4705, 16h8023,
    16h00e7, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3d07, 16h8023, 16h00a7,
    16h4781, 16h1837, 16h0000, 16h1537,
    16h0000, 16h4641, 16h2703, 16h3cc8,
    16hf693, 16h0ff7, 16h0023, 16h00d7,
    16h2703, 16h3c85, 16hd683, 16h0005,
    16h1023, 16h00d7, 16h0785, 16h0589,
    16h92e3, 16hfec7, 16h8082, 16h17b7,
    16h0000, 16ha703, 16h3c07, 16h4783,
    16h0007, 16hf793, 16h0ff7, 16hffe5,
    16h17b7, 16h0000, 16ha703, 16h3c47,
    16h0023, 16h00a7, 16ha783, 16h3c47,
    16hc503, 16h0007, 16h7513, 16h0ff5,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16h39c7, 16h4783, 16h0007, 16hf793,
    16h0ff7, 16hffe5, 16h8082, 16h1141,
    16hc606, 16hc422, 16hc226, 16hc04a,
    16h892a, 16h84ae, 16h8432, 16h0097,
    16h0000, 16h80e7, 16hfdc0, 16h17b7,
    16h0000, 16ha783, 16h3b47, 16h8023,
    16h0127, 16h17b7, 16h0000, 16ha783,
    16h3bc7, 16h9023, 16h0097, 16h17b7,
    16h0000, 16ha783, 16h3b87, 16h9023,
    16h0087, 16h17b7, 16h0000, 16ha783,
    16h3a07, 16h4705, 16h8023, 16h00e7,
    16h40b2, 16h4422, 16h4492, 16h4902,
    16h0141, 16h8082, 16h1141, 16hc606,
    16hc422, 16h842a, 16h0097, 16h0000,
    16h80e7, 16hf8e0, 16h17b7, 16h0000,
    16ha783, 16h3607, 16h8023, 16h0087,
    16h40b2, 16h4422, 16h0141, 16h8082,
    16h1141, 16hc606, 16h17b7, 16h0000,
    16ha783, 16h3b47, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16h3bc7,
    16h9023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16h3b87, 16h9023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16h3b07,
    16h9023, 16h00d7, 16h17b7, 16h0000,
    16ha783, 16h3ac7, 16h9023, 16h00e7,
    16h0097, 16h0000, 16h80e7, 16hf320,
    16h17b7, 16h0000, 16ha783, 16h3a07,
    16h4709, 16h8023, 16h00e7, 16h40b2,
    16h0141, 16h8082, 16h1141, 16hc606,
    16h4515, 16h0097, 16h0000, 16h80e7,
    16hf7a0, 16h0713, 16h1df0, 16h0693,
    16h27f0, 16h4601, 16h4581, 16h0513,
    16h0400, 16h0097, 16h0000, 16h80e7,
    16hf860, 16h40b2, 16h0141, 16h8082,
    16h1141, 16hc606, 16h17b7, 16h0000,
    16ha783, 16h3b47, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16h3bc7,
    16h9023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16h3b87, 16h9023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16h3b07,
    16h9023, 16h00d7, 16h17b7, 16h0000,
    16ha783, 16h3ac7, 16h9023, 16h00e7,
    16h0097, 16h0000, 16h80e7, 16heaa0,
    16h17b7, 16h0000, 16ha783, 16h3a07,
    16h470d, 16h8023, 16h00e7, 16h40b2,
    16h0141, 16h8082, 16h1141, 16hc606,
    16hc422, 16h843a, 16h17b7, 16h0000,
    16ha783, 16h3b47, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16h3bc7,
    16h9023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16h3b87, 16h9023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16h3b07,
    16h9023, 16h00d7, 16h0097, 16h0000,
    16h80e7, 16he560, 16h3733, 16h0080,
    16h0706, 16h0711, 16h17b7, 16h0000,
    16ha783, 16h3a07, 16h8023, 16h00e7,
    16h40b2, 16h4422, 16h0141, 16h8082,
    16h1141, 16hc606, 16hc422, 16h843a,
    16h17b7, 16h0000, 16ha783, 16h3b47,
    16h8023, 16h00a7, 16h17b7, 16h0000,
    16ha783, 16h3bc7, 16h9023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16h3b87,
    16h9023, 16h00c7, 16h17b7, 16h0000,
    16ha783, 16h3b07, 16h9023, 16h00d7,
    16h0097, 16h0000, 16h80e7, 16hdfa0,
    16h37b3, 16h0080, 16h07b3, 16h40f0,
    16h8b8d, 16h0795, 16h1737, 16h0000,
    16h2703, 16h3a07, 16h0023, 16h00f7,
    16h40b2, 16h4422, 16h0141, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h3987,
    16h8023, 16h00a7, 16h4781, 16h1837,
    16h0000, 16h1537, 16h0000, 16h4641,
    16h2703, 16h3948, 16hf693, 16h0ff7,
    16h0023, 16h00d7, 16h2703, 16h3905,
    16hd683, 16h0005, 16h1023, 16h00d7,
    16h0785, 16h0589, 16h92e3, 16hfec7,
    16h8082, 16h1141, 16hc606, 16h18b7,
    16h0000, 16ha883, 16h3b48, 16h8023,
    16h00a8, 16h1537, 16h0000, 16h2503,
    16h3bc5, 16h1023, 16h00b5, 16h15b7,
    16h0000, 16ha583, 16h3b85, 16h9023,
    16h00c5, 16h1637, 16h0000, 16h2603,
    16h3b06, 16h1023, 16h00d6, 16h16b7,
    16h0000, 16ha683, 16h3ac6, 16h9023,
    16h00e6, 16h1737, 16h0000, 16h2703,
    16h3a87, 16h1023, 16h00f7, 16h17b7,
    16h0000, 16ha783, 16h3a47, 16h9023,
    16h0107, 16h0097, 16h0000, 16h80e7,
    16hd400, 16h17b7, 16h0000, 16ha783,
    16h3a07, 16h471d, 16h8023, 16h00e7,
    16h40b2, 16h0141, 16h8082, 16h17b7,
    16h0000, 16ha703, 16h3787, 16h4783,
    16h0007, 16hf793, 16h0ff7, 16hffe5,
    16h8082, 16h1101, 16hce06, 16hcc22,
    16hca26, 16hc84a, 16hc64e, 16h89aa,
    16h892e, 16h84b2, 16h8436, 16h0097,
    16h0000, 16h80e7, 16hfd80, 16h17b7,
    16h0000, 16ha783, 16h38c7, 16h8023,
    16h0137, 16h17b7, 16h0000, 16ha783,
    16h3887, 16h8023, 16h0127, 16h17b7,
    16h0000, 16ha783, 16h3847, 16h9023,
    16h0097, 16h17b7, 16h0000, 16ha783,
    16h3807, 16h9023, 16h0087, 16h17b7,
    16h0000, 16ha783, 16h37c7, 16h4705,
    16h8023, 16h00e7, 16h40f2, 16h4462,
    16h44d2, 16h4942, 16h49b2, 16h6105,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3747, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha783, 16h3707, 16h8023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16h36c7, 16h8023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16h3687, 16h8023,
    16h00d7, 16h17b7, 16h0000, 16ha783,
    16h3647, 16h8023, 16h00e7, 16h8082,
    16hc10d, 16h4785, 16h0663, 16h02f5,
    16h4781, 16h1eb7, 16h0000, 16h1e37,
    16h0000, 16h4685, 16h1337, 16h0000,
    16h18b7, 16h0000, 16h0713, 16h0800,
    16ha83d, 16h17b7, 16h0000, 16ha783,
    16h3307, 16h8023, 16h00b7, 16hbfe9,
    16h17b7, 16h0000, 16ha783, 16h3007,
    16h8023, 16h00b7, 16hb7f1, 16ha583,
    16h32ce, 16hf813, 16h0ff7, 16h8023,
    16h0105, 16h2583, 16h328e, 16h5803,
    16h0006, 16h9023, 16h0105, 16h0785,
    16h0609, 16h8263, 16h02e7, 16hd165,
    16h1be3, 16hfed5, 16h2583, 16h2fc3,
    16hf813, 16h0ff7, 16h8023, 16h0105,
    16ha583, 16h2f88, 16h5803, 16h0006,
    16h9023, 16h0105, 16hbfe9, 16h8082,
    16hc509, 16h4305, 16h0e63, 16h0465,
    16h8082, 16h1537, 16h0000, 16h2503,
    16h3505, 16h0023, 16h00b5, 16h15b7,
    16h0000, 16ha583, 16h34c5, 16h8023,
    16h00c5, 16h1637, 16h0000, 16h2603,
    16h3486, 16h0023, 16h0106, 16h1637,
    16h0000, 16h2603, 16h3446, 16h0023,
    16h00d6, 16h16b7, 16h0000, 16ha683,
    16h3406, 16h9023, 16h00e6, 16h1737,
    16h0000, 16h2703, 16h33c7, 16h1023,
    16h00f7, 16h17b7, 16h0000, 16ha783,
    16h3387, 16h8023, 16h0117, 16h8082,
    16h1537, 16h0000, 16h2503, 16h3205,
    16h0023, 16h00b5, 16h15b7, 16h0000,
    16ha583, 16h31c5, 16h8023, 16h00c5,
    16h1637, 16h0000, 16h2603, 16h3186,
    16h0023, 16h0106, 16h1637, 16h0000,
    16h2603, 16h3146, 16h0023, 16h00d6,
    16h16b7, 16h0000, 16ha683, 16h3106,
    16h9023, 16h00e6, 16h1737, 16h0000,
    16h2703, 16h30c7, 16h1023, 16h00f7,
    16h17b7, 16h0000, 16ha783, 16h3087,
    16h8023, 16h0117, 16h8082, 16he541,
    16h17b7, 16h0000, 16ha783, 16h3507,
    16h8023, 16h00b7, 16h4795, 16hee63,
    16h0ec7, 16h060a, 16h17b7, 16h0000,
    16h8793, 16h4b07, 16h963e, 16h421c,
    16h8782, 16h17b7, 16h0000, 16ha783,
    16h34c7, 16hf693, 16h0ff6, 16h8023,
    16h00d7, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3487, 16hf693, 16h0ff6,
    16h8023, 16h00d7, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3447, 16hf693,
    16h0ff6, 16h8023, 16h00d7, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h3407,
    16h9023, 16h00d7, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h33c7, 16h9023,
    16h00d7, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3387, 16hf693, 16h0ff6,
    16h8023, 16h00d7, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3207, 16h8023,
    16h00b7, 16h4795, 16heb63, 16h06c7,
    16h060a, 16h17b7, 16h0000, 16h8793,
    16h4c87, 16h963e, 16h421c, 16h8782,
    16h17b7, 16h0000, 16ha783, 16h31c7,
    16hf693, 16h0ff6, 16h8023, 16h00d7,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3187, 16hf693, 16h0ff6, 16h8023,
    16h00d7, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3147, 16hf693, 16h0ff6,
    16h8023, 16h00d7, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3107, 16h9023,
    16h00d7, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h30c7, 16h9023, 16h00d7,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3087, 16hf693, 16h0ff6, 16h8023,
    16h00d7, 16h8082, 16he941, 16h17b7,
    16h0000, 16ha783, 16h3507, 16h8023,
    16h00b7, 16h4795, 16he763, 16h10c7,
    16h060a, 16h17b7, 16h0000, 16h8793,
    16h4e07, 16h963e, 16h421c, 16h8782,
    16h17b7, 16h0000, 16ha783, 16h34c7,
    16hc503, 16h0007, 16h7513, 16h0ff5,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3487, 16hc503, 16h0007, 16h7513,
    16h0ff5, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3447, 16hc503, 16h0007,
    16h7513, 16h0ff5, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3407, 16hd503,
    16h0007, 16h0542, 16h8541, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h33c7,
    16hd503, 16h0007, 16h0542, 16h8541,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3387, 16hc503, 16h0007, 16h7513,
    16h0ff5, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3207, 16h8023, 16h00b7,
    16h4795, 16he063, 16h08c7, 16h060a,
    16h17b7, 16h0000, 16h8793, 16h4f87,
    16h963e, 16h421c, 16h8782, 16h17b7,
    16h0000, 16ha783, 16h31c7, 16hc503,
    16h0007, 16h7513, 16h0ff5, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h3187,
    16hc503, 16h0007, 16h7513, 16h0ff5,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h3147, 16hc503, 16h0007, 16h7513,
    16h0ff5, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3107, 16hd503, 16h0007,
    16h0542, 16h8541, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h30c7, 16hd503,
    16h0007, 16h0542, 16h8541, 16h8082,
    16h17b7, 16h0000, 16ha783, 16h3087,
    16hc503, 16h0007, 16h7513, 16h0ff5,
    16h8082, 16h8082, 16hed01, 16h0586,
    16h17b7, 16h0000, 16ha783, 16h3247,
    16h95be, 16hd503, 16h0005, 16h0542,
    16h8141, 16h8082, 16h0586, 16h17b7,
    16h0000, 16ha783, 16h2f47, 16h95be,
    16hd503, 16h0005, 16h0542, 16h8141,
    16h8082, 16hc509, 16h4785, 16h0063,
    16h02f5, 16h8082, 16h17b7, 16h0000,
    16ha783, 16h3507, 16h8023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16h3347,
    16h9023, 16h00c7, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3207, 16h8023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16h3047, 16h9023, 16h00c7, 16h8082,
    16h17b7, 16h0000, 16ha703, 16h2dc7,
    16h4783, 16h0007, 16hf793, 16h0ff7,
    16hffe5, 16h478d, 16h0023, 16h00f7,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16h2f07, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha783, 16h2ec7, 16h8023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16h2e47, 16h8023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16h2e07, 16h8023,
    16h00d7, 16h17b7, 16h0000, 16ha783,
    16h2dc7, 16h4705, 16h8023, 16h00e7,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16h2dc7, 16h4783, 16h0007, 16hf793,
    16h0ff7, 16hffe5, 16h17b7, 16h0000,
    16ha783, 16h2e87, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16h2dc7,
    16h4709, 16h8023, 16h00e7, 16h8082,
    16h4683, 16h0005, 16hca8d, 16h1637,
    16h0000, 16h1837, 16h0000, 16h4589,
    16h2703, 16h2dc6, 16h4783, 16h0007,
    16hf793, 16h0ff7, 16hffe5, 16h2783,
    16h2e88, 16h8023, 16h00d7, 16h2783,
    16h2dc6, 16h8023, 16h00b7, 16h0505,
    16h4683, 16h0005, 16hfef1, 16h8082,
    16h1101, 16hce06, 16h27b7, 16h0030,
    16h8793, 16h0207, 16hc63e, 16h006c,
    16hf097, 16hffff, 16h80e7, 16h25c0,
    16h0068, 16h0097, 16h0000, 16h80e7,
    16hfae0, 16h40f2, 16h6105, 16h8082,
    16h1101, 16hce06, 16h27b7, 16h2020,
    16h8793, 16h0207, 16hc43e, 16h0793,
    16h0300, 16h1623, 16h00f1, 16h002c,
    16hf097, 16hffff, 16h80e7, 16h25a0,
    16h0028, 16h0097, 16h0000, 16h80e7,
    16hf7e0, 16h40f2, 16h6105, 16h8082,
    16h1101, 16hce06, 16h17b7, 16h0000,
    16h8793, 16h5287, 16h4394, 16h43d8,
    16hc236, 16hc43a, 16hd703, 16h0087,
    16h1623, 16h00e1, 16hc783, 16h00a7,
    16h0723, 16h00f1, 16h004c, 16hf097,
    16hffff, 16h80e7, 16h24a0, 16h0048,
    16h0097, 16h0000, 16h80e7, 16hf400,
    16h40f2, 16h6105, 16h8082, 16h17b7,
    16h0000, 16ha783, 16h3fc7, 16h8023,
    16h00a7, 16h8082, 16h8ff0, 16h0000,
    16h8930, 16h0000, 16h8920, 16h0000,
    16h8910, 16h0000, 16h8904, 16h0000,
    16h8900, 16h0000, 16h881c, 16h0000,
    16h8818, 16h0000, 16h8814, 16h0000,
    16h8810, 16h0000, 16h880c, 16h0000,
    16h8808, 16h0000, 16h8804, 16h0000,
    16h8800, 16h0000, 16h8614, 16h0000,
    16h8610, 16h0000, 16h860c, 16h0000,
    16h8608, 16h0000, 16h8604, 16h0000,
    16h8600, 16h0000, 16h8530, 16h0000,
    16h8528, 16h0000, 16h8524, 16h0000,
    16h8520, 16h0000, 16h851c, 16h0000,
    16h8518, 16h0000, 16h8514, 16h0000,
    16h8510, 16h0000, 16h850c, 16h0000,
    16h8508, 16h0000, 16h8504, 16h0000,
    16h8500, 16h0000, 16h8330, 16h0000,
    16h8328, 16h0000, 16h8324, 16h0000,
    16h8320, 16h0000, 16h831c, 16h0000,
    16h8318, 16h0000, 16h8314, 16h0000,
    16h8310, 16h0000, 16h830c, 16h0000,
    16h8308, 16h0000, 16h8304, 16h0000,
    16h8300, 16h0000, 16h8474, 16h0000,
    16h8470, 16h0000, 16h8470, 16h0000,
    16h8460, 16h0000, 16h8440, 16h0000,
    16h843c, 16h0000, 16h8444, 16h0000,
    16h8438, 16h0000, 16h8434, 16h0000,
    16h8448, 16h0000, 16h8430, 16h0000,
    16h842c, 16h0000, 16h8428, 16h0000,
    16h8424, 16h0000, 16h8420, 16h0000,
    16h8458, 16h0000, 16h8454, 16h0000,
    16h8450, 16h0000, 16h841c, 16h0000,
    16h841c, 16h0000, 16h8418, 16h0000,
    16h8414, 16h0000, 16h8410, 16h0000,
    16h840c, 16h0000, 16h8408, 16h0000,
    16h8404, 16h0000, 16h8400, 16h0000,
    16h8234, 16h0000, 16h8230, 16h0000,
    16h8228, 16h0000, 16h8224, 16h0000,
    16h8220, 16h0000, 16h8214, 16h0000,
    16h8210, 16h0000, 16h820c, 16h0000,
    16h8208, 16h0000, 16h8204, 16h0000,
    16h8200, 16h0000, 16h8108, 16h0000,
    16h8104, 16h0000, 16h8100, 16h0000,
    16h8700, 16h0000, 16h8704, 16h0000,
    16h8700, 16h0000, 16h8f10, 16h0000,
    16h8f10, 16h0000, 16h8f04, 16h0000,
    16h8f08, 16h0000, 16h8f00, 16h0000,
    16h8f00, 16h0000, 16h800c, 16h0000,
    16h8008, 16h0000, 16h8000, 16h0000,
    16h8004, 16h0000, 16h073e, 16h0000,
    16h0712, 16h0000, 16h0712, 16h0000,
    16h06ea, 16h0000, 16h06a6, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06a6, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06a6, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06ea, 16h0000,
    16h06ea, 16h0000, 16h06a6, 16h0000,
    16h0eca, 16h0000, 16h0edc, 16h0000,
    16h0eee, 16h0000, 16h0f00, 16h0000,
    16h0f0e, 16h0000, 16h0f1c, 16h0000,
    16h0f50, 16h0000, 16h0f62, 16h0000,
    16h0f74, 16h0000, 16h0f86, 16h0000,
    16h0f94, 16h0000, 16h0fa2, 16h0000,
    16h0fd8, 16h0000, 16h0fea, 16h0000,
    16h0ffc, 16h0000, 16h100e, 16h0000,
    16h1020, 16h0000, 16h1032, 16h0000,
    16h1066, 16h0000, 16h1078, 16h0000,
    16h108a, 16h0000, 16h109c, 16h0000,
    16h10ae, 16h0000, 16h10c0, 16h0000,
    16h7250, 16h7365, 16h2073, 16h4946,
    16h4552, 16h7420, 16h206f, 16h6572,
    16h7473, 16h7261, 16h2174, 16h0000,
    16h2020, 16h2020, 16h2020, 16h2020,
    16h3020, 16h0000

        , pad(uninitialized)
    };

    // FLAGS FOR BRAM ACCESS
    ram.wenable := 0;
    ram.addr := address[1,15];

    // RETURN RESULTS FROM BRAM OR CACHE
    readdata := ram.rdata;

    while(1) {
        if( writeflag ) {
            ram.wdata = writedata;
            ram.wenable = 1;
        }
    }
}

algorithm ramcontrollerSDRAM (
    input   uint32  address,
    input   uint16  writedata,
    output  uint16  readdata,
    input   uint1   writeflag,
    input   uint1   readflag,
    input   uint1   Icache,
    output  uint1   busy
) <autorun> {
    // INSTRUCTION & DATA CACHES for SDRAM
    // CACHE LINE IS LOWER 11 bits ( 0 - 2047 ) of address, dropping the BYTE address bit
    // CACHE TAG IS REMAINING 13 bits of the 25 bit address + 1 bit for valid flag
    bram uint16 Dcachedata<input!>[2048] = uninitialized;
    bram uint14 Dcachetag<input!>[2048] = uninitialized;
    bram uint16 Icachedata<input!>[2048] = uninitialized;
    bram uint14 Icachetag<input!>[2048] = uninitialized;

    // FLAGS FOR CACHE ACCESS
    Dcachedata.wenable := 0; Dcachedata.addr := address[1,11];
    Dcachetag.wenable := 0; Dcachetag.addr := address[1,11]; Dcachetag.wdata := { 1b1, address[12,13] };
    Icachedata.wenable := 0; Icachedata.addr := address[1,11];
    Icachetag.wenable := 0; Icachetag.addr := address[1,11]; Icachetag.wdata := { 1b1, address[12,13] };

    // RETURN RESULTS FROM CACHES
    // NON-SIGN EXTENDED 16 bit read - for instructions and 32 bit reads
    readdata := Icache ? Icachedata.rdata : Dcachedata.rdata;

    while(1) {
        if( readflag ) {
            if( ( Icache && ( Icachetag.rdata == { 1b1, address[12,13] } ) ) || ( Dcachetag.rdata == { 1b1, address[12,13] } ) ) {
                // CACHE HIT
                busy = 0;
            } else {
                // CACHE MISS
                busy = 1;
                // READ FROM SDRAM
                // WRITE RESULT TO ICACHE or DCACHE
                if( Icache ) {
                    // ICACHE WRITE
                    Icachetag.wenable = 1;
                } else {
                    // DCACHE WRITE
                    Dcachetag.wenable = 1;
                }
                busy = 0;
            }
        }

        if( writeflag ) {
            busy = 1;
            // WRITE INTO CACHE
            Dcachedata.wdata = writedata;
            Dcachedata.wenable = 1; Dcachetag.wenable = 1;

            // CHECK IF ENTRY IS IN ICACHE AND UPDATE
            if( Icachetag.rdata == { 1b1, address[12,13] } ) {
                Icachedata.wdata = Dcachedata.wdata;
                Icachedata.wenable = 1;
            }

            // WRITE TO SDRAM
            busy = 0;
        }
    }
}


