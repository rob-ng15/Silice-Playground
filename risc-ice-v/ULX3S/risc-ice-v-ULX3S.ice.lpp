// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface bram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface bram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

interface bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----


// VGA/HDMI + UART Driver Includes
// SL 2020-09-05
// Silice HDMI driver
//
// 640x480, 250MHz TMDS from 25MHz pixel clock
//
// Currently limited to the ULX3S, but should be relatively easy to port,
// pending pll and differential serial output primitives
//
// See also
// - https://www.digikey.com/eewiki/pages/viewpage.action?pageId=36569119
// - https://www.fpga4fun.com/HDMI.html
// - https://github.com/lawrie/ulx3s_examples/blob/master/hdmi/tmds_encoder.v
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

import('hdmi_clock.v')
import('differential_pair.v')
import('hdmi_differential_pairs.v')

// ----------------------------------------------------

algorithm tmds_encoder(
  input   uint8  data,
  input   uint2  ctrl,
  input   uint1  data_or_ctrl,
  output  uint10 tmds
) <autorun> {

  uint9 q_m             = 0;
  int5  dc_bias         = 0;

  // tracks 'number on ones' in input
  uint4 num_ones        := data[0,1] + data[1,1] + data[2,1] + data[3,1]
                         + data[4,1] + data[5,1] + data[6,1] + data[7,1];
  // tracks 'numbers of ones minus number of zeros' in internal byte
  int5  diff_ones_zeros := q_m[0,1] + q_m[1,1] + q_m[2,1] + q_m[3,1] 
                         + q_m[4,1] + q_m[5,1] + q_m[6,1] + q_m[7,1] - 6d4;

  // XOR chain on input
  int1  xored1          := data[1,1] ^ data[0,1];
  int1  xored2          := data[2,1] ^ xored1;
  int1  xored3          := data[3,1] ^ xored2;
  int1  xored4          := data[4,1] ^ xored3;
  int1  xored5          := data[5,1] ^ xored4;
  int1  xored6          := data[6,1] ^ xored5;
  int1  xored7          := data[7,1] ^ xored6;

  // XNOR chain on input
  int1  xnored1         := ~(data[1,1] ^ data[0,1]);
  int1  xnored2         := ~(data[2,1] ^ xnored1);
  int1  xnored3         := ~(data[3,1] ^ xnored2);
  int1  xnored4         := ~(data[4,1] ^ xnored3);
  int1  xnored5         := ~(data[5,1] ^ xnored4);
  int1  xnored6         := ~(data[6,1] ^ xnored5);
  int1  xnored7         := ~(data[7,1] ^ xnored6);
  
  always {
    // choice of encoding scheme (xor / xnor)
    if ((num_ones > 4) || (num_ones == 4 && data[0,1] == 0)) {
      q_m = { 1b0 , {xnored7,xnored6,xnored5,xnored4,xnored3,xnored2,xnored1} , data[0,1] };  
    } else {
      q_m = { 1b1 , {xored7,xored6,xored5,xored4,xored3,xored2,xored1} , data[0,1] };    
    }
    if (data_or_ctrl) {
      // output data
      if (dc_bias == 0 || diff_ones_zeros == 0) {
        tmds      = {~q_m[8,1] , q_m[8,1], (q_m[8,1] ? q_m[0,8] : ~q_m[0,8])};
        if (q_m[8,1] == 0) {
          dc_bias = dc_bias - diff_ones_zeros;
        } else {
          dc_bias = dc_bias + diff_ones_zeros;
        }
      } else {
        if (  (dc_bias > 0 && diff_ones_zeros > 0)
           || (dc_bias < 0 && diff_ones_zeros < 0) ) {
          tmds    = {1b1, q_m[8,1], ~q_m[0,8] };
          dc_bias = dc_bias + q_m[8,1] - diff_ones_zeros;
        } else {
          tmds    = {1b0,q_m};
          dc_bias = dc_bias - (~q_m[8,1]) + diff_ones_zeros;
        }
      }
    } else {
      // output control
      switch (ctrl) {
        case 2b00: { tmds = 10b1101010100; }
        case 2b01: { tmds = 10b0010101011; }
        case 2b10: { tmds = 10b0101010100; }
        case 2b11: { tmds = 10b1010101011; }
      }
      dc_bias = 0;
    }
  }

}

// ----------------------------------------------------

algorithm hdmi_ddr_shifter(
  input   uint10 data_r,
  input   uint10 data_g,
  input   uint10 data_b,
  output  uint8  outbits,
) <autorun> {
  uint3  mod5    = 0;
  uint10 shift_r = 0;
  uint10 shift_g = 0;
  uint10 shift_b = 0;
  uint2  clkbits = 0;
  always {
    shift_r = (mod5 == 0) ?  data_r : shift_r[2,8];
    shift_g = (mod5 == 0) ?  data_g : shift_g[2,8];
    shift_b = (mod5 == 0) ?  data_b : shift_b[2,8];
    clkbits = (mod5[0,2] < 2) ? 2b11 : ( (mod5 > 2) ? 2b00 : 2b01 );
    outbits = { clkbits , shift_b[0,2] , shift_g[0,2] , shift_r[0,2] };
    mod5    = (mod5 == 4) ? 0 : (mod5 + 1);
  }
}

// ----------------------------------------------------

// Expects to run at 25 MHz (hdmi pixel clock)
algorithm hdmi(
  output  uint10 x,
  output  uint10 y,
  output  uint1  active,
  output  uint1  vblank,
  output! uint4  gpdi_dp,
  output! uint4  gpdi_dn,
  input   uint8  red,
  input   uint8  green,
  input   uint8  blue,
) <autorun> {
    
  uint10 cntx  = 0;
  uint10 cnty  = 0;
  
  uint1  hsync = 0;
  uint1  vsync = 0;
  
  // pll for tmds
  uint1  half_hdmi_clk = uninitialized;
  hdmi_clock pll(
    clk      <: clock,              //  25 MHz
    half_hdmi_clk :> half_hdmi_clk, // 125 MHz (half 250MHz HDMI, double data rate output)
  );
  
  uint2  null_ctrl  = 0;
  uint2  sync_ctrl  = 0;
  uint10 tmds_red   = 0;
  uint10 tmds_green = 0;
  uint10 tmds_blue  = 0;

  uint8  latch_red   = 0;
  uint8  latch_green = 0;
  uint8  latch_blue  = 0;
  uint2  prev_sync_ctrl = 0;
  uint1  prev_active    = 0;

  // encoders
  // => we use <:: to bind values from cycle start (ignoring changes during current cycle)
  tmds_encoder tmdsR(
    data        <:: latch_red,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_red
  );
  tmds_encoder tmdsG(
    data        <:: latch_green,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_green
  );
  tmds_encoder tmdsB(
    data        <:: latch_blue,
    ctrl        <:: prev_sync_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_blue
  );

  // shifter
  uint8 crgb_pos = 0;
  hdmi_ddr_shifter shift<@half_hdmi_clk>(
    data_r  <: tmds_red,
    data_g  <: tmds_green,
    data_b  <: tmds_blue,
    outbits :> crgb_pos,
  );

  uint8 crgb_neg := ~ crgb_pos;
  
  hdmi_differential_pairs hdmi_out( 
    clock   <: half_hdmi_clk,
    pos     <: crgb_pos, 
    neg     <: crgb_neg, 
    out_pos :> gpdi_dp, 
    out_neg :> gpdi_dn );

  always {

    // record previous state of sync_ctrl and active,
    // we receive the r,b,g value for the x,y set below with a one cycle latency
    // these are then latched for the following cycle
    // thus we have to delay corresponding sync and active two cycles
    prev_sync_ctrl = sync_ctrl;
    prev_active    = active;

    // synchronization bits
    hsync          = (cntx > 655) && (cntx < 752);
    vsync          = (cnty > 489) && (cnty < 492);
    sync_ctrl      = {vsync,hsync};    
    // output active area
    active         = (cntx < 640) && (cnty < 480);    
    // output vblank
    vblank         = (cnty >= 480);
    // output x,y
    x              = cntx;
    y              = cnty; 
    // => we will get color result on next cycle   

    // update coordinates
    cnty        = (cntx == 799) ? (cnty == 524 ? 0 : (cnty + 1)) : cnty;
    cntx        = (cntx == 799) ? 0 : (cntx + 1);
    
    // latch r,b,g received at this cycle, for previous coord
    // will be fed into HDMI encoders next cycle
    latch_red   = red;
    latch_green = green;
    latch_blue  = blue;

  }
}

// ----------------------------------------------------

// @sylefeb, 2020-10-08, simple UART in Silice
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

// UART config



// sender

// -> interface

group uart_out
{
  uint8 data_in = 0,
  uint1 data_in_ready = 0,
  uint1 busy = 0,
}

interface io_uart_out
{
  input  data_in,
  input  data_in_ready,
  output busy,
}

// -> algorithm

algorithm uart_sender(
  io_uart_out  io,
  output uint1 uart_tx
) <autorun> {
  
  uint10 interval      = 217;
  uint10 counter       = 0;

  uint11 transmit      = 0;

  always {    

    if (transmit > 1) {
      // keep transmitting
      if (counter == 0) {
        // keep going
        uart_tx  = transmit[0,1];
        transmit = {1b0,transmit[1,10]}; // goes to zero when done
      }
      counter = (counter == interval) ? 0 : (counter + 1);
    } else {
      // done
      uart_tx = 1;
      io.busy = 0;
      if (io.data_in_ready) {
        // start transmitting
        io.busy  = 1;
        transmit = {1b1,1b0,io.data_in,1b0};
      }
    }
  }

  uart_tx = 1;

}

// receiver

// -> interface

group uart_in
{
  uint8 data_out = 0,
  uint1 data_out_ready = 0,
}

interface io_uart_in
{
  output data_out,
  output data_out_ready,
}

// -> algorithm

algorithm uart_receiver(
  io_uart_in  io,
  input uint1 uart_rx
) <autorun> {
  
  uint10 interval      = 217;
  uint10 half_interval = 109;
  uint10 counter       = 0;

  uint4  receiving     = 0;
  uint10 received      = 0;

  uint1  latched_rx    = 0;

  always {     

    io.data_out_ready = 0; // maintain low

    if (receiving == 0) {
      if (latched_rx == 0) {
        // start receiving
        receiving = 10; // expecting 10 bits: start - data x8 - stop
        received  =  0;
        counter   = half_interval; // wait half-period
      }
    } else {
      if (counter == 0) { // right in the middle
        received  = {latched_rx,received[1,9]}; // read uart rx
        receiving = receiving - 1;
        counter   = interval;
        if (receiving == 0) {
          // done
          io.data_out       = received[1,8];
          io.data_out_ready = 1;
        }
      } else {
        counter   = counter - 1;
      }
    }

    latched_rx = uart_rx;

  }

}


// Multiplexed Display Includes
algorithm multiplex_display(
    input   uint10 pix_x,
    input   uint10 pix_y,
    input   uint1  pix_active,
    input   uint1  pix_vblank,
    output! uint8 pix_red,
    output! uint8 pix_green,
    output! uint8 pix_blue,

    // BACKGROUND
    input uint2 background_r,
    input uint2 background_g,
    input uint2 background_b,

    // TILEMAP
    input uint2 tilemap_r,
    input uint2 tilemap_g,
    input uint2 tilemap_b,
    input uint1 tilemap_display,

    // LOWER SPRITES
    input uint2 lower_sprites_r,
    input uint2 lower_sprites_g,
    input uint2 lower_sprites_b,
    input uint1 lower_sprites_display,

    // BITMAP
    input uint2 bitmap_r,
    input uint2 bitmap_g,
    input uint2 bitmap_b,
    input uint1 bitmap_display,

    // UPPER SPRITES
    input uint2 upper_sprites_r,
    input uint2 upper_sprites_g,
    input uint2 upper_sprites_b,
    input uint1 upper_sprites_display,

    // CHARACTER MAP
    input uint2 character_map_r,
    input uint2 character_map_g,
    input uint2 character_map_b,
    input uint1 character_map_display,

    // TERMINAL
    input uint2 terminal_r,
    input uint2 terminal_g,
    input uint2 terminal_b,
    input uint1 terminal_display
) <autorun> {
    // Output defaults to 0
    pix_red   := 0;
    pix_green := 0;
    pix_blue  := 0;

    // Draw the screen
    while (1) {
        // wait until pix_active THEN BACKGROUND -> TILEMAP -> LOWER SPRITES -> BITMAP -> UPPER SPRITES -> CHARACTER MAP -> TERMINAL
        if( pix_active ) {
            // Select the 2 bit r g or b and expand to 6 bit r g or b
            pix_red = ( terminal_display ) ? { {4{terminal_r}} } :
                        ( character_map_display ) ? { {4{character_map_r}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_r}} } :
                        ( bitmap_display ) ? { {4{bitmap_r}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_r}} } :
                        ( tilemap_display ) ? { {4{tilemap_r}} } :
                        { {4{background_r}} };
            pix_green = ( terminal_display ) ? { {4{terminal_g}} } :
                        ( character_map_display ) ? { {4{character_map_g}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_g}} } :
                        ( bitmap_display ) ? { {4{bitmap_g}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_g}} } :
                        ( tilemap_display ) ? { {4{tilemap_g}} } :
                        { {4{background_g}} };
            pix_blue = ( terminal_display ) ? { {4{terminal_b}} } :
                        ( character_map_display ) ? { {4{character_map_b}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_b}} } :
                        ( bitmap_display ) ? { {4{bitmap_b}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_b}} } :
                        ( tilemap_display ) ? { {4{tilemap_b}} } :
                        { {4{background_b}} };
        } // pix_active
    }
}

// Create 1hz (1 second counter, also can output the baseline 50MHz counter)
algorithm pulse1hz(
    output  uint16  counter1hz,
    input   uint1   resetCounter
) <autorun> {
    uint26  counter50mhz = 0;
    counter1hz = 0;

    while (1) {
        if( resetCounter == 1) {
            counter1hz = 0;
            counter50mhz = 0;
        } else {
            counter1hz = ( counter50mhz == 50000000 ) ? counter1hz + 1 : counter1hz;
            counter50mhz = ( counter50mhz == 50000000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// Create 1khz (1 milli-second counter)
algorithm pulse1khz(
    output  uint16  counter1khz,
    input   uint16  resetCount,
    input   uint1   resetCounter
) <autorun> {
    uint16 counter50mhz = 0;

    while (1) {
        if( resetCounter == 1 ) {
            counter1khz = resetCount;
            counter50mhz = 0;
        } else {
            counter1khz = ( counter1khz == 0 ) ? 0 : ( counter50mhz == 50000 ) ? counter1khz - 1 : counter1khz;
            counter50mhz = ( counter50mhz == 50000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// 16 bit random number generator
// Translation into Silice of LFSR_Plus.v
algorithm random(
    output  uint16  g_noise_out,
    input   uint1   resetRandom
) <autorun> {
    uint16  rand_out = 0;
    uint16  rand_ff = 24b011000110111011010011101;
    uint18  rand_en_ff = 24b001100010011011101100101;
    uint16  temp_u_noise3 = 0;
    uint16  temp_u_noise2 = 0;
    uint16  temp_u_noise1 = 0;
    uint16  temp_u_noise0 = 0;
    uint16  temp_g_noise_nxt = uninitialized;

    always {
        rand_en_ff = {(rand_en_ff[7,1] ^ rand_en_ff[0,1]) , rand_en_ff[1,17]};
        rand_ff = { ( rand_ff[5,1] ^ rand_ff[3,1] ^ rand_ff[2,1] ^ rand_ff[0,1]) , rand_ff[1,15] };
        g_noise_out = ( rand_en_ff[17,1] ) ? temp_g_noise_nxt : ( rand_en_ff[10,1] ) ? rand_out : g_noise_out;
    }

    while(1) {
        if( resetRandom ) {
            rand_en_ff = 24b001100010011011101100101;
            rand_ff = 24b011000110111011010011101;
            rand_out = 0;
            temp_u_noise3 = 0;
            temp_u_noise2 = 0;
            temp_u_noise1 = 0;
            temp_u_noise0 = 0;
            g_noise_out = 0;
        } else {
            rand_out = rand_ff;
            temp_u_noise3 = { rand_out[15,1], rand_out[15,1], rand_out[2,13] };
            temp_u_noise2 = temp_u_noise3;
            temp_u_noise1 = temp_u_noise2;
            temp_u_noise0 = temp_u_noise1;
            temp_g_noise_nxt = ( rand_en_ff[9,1] ) ? temp_u_noise3 + temp_u_noise2 + temp_u_noise1 + temp_u_noise0 + g_noise_out : temp_u_noise3 + temp_u_noise2 + temp_u_noise1 + temp_u_noise0;
        }
    }
}

algorithm terminal(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   terminal_display,

    input   uint8   terminal_character,
    input   uint1   terminal_write,
    input   uint1   showterminal,
    input   uint1   showcursor,
    input   uint1   timer1hz,
    output  uint1   terminal_active
) <autorun> {
    // Character ROM 8x8 x 256
    brom uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // 80 x 4 character buffer for the input/output terminal
    dualport_bram uint8 terminal[640] = uninitialized;

    // Initial cursor position in the terminal, bottom left
    uint7 terminal_x = 0;
    uint3 terminal_y = 7;

    // Character position on the terminal x 0-79, y 0-7 * 80 ( fetch it one pixel ahead of the actual x pixel, so it is always ready )
    uint7 xterminalpos := ( pix_active ? pix_x + 2 : 0 ) >> 3;
    uint10 yterminalpos := (( pix_vblank ? 0 : pix_y - 416 ) >> 3) * 80;

    // Determine if cursor, and if cursor is flashing
    uint1 is_cursor := ( xterminalpos == terminal_x ) && ( ( ( pix_y - 416) >> 3 ) == terminal_y );

    // Derive the x and y coordinate within the current 8x8 terminal character block x 0-7, y 0-7
    uint3 xinterminal := (pix_x) & 7;
    uint3 yinterminal := (pix_y) & 7;

    // Derive the actual pixel in the current terminal
    uint1 terminalpixel := characterGenerator8x8.rdata[7 - xinterminal,1];

    // Terminal active (scroll) flag and temporary storage for scrolling
    uint10 terminal_scroll = 0;
    uint10 terminal_scroll_character = 0;

    // Setup the reading of the terminal memory
    terminal.addr0 := xterminalpos + yterminalpos;
    terminal.wenable0 := 0;

    // Setup the writing to the terminal memory
    terminal.wenable1 := 0;

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr :=  terminal.rdata0 * 8 + yinterminal;

    // Default to transparent and active pixels always blue
    terminal_display := pix_active && showterminal && (pix_y > 415);
    pix_blue := 3;

    always {
        if( terminal_display ) {
            // TERMINAL is in range and showterminal flag
            // Invert colours for cursor if flashing
            switch( terminalpixel ) {
                case 0: {
                    pix_red = ( is_cursor && timer1hz ) ? 3 : 0;
                    pix_green = ( is_cursor && timer1hz ) ? 3: 0;
                }
                case 1: {
                    pix_red = ( is_cursor && timer1hz ) ? 0 : 3;
                    pix_green = ( is_cursor && timer1hz ) ? 0 : 3;
                }
            }
        }
    }

    // Render the terminal
    while(1) {
        if( terminal_write ) {
            // Display character
            switch( terminal_character ) {
                case 8: {
                    // BACKSPACE, move back one character
                    if( terminal_x != 0 ) {
                        terminal_x = terminal_x - 1;
                        terminal.addr1 = terminal_x + terminal_y * 80;
                        terminal.wdata1 = 0;
                        terminal.wenable1 = 1;
                    }
                }
                case 10: {
                    // LINE FEED, scroll
                    terminal_active = 1;
                }
                case 13: {
                    // CARRIAGE RETURN
                    terminal_x = 0;
                }
                default: {
                    // Display character
                    terminal.addr1 = terminal_x + terminal_y * 80;
                    terminal.wdata1 = terminal_character;
                    terminal.wenable1 = 1;
                    terminal_active = ( terminal_x == 79 ) ? 1 : 0;
                    terminal_x = ( terminal_x == 79 ) ? 0 : terminal_x + 1;
                }
            }
        } else {
            if( terminal_active ) {
                // SCROLL
                terminal_scroll = 0;
                ++:
                while( terminal_scroll < 560 ) {
                    // Retrieve character on the next line
                    terminal.addr1 = terminal_scroll + 80;
                    ++:
                    terminal_scroll_character = terminal.rdata1;
                    ++:
                    // Write retrieved character
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = terminal_scroll_character;
                    terminal.wenable1 = 1;

                    //++:
                    terminal_scroll = terminal_scroll + 1;
                }

                // BLANK LAST LINE
                while( terminal_scroll < 640 ) {
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = 0;
                    terminal.wenable1 = 1;

                    terminal_scroll = terminal_scroll + 1;
                }

                terminal_active = 0;
            }
        }
    }
}

bitfield charactermapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint8   character
}

algorithm character_map(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   character_map_display,

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint5   tpu_y,
    input   uint8   tpu_character,
    input   uint6   tpu_foreground,
    input   uint7   tpu_background,
    input   uint3   tpu_write,

    output  uint2   tpu_active
) <autorun> {
    // Character ROM 8x16
    brom uint8 characterGenerator8x16[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h81, 8ha5, 8h81, 8h81, 8hbd, 8h99, 8h81, 8h81, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8hff, 8hdb, 8hff, 8hff, 8hc3, 8he7, 8hff, 8hff, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h6c, 8hfe, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8he7, 8he7, 8he7, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h7e, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h1e, 8h0e, 8h1a, 8h32, 8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h33, 8h3f, 8h30, 8h30, 8h30, 8h30, 8h70, 8hf0, 8he0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8h63, 8h7f, 8h63, 8h63, 8h63, 8h63, 8h67, 8he7, 8he6, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8hdb, 8h3c, 8he7, 8h3c, 8hdb, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h80, 8hc0, 8he0, 8hf0, 8hf8, 8hfe, 8hf8, 8hf0, 8he0, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h02, 8h06, 8h0e, 8h1e, 8h3e, 8hfe, 8h3e, 8h1e, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8hdb, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h1b, 8h1b, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h7c, 8hc6, 8h60, 8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h28, 8h6c, 8hfe, 8h6c, 8h28, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h38, 8h7c, 8h7c, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8h7c, 8h7c, 8h38, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h24, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h7c, 8hc6, 8hc2, 8hc0, 8h7c, 8h06, 8h06, 8h86, 8hc6, 8h7c, 8h18, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hc2, 8hc6, 8h0c, 8h18, 8h30, 8h60, 8hc6, 8h86, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h30, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h18, 8h0c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h18, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h02, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hd6, 8hd6, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h38, 8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h06, 8h3c, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h0c, 8h0c, 8h1e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hfc, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h60, 8hc0, 8hc0, 8hfc, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h06, 8h06, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h06, 8h06, 8h0c, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h0c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hde, 8hde, 8hde, 8hdc, 8hc0, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h66, 8h66, 8h66, 8h66, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf8, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hde, 8hc6, 8hc6, 8h66, 8h3a, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he6, 8h66, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf0, 8h60, 8h60, 8h60, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hde, 8h7c, 8h0c, 8h0e, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h60, 8h38, 8h0c, 8h06, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h7e, 8h5a, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8hee, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8h6c, 8h7c, 8h38, 8h38, 8h7c, 8h6c, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h86, 8h0c, 8h18, 8h30, 8h60, 8hc2, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h80, 8hc0, 8he0, 8h70, 8h38, 8h1c, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h78, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc0, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h0c, 8h0c, 8h3c, 8h6c, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h6c, 8h76, 8h66, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h06, 8h06, 8h00, 8h0e, 8h06, 8h06, 8h06, 8h06, 8h06, 8h06, 8h66, 8h66, 8h3c, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hec, 8hfe, 8hd6, 8hd6, 8hd6, 8hd6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8h0c, 8h1e, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8h60, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h30, 8h30, 8h36, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8h6c, 8h38, 8h38, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8hf8, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hcc, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h18, 8h18, 8h18, 8h70, 8h18, 8h18, 8h18, 8h18, 8h0e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h70, 8h18, 8h18, 8h18, 8h0e, 8h18, 8h18, 8h18, 8h18, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h0c, 8h06, 8h7c, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h38, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h60, 8h60, 8h66, 8h3c, 8h0c, 8h06, 8h3c, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h66, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h38, 8h6c, 8h38, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h00, 8hfe, 8h66, 8h60, 8h7c, 8h60, 8h60, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8h76, 8h36, 8h7e, 8hd8, 8hd8, 8h6e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3e, 8h6c, 8hcc, 8hcc, 8hfe, 8hcc, 8hcc, 8hcc, 8hcc, 8hce, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8h78, 8h00,
    8h00, 8hc6, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h18, 8h3c, 8h66, 8h60, 8h60, 8h60, 8h66, 8h3c, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8he6, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hf8, 8hcc, 8hcc, 8hf8, 8hc4, 8hcc, 8hde, 8hcc, 8hcc, 8hcc, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0e, 8h1b, 8h18, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8h70, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h76, 8hdc, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h30, 8h00, 8h30, 8h30, 8h60, 8hc0, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8h06, 8h06, 8h06, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h60, 8hdc, 8h86, 8h0c, 8h18, 8h3e, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hce, 8h9e, 8h3e, 8h06, 8h06, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h36, 8h6c, 8hd8, 8h6c, 8h36, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hd8, 8h6c, 8h36, 8h6c, 8hd8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8hd8, 8hd8, 8hd8, 8hdc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8hd8, 8hcc, 8hc6, 8hc6, 8hc6, 8hcc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8hc6, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfe, 8hc6, 8h60, 8h30, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7e, 8h18, 8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h6c, 8h6c, 8h6c, 8hee, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h30, 8h18, 8h0c, 8h3e, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hdb, 8hdb, 8hdb, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h03, 8h06, 8h7e, 8hdb, 8hdb, 8hf3, 8h7e, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h30, 8h60, 8h60, 8h7c, 8h60, 8h60, 8h60, 8h30, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h7e, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0f, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h6c, 8h3c, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hd8, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h70, 8hd8, 8h30, 8h60, 8hc8, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00


    };

    // 80 x 30 character buffer
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    dualport_bram uint21 charactermap[2400] = { 21b100000000000000000000, pad(21b100000000000000000000) };

    // Character position on the screen x 0-79, y 0-29 * 80 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    uint8 xcharacterpos := ( pix_active ?  pix_x + 2 : 0 ) >> 3;
    uint12 ycharacterpos := (( pix_vblank ? 0 : pix_y ) >> 4) * 80;

    // Derive the x and y coordinate within the current 8x16 character block x 0-7, y 0-15
    uint3 xincharacter := (pix_x) & 7;
    uint4 yincharacter := (pix_y) & 15;

    // Derive the actual pixel in the current character
    uint1 characterpixel := characterGenerator8x16.rdata[7 - xincharacter,1];

    // TPU character position
    uint7 tpu_active_x = 0;
    uint5 tpu_active_y = 0;

    // CS Counter
    uint12  tpu_cs_addr = uninitialized;

    // Set up reading of the charactermap
    charactermap.addr0 := xcharacterpos + ycharacterpos;
    charactermap.wenable0 := 0;

    // BRAM write access for the TPU
    charactermap.wenable1 := 1;

    // Setup the reading of the characterGenerator8x16 ROM
    characterGenerator8x16.addr :=  charactermapentry(charactermap.rdata0).character * 16 + yincharacter;

    // Default to transparent
    character_map_display := pix_active && (( characterpixel ) || ( ~charactermapentry(charactermap.rdata0).alpha ));

    // Default to 0,0 and transparent
    charactermap.addr1 = 0; charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };

    // Render the character map
    while(1) {
        if( character_map_display ) {
            // CHARACTER from characterGenerator8x16
            // Determine if background or foreground
            pix_red = characterpixel ? charactermap.rdata0[12,2] : charactermap.rdata0[18,2];
            pix_green = characterpixel ? charactermap.rdata0[10,2] : charactermap.rdata0[16,2];
            pix_blue = characterpixel ? charactermap.rdata0[8,2] : charactermap.rdata0[14,2];
        }

        switch( tpu_active ) {
            case 0: {
                switch( tpu_write ) {
                    case 1: {
                        // Set cursor position
                        tpu_active_x = tpu_x;
                        tpu_active_y = tpu_y;
                    }
                    case 2: {
                        // Write character,foreground, background to current cursor position and move onto next character position
                        charactermap.addr1 = tpu_active_x + tpu_active_y * 80;
                        charactermap.wdata1 = { tpu_background, tpu_foreground, tpu_character };

                        tpu_active_y = ( tpu_active_x == 79 ) ? ( tpu_active_y == 29 ) ? 0 : tpu_active_y + 1 : tpu_active_y;
                        tpu_active_x = ( tpu_active_x == 79 ) ? 0 : tpu_active_x + 1;
                    }
                    case 3: {
                        // Start tpucs!
                        tpu_active_x = 0;
                        tpu_active_y = 0;
                        tpu_active = 1;
                        tpu_cs_addr = 0;
                        charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };
                    }
                }
            }

            // TPU CS
            case 1: {
                charactermap.addr1 = tpu_cs_addr;
                tpu_cs_addr = tpu_cs_addr + 1;
                tpu_active = 2;
            }

            case 2: {
                tpu_active = ( tpu_cs_addr < 2400 ) ? 1 : 0;
            }
        }
    }
}

algorithm bitmap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   bitmap_display,

    // GPU to SET and GET pixels
    input   int11   bitmap_x_write,
    input   int11   bitmap_y_write,
    input   uint7   bitmap_colour_write,
    input   uint1   bitmap_write,

    // Hardware scrolling
    input   uint3   bitmap_write_offset,

    // Pixel reader
    input   int16   bitmap_x_read,
    input   int16   bitmap_y_read,
    output  uint7   bitmap_colour_read
) <autorun> {
    // 640 x 480 x 7 bit { Arrggbb } colour bitmap
    dualport_bram uint7 bitmap[ 307200 ] = uninitialized;

    // Offset from ( 0, 0 ) to start drawing
    uint10  x_offset = 0;
    uint10  y_offset = 0;

    // Pixel x and y fetching ( adjusting for offset )
    uint10  x_plus_one := ( pix_x + x_offset + 1 ) > 639 ? ( pix_x + x_offset + 1 ) - 639 : ( pix_x + x_offset + 1 );
    uint10  y_line := pix_vblank ? y_offset : ( ( pix_y + y_offset ) > 479 ? ( pix_y + y_offset ) - 479 : ( pix_y + y_offset ) );
    uint10  x_pixel := pix_active ? x_plus_one : x_offset;

    // Pixel x and y for writing ( adjusting for offset )
    uint10  x_write_pixel := ( bitmap_x_write + x_offset ) > 639 ? ( bitmap_x_write + x_offset ) - 639 : ( bitmap_x_write + x_offset );
    uint10  y_write_pixel := ( bitmap_y_write + y_offset ) > 479 ? ( bitmap_y_write + y_offset ) - 479 : ( bitmap_y_write + y_offset );

    // Write in range?
    uint1 write_pixel := (bitmap_x_write >= 0 ) && (bitmap_x_write < 640) && (bitmap_y_write >= 0) && (bitmap_y_write <= 479) && bitmap_write;

    // Pixel being read?
    bitmap_colour_read := ( pix_x == bitmap_x_read ) && ( pix_y == bitmap_y_read ) ? bitmap.rdata0 : bitmap_colour_read;

    // Setup the address in the bitmap for the pixel being rendered
    // Use pre-fetching of the next pixel ready for the next cycle
    bitmap.addr0 := x_pixel + ( y_line * 640 );
    bitmap.wenable0 := 0;

    // Bitmap write access for the GPU - Only enable when x and y are in range
    bitmap.wenable1 := 1;

    // Default to transparent
    bitmap_display := pix_active && ~colour7(bitmap.rdata0).alpha;

    // Render the bitmap
    while(1) {
        if( bitmap_display ) {
            pix_red = colour7(bitmap.rdata0).red;
            pix_green = colour7(bitmap.rdata0).green;
            pix_blue = colour7(bitmap.rdata0).blue;
        }

        if( write_pixel == 1 ) {
            bitmap.addr1 = x_write_pixel + y_write_pixel * 640;
            bitmap.wdata1 = bitmap_colour_write;
        }

        switch( bitmap_write_offset ) {
            case 1: {
                x_offset = ( x_offset == 639 ) ? 0 : x_offset + 1;
            }
            case 2: {
                y_offset = ( y_offset == 479 ) ? 0 : y_offset + 1;
            }
            case 3: {
                x_offset = ( x_offset == 0 ) ? 639 : x_offset - 1;
            }
            case 4: {
                y_offset = ( y_offset == 0 ) ? 479 : y_offset - 1;
            }
            case 5: {
                x_offset = 0;
                y_offset = 0;
            }
        }
   }
}

// Vector Block
// Stores blocks of upto 16 vertices which can be sent to the GPU for line drawing
// Each vertices represents a delta from the centre of the vector
// Deltas are stored as 6 bit 2's complement range -31 to 0 to 31
// Each vertices has an active flag, processing of a vector block stops when the active flag is 0
// Each vector block has a centre x and y coordinate and a colour { rrggbb } when drawn

bitfield vectorentry {
    uint1   active,
    uint1   dxsign,
    uint5   dx,
    uint1   dysign,
    uint5   dy
}

algorithm vectors(
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,

    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,
    input   uint1   vertices_writer_write,

    output  uint1   vector_block_active,

    // Communication with the GPU
    output  int11 gpu_x,
    output  int11 gpu_y,
    output  uint7 gpu_colour,
    output  int11 gpu_param0,
    output  int11 gpu_param1,
    output  uint4 gpu_write,

    input  uint1 gpu_active
) <autorun> {
    // 32 vector blocks each of 16 vertices
    dualport_bram uint13 vertex[512] = uninitialised;

    // Extract deltax and deltay for the present vertices
    int11 deltax := { {6{vectorentry(vertex.rdata0).dxsign}}, vectorentry(vertex.rdata0).dx };
    int11 deltay := { {6{vectorentry(vertex.rdata0).dysign}}, vectorentry(vertex.rdata0).dy };

    // Vertices being processed, plus first coordinate of each line
    uint5 block_number = uninitialised;
    uint5 vertices_number = uninitialised;
    int11 start_x = uninitialised;
    int11 start_y = uninitialised;

    // Set read and write address for the vertices
    vertex.addr0 := block_number * 16 + vertices_number;
    vertex.wenable0 := 0;
    vertex.wenable1 := 1;

    gpu_write := 0;

    vector_block_active = 0;
    vertices_number = 0;

    while(1) {
        if( vertices_writer_write ) {
            vertex.addr1 = vertices_writer_block * 16 + vertices_writer_vertex;
            vertex.wdata1 = { vertices_writer_active, vertices_writer_xdelta, vertices_writer_ydelta };
        }

        if( draw_vector ) {
            block_number = vector_block_number;
            gpu_colour = vector_block_colour;
            vertices_number = 0;
            vector_block_active = 1;
            ++:
            start_x = vector_block_xc + deltax;
            start_y = vector_block_yc + deltay;
            vertices_number = 1;
            ++:
            while( vectorentry(vertex.rdata0).active && ( vertices_number < 16 ) ) {
                gpu_x = start_x;
                gpu_y = start_y;
                gpu_param0 = vector_block_xc + deltax;
                gpu_param1 = vector_block_yc + deltay;

                while( gpu_active ) {}

                gpu_write = 3;

                // Move onto the next of the vertices
                start_x = vector_block_xc + deltax;
                start_y = vector_block_yc + deltay;
                vertices_number = vertices_number + 1;
                ++:
            }
            vector_block_active = 0;
        }
    }
}

// Display List
// Stores GPU or VECTOR commands
// Each display list entry consists of:
//      active
//      command ( 1 - 7 copy details across to the GPU )
//      x y p0 p1 p2 p3 parameters for the GPU command

bitfield dlentry {
    uint1   active,
    uint4   command,
    uint7   colour,
    uint11  x,
    uint11  y,
    uint11  p0,
    uint11  p1,
    uint11  p2,
    uint11  p3
}

algorithm displaylist(
    input   uint5   start_entry,
    input   uint5   finish_entry,
    input   uint1   start_displaylist,
    output  uint1   display_list_active,

    input   uint5   writer_entry_number,
    input   uint1   writer_active,
    input   uint4   writer_command,
    input   uint7   writer_colour,
    input   uint11  writer_x,
    input   uint11  writer_y,
    input   uint11  writer_p0,
    input   uint11  writer_p1,
    input   uint11  writer_p2,
    input   uint11  writer_p3,
    input   uint4   writer_write,

    // Communication with the GPU
    output int11   gpu_x,
    output int11   gpu_y,
    output uint7   gpu_colour,
    output int11   gpu_param0,
    output int11   gpu_param1,
    output int11   gpu_param2,
    output int11   gpu_param3,
    output uint4   gpu_write,
    input  uint1   gpu_active,
) {
    // 32 display list entries
    dualport_bram uint78 dlentries[32] = uninitialised;

    uint5   entry_number = uninitialised;
    uint5   finish_number = uninitialised;

    // Set read address for the display list entry being processed
    dlentries.addr0 := entry_number;
    dlentries.wenable0 := 0;
    dlentries.wenable1 := 1;

    // Dispatch to the GPU
    gpu_write = 0;

    while(1) {
        switch( writer_write ) {
            case 1: {
                dlentries.addr1 = writer_entry_number;
                dlentries.wdata1 = { writer_active, writer_command, writer_colour, writer_x, writer_y, writer_p0, writer_p1, writer_p2, writer_p3 };
            }
        }

        if( start_displaylist ) {
            entry_number = start_entry;
            finish_number = finish_entry;
            display_list_active = 1;
            ++:
            while( entry_number <= finish_number ) {
                ++:
                if( dlentry(dlentries.rdata0).active ) {
                    while( gpu_active != 0 ) {}
                    ++:
                    gpu_write = dlentry(dlentries.rdata0).command;
                    gpu_colour = dlentry(dlentries.rdata0).colour;
                    gpu_x = dlentry(dlentries.rdata0).x;
                    gpu_y = dlentry(dlentries.rdata0).y;
                    gpu_param0 = dlentry(dlentries.rdata0).p0;
                    gpu_param1 = dlentry(dlentries.rdata0).p1;
                    gpu_param2 = dlentry(dlentries.rdata0).p2;
                    gpu_param3 = dlentry(dlentries.rdata0).p3;
                    ++:
                    ++:
                    gpu_write = 0;
                }
                entry_number = entry_number + 1;
                ++:
            }
            display_list_active = 0;
        }
     }
}

algorithm gpu(
    // GPU to SET and GET pixels
    output! int11 bitmap_x_write,
    output! int11 bitmap_y_write,
    output! uint7 bitmap_colour_write,
    output! uint1 bitmap_write,

    // From j1eforth
    input   int11 gpu_x,
    input   int11 gpu_y,
    input   uint8 gpu_colour,
    input   int16 gpu_param0,
    input   int16 gpu_param1,
    input   int16 gpu_param2,
    input   int16 gpu_param3,
    input   uint4 gpu_write,

    // For setting blit1 tile bitmaps
    input   uint5   blit1_writer_tile,
    input   uint4   blit1_writer_line,
    input   uint16  blit1_writer_bitmap,
    input   uint1   blit1_writer_active,

    // VECTOR BLOCK
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,
    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,
    input   uint1   vertices_writer_write,

    // DISPLAY LISTS
    input   uint5   dl_start_entry,
    input   uint5   dl_finish_entry,
    input   uint1   dl_start,
    // For setting entries
    input   uint5   dl_writer_entry_number,
    input   uint1   dl_writer_active,
    input   uint4   dl_writer_command,
    input   uint7   dl_writer_colour,
    input   uint11  dl_writer_x,
    input   uint11  dl_writer_y,
    input   uint11  dl_writer_p0,
    input   uint11  dl_writer_p1,
    input   uint11  dl_writer_p2,
    input   uint11  dl_writer_p3,
    input   uint4   dl_writer_write,

    output  uint1   gpu_active,
    output  uint1   vector_block_active,
    output  uint1   display_list_active
) <autorun> {
    // 32 x 16 x 16 1 bit tilemap for blit1tilemap
    dualport_bram uint16 blit1tilemap[ 512 ] = uninitialized;

    // GPU work variable storage
    // Present GPU pixel and colour
    int11 gpu_active_x = uninitialized;
    int11 gpu_active_y = uninitialized;
    uint7 gpu_active_colour = uninitialized;

    // Temporary storage for GPU operations with meaningful names centre coordinates, end coordinates, width, height, deltas, radius, etc
    int11 gpu_xc = uninitialized;
    int11 gpu_yc = uninitialized;
    int11 gpu_x1 = uninitialized;
    int11 gpu_y1 = uninitialized;
    int11 gpu_x2 = uninitialized;
    int11 gpu_y2 = uninitialized;
    int11 gpu_dx = uninitialized;
    int11 gpu_sx = uninitialized;
    int11 gpu_dy = uninitialized;
    int11 gpu_sy = uninitialized;
    int11 gpu_min_x = uninitialized;
    int11 gpu_max_x = uninitialized;
    int11 gpu_min_y = uninitialized;
    int11 gpu_max_y = uninitialized;
    int11 gpu_numerator = uninitialized;
    int11 gpu_numerator2 = uninitialized;
    int11 gpu_count = uninitialized;
    int11 gpu_max_count = uninitialized;
    uint6 gpu_tile = uninitialized;

    // Filled triangle calculations
    // Is the point sx,sy inside the triangle given by active_x,active_y x1,y1 x2,y2?
    uint1 w0 = uninitialized;
    uint1 w1 = uninitialized;
    uint1 w2 = uninitialized;

    // GPU inputs, copied to according to Forth, VECTOR or DISPLAY LISTS
    int11   x = uninitialized;
    int11   y = uninitialized;
    int16   param0 = uninitialized;
    int16   param1 = uninitialized;
    int16   param2 = uninitialized;
    int16   param3 = uninitialized;
    uint4   write = uninitialized;

    // GPU <-> VECTOR DRAWER Communication
    int11 v_gpu_x = uninitialised;
    int11 v_gpu_y = uninitialised;
    uint7 v_gpu_colour = uninitialised;
    int11 v_gpu_param0 = uninitialised;
    int11 v_gpu_param1 = uninitialised;
    uint4 v_gpu_write = uninitialised;

    vectors vector_drawer (
        vector_block_number <: vector_block_number,
        vector_block_colour <: vector_block_colour,
        vector_block_xc <: vector_block_xc,
        vector_block_yc <: vector_block_yc,
        draw_vector <: draw_vector,
        vertices_writer_block <: vertices_writer_block,
        vertices_writer_vertex <: vertices_writer_vertex,
        vertices_writer_xdelta <: vertices_writer_xdelta,
        vertices_writer_ydelta <: vertices_writer_ydelta,
        vertices_writer_active <: vertices_writer_active,
        vertices_writer_write <: vertices_writer_write,

        vector_block_active :> vector_block_active,

        gpu_x :> v_gpu_x,
        gpu_y :> v_gpu_y,
        gpu_colour :> v_gpu_colour,
        gpu_param0 :> v_gpu_param0,
        gpu_param1 :> v_gpu_param1,
        gpu_write :> v_gpu_write,
        gpu_active <: gpu_active
    );

    // GPU <-> DISPLAY LIST COMMUNICATION
    int11 dl_gpu_x = uninitialised;
    int11 dl_gpu_y = uninitialised;
    uint7 dl_gpu_colour = uninitialised;
    int11 dl_gpu_param0 = uninitialised;
    int11 dl_gpu_param1 = uninitialised;
    int11 dl_gpu_param2 = uninitialised;
    int11 dl_gpu_param3 = uninitialised;
    uint4 dl_gpu_write = uninitialised;

    displaylist displaylist_drawer (
        start_entry <: dl_start_entry,
        finish_entry <: dl_finish_entry,
        start_displaylist <: dl_start,

        writer_entry_number <: dl_writer_entry_number,
        writer_active <: dl_writer_active,
        writer_command <: dl_writer_command,
        writer_colour <: dl_writer_colour,
        writer_x <: dl_writer_x,
        writer_y <: dl_writer_y,
        writer_p0 <: dl_writer_p0,
        writer_p1 <: dl_writer_p1,
        writer_p2 <: dl_writer_p2,
        writer_p3 <: dl_writer_p3,
        writer_write <: dl_writer_write,

        display_list_active :> display_list_active,

        gpu_x :> dl_gpu_x,
        gpu_y :> dl_gpu_y,
        gpu_colour :> dl_gpu_colour,
        gpu_param0 :> dl_gpu_param0,
        gpu_param1 :> dl_gpu_param1,
        gpu_param2 :> dl_gpu_param2,
        gpu_param3 :> dl_gpu_param3,
        gpu_write :> dl_gpu_write,
        gpu_active <: gpu_active
    );

    // blit1tilemap read access for the blit1tilemap
    blit1tilemap.addr0 := gpu_tile * 16 + gpu_active_y;
    blit1tilemap.wenable0 := 0;

    // blit1tilemap write access for the GPU to load tilemaps
    blit1tilemap.wenable1 := 1;

    bitmap_write := 0;
    bitmap_colour_write := gpu_active_colour;


    always {
        if( blit1_writer_active ) {
            blit1tilemap.addr1 = blit1_writer_tile * 16 + blit1_writer_line;
            blit1tilemap.wdata1 = blit1_writer_bitmap;
        }
    }

    while(1) {
        if( ( dl_gpu_write != 0 ) || ( v_gpu_write != 0 ) || ( gpu_write != 0 ) ) {
            if( dl_gpu_write != 0 ) {
                x = dl_gpu_x;
                y = dl_gpu_y;
                gpu_active_colour = dl_gpu_colour;
                param0 = dl_gpu_param0;
                param1 = dl_gpu_param1;
                param2 = dl_gpu_param2;
                param3 = dl_gpu_param3;
                write = dl_gpu_write;
            } else {
                if( v_gpu_write != 0 ) {
                    x = v_gpu_x;
                    y = v_gpu_y;
                    gpu_active_colour = v_gpu_colour;
                    param0 = v_gpu_param0;
                    param1 = v_gpu_param1;
                    write = v_gpu_write;
                } else {
                    if( gpu_write != 0 ) {
                        x = gpu_x;
                        y = gpu_y;
                        gpu_active_colour = gpu_colour;
                        param0 = gpu_param0;
                        param1 = gpu_param1;
                        param2 = gpu_param2;
                        param3 = gpu_param3;
                        write = gpu_write;
                    } else {
                        write = 0;
                    }
                }
            }

            ++:

            switch( write ) {
                case 1: {
                    // Setup writing a pixel colour to x,y
                    // Done directly, does not activate the GPU
                    bitmap_x_write = x;
                    bitmap_y_write = y;
                    bitmap_write = 1;
                }

                case 2: {
                    // Setup drawing a rectangle from x,y to param0,param1 in colour
                    // Ensures that works left to right, top to bottom
                    // Cut out pixels out of 0 <= x <= 639 , 0 <= y <= 479
                    gpu_active_x = ( x < param0 ) ? ( x < 0 ? 0 : x ) : ( param0 < 0 ? 0 : param0 );                // left
                    gpu_active_y = ( y < param1 ) ? ( y < 0 ? 0 : y ) : ( param1 < 0 ? 0 : param1 );                // top
                    gpu_x1 = ( x < param0 ) ? ( x < 0 ? 0 : x )  : ( param0 < 0 ? 0 : param0 );                     // left - for next line
                    gpu_max_x = ( x < param0 ) ? ( param0 > 639 ? 639 : param0 ) : ( x > 639 ? 639 : x );              // right - at end of line
                    gpu_max_y = ( y < param1 ) ? ( param1 > 479 ? 479 : param1 ) : ( y > 479 ? 479 : y );              // bottom - at end of rectangle
                    gpu_active = 1;

                    ++:

                    while( ( gpu_active_x <= gpu_max_x ) && ( gpu_active_y <= gpu_max_y ) ) {
                        bitmap_x_write = gpu_active_x;
                        bitmap_y_write = gpu_active_y;
                        bitmap_write = 1;
                        gpu_active_x = ( gpu_active_x == gpu_max_x ) ? gpu_x1 : gpu_active_x + 1;
                        gpu_active_y = ( gpu_active_x == gpu_max_x ) ? gpu_active_y + 1 : gpu_active_y;
                    }

                    gpu_active = 0;
                }

                case 3: {
                    // Setup drawing a line from x,y to param0,param1 in colour
                    // Ensure LEFT to RIGHT
                    gpu_active_x = ( x < param0 ) ? x : param0;
                    gpu_active_y = ( x < param0 ) ? y : param1;

                    // Absolute DELTAs
                    gpu_dx = ( param0 < x ) ? x - param0 : param0 - x;
                    gpu_dy = ( param1 < y ) ? y - param1 : param1 - y;

                    // Shift X is always POSITIVE
                    gpu_sx = 1;

                    // Shift Y is NEGATIVE or POSITIVE
                    gpu_sy = ( x < param0 ) ? ( ( y < param1 ) ? 1 : -1 ) : ( ( y < param1 ) ? -1 : 1 );

                    gpu_count = 0;
                    gpu_active = 1;

                    ++:

                    gpu_numerator = ( gpu_dx > gpu_dy ) ? ( gpu_dx >> 1 ) : -( gpu_dy >> 1 );
                    gpu_max_count = ( gpu_dx > gpu_dy ) ? gpu_dx : gpu_dy;

                    ++:

                    while( gpu_count <= gpu_max_count ) {
                        bitmap_x_write = gpu_active_x;
                        bitmap_y_write = gpu_active_y;
                        bitmap_write = 1;

                        gpu_numerator2 = gpu_numerator;

                        ++:

                        if ( gpu_numerator2 > (-gpu_dx) ) {
                            gpu_numerator = gpu_numerator - gpu_dy;
                            gpu_active_x = gpu_active_x + gpu_sx;
                        }

                        ++:

                        if( gpu_numerator2 < gpu_dy ) {
                            gpu_numerator = gpu_numerator + gpu_dx;
                            gpu_active_y = gpu_active_y + gpu_sy;
                        }

                        gpu_count = gpu_count + 1;
                    }

                    gpu_active = 0;
                }

                case 4: {
                    // Setup drawing a circle centre x,y or radius param0 in colour
                    gpu_active_x = 0;
                    gpu_active_y = ( ( param0 < 0 ) ? -param0 : param0 );
                    gpu_xc = x;
                    gpu_yc = y;
                    gpu_numerator = 3 - ( 2 * ( ( param0 < 0 ) ? -param0 : param0 ) );

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y >= gpu_active_x ) {
                        bitmap_x_write = gpu_xc + gpu_active_x;
                        bitmap_y_write = gpu_yc + gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_x;
                        bitmap_y_write = gpu_yc + gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_x;
                        bitmap_y_write = gpu_yc - gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_x;
                        bitmap_y_write = gpu_yc - gpu_active_y;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_y;
                        bitmap_y_write = gpu_yc + gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_y;
                        bitmap_y_write = gpu_yc + gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc + gpu_active_y;
                        bitmap_y_write = gpu_yc - gpu_active_x;
                        bitmap_write = 1;
                        ++:
                        bitmap_x_write = gpu_xc - gpu_active_y;
                        bitmap_y_write = gpu_yc - gpu_active_x;
                        bitmap_write = 1;

                        gpu_active_x = gpu_active_x + 1;

                        if( gpu_numerator > 0 ) {
                            gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                            gpu_active_y = gpu_active_y - 1;
                        } else {
                            gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                        }
                    }

                    gpu_active = 0;
                }

                case 5: {
                    // Setup 1 bit 16x16 blitter starting at x,y in colour of tile param0
                    gpu_active_x = 0;
                    gpu_active_y = 0;
                    gpu_x1 = x;
                    gpu_y1 = y;
                    gpu_max_x = 15;
                    gpu_max_y = 15;
                    gpu_tile = param0;

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y < gpu_max_y ) {
                        while( gpu_active_x < gpu_max_x ) {
                            if( blit1tilemap.rdata0[15 -gpu_active_x,1] ) {
                                bitmap_x_write = gpu_x1 + gpu_active_x;
                                bitmap_y_write = gpu_y1 + gpu_active_y;
                                bitmap_write = 1;
                            }
                            gpu_active_x = gpu_active_x + 1;
                        }
                        gpu_active_x = 0;
                        gpu_active_y = gpu_active_y + 1;
                    }

                    gpu_active = 0;
                }

                case 6: {
                    // Setup drawing a filled circle centre x,y or radius param0 in colour
                    // Minimum radius is 4, radius is always positive
                    gpu_active_x = 0;
                    gpu_active_y = ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) );
                    gpu_xc = x;
                    gpu_yc = y;
                    gpu_count = ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) );
                    gpu_numerator = 3 - ( 2 * ( ( param0 < 0 ) ? ( ( param0 < -4 ) ? 4 : -param0 ) : ( ( param0 < 4 ) ? 4 : param0 ) ) );

                    gpu_active = 1;

                    ++:

                    while( gpu_active_y >= gpu_active_x ) {
                        while( gpu_count != 0 ) {
                            bitmap_x_write = gpu_xc + gpu_active_x;
                            bitmap_y_write = gpu_yc + gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_active_x;
                            bitmap_y_write = gpu_yc - gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_active_x;
                            bitmap_y_write = gpu_yc + gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_active_x;
                            bitmap_y_write = gpu_yc - gpu_count;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_count;
                            bitmap_y_write = gpu_yc + gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_count;
                            bitmap_y_write = gpu_yc + gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc + gpu_count;
                            bitmap_y_write = gpu_yc - gpu_active_x;
                            bitmap_write = 1;
                            ++:
                            bitmap_x_write = gpu_xc - gpu_count;
                            bitmap_y_write = gpu_yc - gpu_active_x;
                            bitmap_write = 1;

                            gpu_count = gpu_count - 1;
                        }

                        gpu_active_x = gpu_active_x + 1;

                        if( gpu_numerator > 0 ) {
                            gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                            gpu_active_y = gpu_active_y - 1;
                            gpu_count = gpu_active_y - 1;
                        } else {
                            gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                            gpu_count = gpu_active_y;
                        }
                    }

                    bitmap_x_write = gpu_xc;
                    bitmap_y_write = gpu_yc;
                    bitmap_write = 1;

                    gpu_active = 0;
                }

                case 7: {
                    // Setup drawing a filled triangle x,y param0, param1, param2, param3
                    gpu_active_x = x;
                    gpu_active_y = y;
                    gpu_x1 = param0;
                    gpu_y1 = param1;
                    gpu_x2 = param2;
                    gpu_y2 = param3;

                    gpu_active = 1;

                    ++:

                    // Find minimum and maximum of x, x1 and x2 for the bounding box
                    // Find minimum and maximum of y, y1 and y2 for the bounding box
                    gpu_min_x = ( gpu_active_x < gpu_x1 ) ? ( ( gpu_active_x < gpu_x2 ) ? gpu_active_x : gpu_x2 ) : ( ( gpu_x1 < gpu_x2 ) ? gpu_x1: gpu_x2 );
                    gpu_min_y = ( gpu_active_y < gpu_y1 ) ? ( ( gpu_active_y < gpu_y2 ) ? gpu_active_y : gpu_y2 ) : ( ( gpu_y1 < gpu_y2 ) ? gpu_y1: gpu_y2 );
                    gpu_max_x = ( gpu_active_x > gpu_x1 ) ? ( ( gpu_active_x > gpu_x2 ) ? gpu_active_x : gpu_x2 ) : ( ( gpu_x1 > gpu_x2 ) ? gpu_x1 : gpu_x2 );
                    gpu_max_y = ( gpu_active_y > gpu_y1 ) ? ( ( gpu_active_y > gpu_y2 ) ? gpu_active_y : gpu_y2 ) : ( ( gpu_y1 > gpu_y2 ) ? gpu_y1 : gpu_y2 );

                    ++:

                    // Clip to the screen edge
                    gpu_min_x = ( gpu_min_x < 0 ) ? 0 : gpu_min_x;
                    gpu_min_y = ( gpu_min_y < 0 ) ? 0 : gpu_min_y;
                    gpu_max_x = ( gpu_min_x > 639 ) ? 639 : gpu_max_x;
                    gpu_max_y = ( gpu_min_y > 479 ) ? 479 : gpu_max_y;

                    ++:

                    // Find the point closest to the top of the screen
                    if( gpu_y1 < gpu_active_y ) {
                        gpu_active_x = gpu_x1;
                        gpu_active_y = gpu_y1;
                        gpu_x1 = gpu_active_x;
                        gpu_y1 = gpu_active_y;
                    }

                    ++:

                    if( gpu_y2 < gpu_active_y ) {
                        gpu_active_x = gpu_x2;
                        gpu_active_y = gpu_y2;
                        gpu_x2 = gpu_active_x;
                        gpu_y2 = gpu_active_y;
                    }

                    ++:

                    // Point order is top of screen then down to the right
                    if( gpu_x1 < gpu_x2 ) {
                        gpu_x2 = gpu_x1;
                        gpu_y2 = gpu_y1;
                        gpu_x1 = gpu_x2;
                        gpu_y1 = gpu_y2;
                    }

                    ++:

                    // Start at the top left
                    gpu_sx = gpu_min_x;
                    gpu_sy = gpu_min_y;
                    gpu_dx = 1;
                    gpu_count = 0;

                    ++:

                    while( gpu_sy <= gpu_max_y ) {
                        ++:

                        // Edge calculations to determine if inside the triangle - converted to DSP blocks
                        w0 = (( gpu_x2 - gpu_x1 ) * ( gpu_sy - gpu_y1 ) - ( gpu_y2 - gpu_y1 ) * ( gpu_sx - gpu_x1 )) >= 0;
                        w1 = (( gpu_active_x - gpu_x2 ) * ( gpu_sy - gpu_y2 ) - ( gpu_active_y - gpu_y2 ) * ( gpu_sx - gpu_x2 )) >= 0;
                        w2 = (( gpu_x1 - gpu_active_x ) * ( gpu_sy - gpu_active_y ) - ( gpu_y1 - gpu_active_y ) * ( gpu_sx - gpu_active_x )) >= 0;

                        ++:

                        bitmap_x_write = gpu_sx;
                        bitmap_y_write = gpu_sy;
                        bitmap_write = ( w0 && w1 && w2 );

                        gpu_count = ( w0 && w1 && w2 ) ? 1 : gpu_count;

                        ++:

                        if( ( gpu_count == 1 ) && ~( w0 && w1 && w2 ) ) {
                            // Exited the triangle, move to the next line
                            gpu_count = 0;
                            gpu_sy = gpu_sy + 1;
                            if( ( gpu_max_x - gpu_sx ) < ( gpu_sx - gpu_min_x ) ) {
                                // Closer to the right
                                gpu_sx = gpu_max_x;
                                gpu_dx = -1;
                            } else {
                                // Closer to the left
                                gpu_sx = gpu_min_x;
                                gpu_dx = 1;
                            }
                        } else {
                            switch( gpu_dx ) {
                                case 1: {
                                    if( gpu_sx < gpu_max_x ) {
                                        gpu_sx = gpu_sx + 1;
                                    } else {
                                        gpu_dx = -1;
                                        gpu_count = 0;
                                        gpu_sy = gpu_sy + 1;
                                    }
                                }
                                default: {
                                    if( gpu_sx > gpu_min_x ) {
                                        gpu_sx = gpu_sx - 1;
                                    } else {
                                        gpu_dx = 1;
                                        gpu_count = 0;
                                        gpu_sy = gpu_sy + 1;
                                    }
                                }
                            }
                        }
                    }

                    gpu_active = 0;
                }
            }
        }
    }
}

algorithm background(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,

    input uint16 staticGenerator,

    input uint6 backgroundcolour,
    input uint6 backgroundcolour_alt,
    input uint3 backgroundcolour_mode,
    input uint3 background_write
) <autorun> {
    uint6 background = 0;
    uint6 background_alt = 0;
    uint3 background_mode = 0;

    // Variables for SNOW (from @sylefeb)
    int10   dotpos = 0;
    int2    speed = 0;
    int2    inv_speed = 0;
    int12   rand_x = 0;
    int32   frame = 0;

    // Default to black
    pix_red := 0;
    pix_green := 0;
    pix_blue := 0;

    always {
        switch( background_write ) {
            case 1: { background = backgroundcolour; }
            case 2: { background_alt = backgroundcolour_alt; }
            case 3: { background_mode = backgroundcolour_mode; }
            default: {}
        }

        // Increment frame number for the snow/star field
        frame = ( ( pix_x == 639 ) && ( pix_y == 470 ) ) ? frame + 1 : frame;
    }

    while(1) {
        switch( backgroundcolour_mode ) {
            case 0: {
                // SOLID
                pix_red = colour6(background).red;
                pix_green = colour6(background).green;
                pix_blue = colour6(background).blue;
            }
            case 1: {
                // SMALL checkerboard
                switch( { pix_x[0,1], pix_y[0,1] } ) {
                    case 2b00: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                    case 2b01: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b10: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b11: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                }
            }
            case 2: {
                // MEDIUM checkerboard
                switch( { pix_x[1,1], pix_y[1,1] } ) {
                    case 2b00: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                    case 2b01: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b10: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b11: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                }
            }
            case 3: {
                // LARGE checkerboard
                switch( { pix_x[2,1], pix_y[2,1] } ) {
                    case 2b00: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                    case 2b01: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b10: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b11: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                }
            }
            case 4: {
                // HUGE checkerboard
                switch( { pix_x[3,1], pix_y[3,1] } ) {
                    case 2b00: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                    case 2b01: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b10: {
                        pix_red = colour6(background_alt).red;
                        pix_green = colour6(background_alt).green;
                        pix_blue = colour6(background_alt).blue;
                    }
                    case 2b11: {
                        pix_red = colour6(background).red;
                        pix_green = colour6(background).green;
                        pix_blue = colour6(background).blue;
                    }
                }
            }
            case 5: {
                // 8 colour rainbow
                switch( pix_y[6,3] ) {
                    case 3b000: { pix_red = 2; }
                    case 3b001: { pix_red = 3; }
                    case 3b010: { pix_red = 3; pix_green = 2; }
                    case 3b011: { pix_red = 3; pix_green = 3; }
                    case 3b100: { pix_green = 3; }
                    case 3b101: { pix_blue = 3; }
                    case 3b110: { pix_red = 1; pix_blue = 2; }
                    case 3b111: { pix_red = 1; pix_green = 2; pix_blue = 3; }
                }
            }
            case 6: {
                // Static
                pix_red = staticGenerator[0,2];
                pix_green = staticGenerator[0,2];
                pix_blue = staticGenerator[0,2];
            }
            case 7: {
                // SNOW (from @sylefeb)
                rand_x = ( pix_x == 0)  ? 1 : rand_x * 31421 + 6927;
                speed  = rand_x[10,2];
                dotpos = ( frame >> speed ) + rand_x;
                    pix_red   = (pix_y == dotpos) ? colour6(background).red : colour6(background_alt).red;
                    pix_green = (pix_y == dotpos) ? colour6(background).green : colour6(background_alt).green;
                    pix_blue  = (pix_y == dotpos) ? colour6(background).blue : colour6(background_alt).blue;
            }
            default: {}
        }
    }
}

bitfield spriteupdate {
    uint1   colour_act,         // 1 change the colour
    uint6   colour,             // { rrggbb }
    uint1   y_act,              // 1 - kill when off screen, 0 - wrap
    uint1   x_act,              // 1 - kill when off screen, 0 - wrap
    uint1   tile_act,           // 1 - increase the tile number
    uint1   dysign,             // dy - 2's complement update for the y coordinate
    uint2   dy,
    uint1   dxsign,             // dx - 2's complement update for the x coordinate
    uint2   dx
}

algorithm sprite_layer(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   sprite_layer_display,

    // For setting sprite characteristics
    input   uint4   sprite_set_number,
    input   uint1   sprite_set_active,
    input   uint1   sprite_set_double,
    input   uint6   sprite_set_colour,
    input   int11   sprite_set_x,
    input   int11   sprite_set_y,
    input   uint3   sprite_set_tile,
    // Flag to set the above
    input   uint4   sprite_layer_write,

    // For reading sprite characteristics for sprite_set_number
    output uint1   sprite_read_active,
    output uint1   sprite_read_double,
    output uint6   sprite_read_colour,
    output int11   sprite_read_x,
    output int11   sprite_read_y,
    output uint3   sprite_read_tile,

    input   uint16  sprite_update,

    // FULL collision detection
    // (1) Bitmap, (2) Tile Map, (3) Other Sprite Layer
    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
        output uint16 collision_0,
        output uint16 collision_1,
        output uint16 collision_2,
        output uint16 collision_3,
        output uint16 collision_4,
        output uint16 collision_5,
        output uint16 collision_6,
        output uint16 collision_7,
        output uint16 collision_8,
        output uint16 collision_9,
        output uint16 collision_10,
        output uint16 collision_11,
        output uint16 collision_12,

    // For setting sprite tile bitmaps
    input   uint4   sprite_writer_sprite,
    input   uint7   sprite_writer_line,
    input   uint16  sprite_writer_bitmap,
    input   uint1   sprite_writer_active

) <autorun> {
    // Storage for the sprites
    // Stored as registers as needed instantly
    uint1 sprite_active[13] = uninitialised;
    uint1 sprite_double[13] = uninitialised;
    int11 sprite_x[13] = uninitialised;
    int11 sprite_y[13] = uninitialised;
    uint6 sprite_colour[13] = uninitialised;
    uint3 sprite_tile_number[13] = uninitialised;

        // Sprite Tiles
        dualport_bram uint16 tiles_0[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_0 := sprite_double[0] ? 32 : 16;
        uint4 xinsprite_0 := 15  - ( ( pix_x - sprite_x[0] ) >> sprite_double[0] );
        uint4 yinsprite_0 := ( pix_y - sprite_y[0] ) >> sprite_double[0];
        uint1 xinrange_0 := ( pix_x >= sprite_x[0] ) && ( pix_x < ( sprite_x[0] + spritesize_0 ) );
        uint1 yinrange_0 := ( pix_y >= sprite_y[0] ) && ( pix_y < ( sprite_y[0] + spritesize_0 ) );
        uint1 pix_visible_0 := sprite_active[0] && xinrange_0 && yinrange_0 && ( tiles_0.rdata0[ xinsprite_0, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_0 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_1[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_1 := sprite_double[1] ? 32 : 16;
        uint4 xinsprite_1 := 15  - ( ( pix_x - sprite_x[1] ) >> sprite_double[1] );
        uint4 yinsprite_1 := ( pix_y - sprite_y[1] ) >> sprite_double[1];
        uint1 xinrange_1 := ( pix_x >= sprite_x[1] ) && ( pix_x < ( sprite_x[1] + spritesize_1 ) );
        uint1 yinrange_1 := ( pix_y >= sprite_y[1] ) && ( pix_y < ( sprite_y[1] + spritesize_1 ) );
        uint1 pix_visible_1 := sprite_active[1] && xinrange_1 && yinrange_1 && ( tiles_1.rdata0[ xinsprite_1, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_1 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_2[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_2 := sprite_double[2] ? 32 : 16;
        uint4 xinsprite_2 := 15  - ( ( pix_x - sprite_x[2] ) >> sprite_double[2] );
        uint4 yinsprite_2 := ( pix_y - sprite_y[2] ) >> sprite_double[2];
        uint1 xinrange_2 := ( pix_x >= sprite_x[2] ) && ( pix_x < ( sprite_x[2] + spritesize_2 ) );
        uint1 yinrange_2 := ( pix_y >= sprite_y[2] ) && ( pix_y < ( sprite_y[2] + spritesize_2 ) );
        uint1 pix_visible_2 := sprite_active[2] && xinrange_2 && yinrange_2 && ( tiles_2.rdata0[ xinsprite_2, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_2 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_3[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_3 := sprite_double[3] ? 32 : 16;
        uint4 xinsprite_3 := 15  - ( ( pix_x - sprite_x[3] ) >> sprite_double[3] );
        uint4 yinsprite_3 := ( pix_y - sprite_y[3] ) >> sprite_double[3];
        uint1 xinrange_3 := ( pix_x >= sprite_x[3] ) && ( pix_x < ( sprite_x[3] + spritesize_3 ) );
        uint1 yinrange_3 := ( pix_y >= sprite_y[3] ) && ( pix_y < ( sprite_y[3] + spritesize_3 ) );
        uint1 pix_visible_3 := sprite_active[3] && xinrange_3 && yinrange_3 && ( tiles_3.rdata0[ xinsprite_3, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_3 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_4[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_4 := sprite_double[4] ? 32 : 16;
        uint4 xinsprite_4 := 15  - ( ( pix_x - sprite_x[4] ) >> sprite_double[4] );
        uint4 yinsprite_4 := ( pix_y - sprite_y[4] ) >> sprite_double[4];
        uint1 xinrange_4 := ( pix_x >= sprite_x[4] ) && ( pix_x < ( sprite_x[4] + spritesize_4 ) );
        uint1 yinrange_4 := ( pix_y >= sprite_y[4] ) && ( pix_y < ( sprite_y[4] + spritesize_4 ) );
        uint1 pix_visible_4 := sprite_active[4] && xinrange_4 && yinrange_4 && ( tiles_4.rdata0[ xinsprite_4, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_4 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_5[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_5 := sprite_double[5] ? 32 : 16;
        uint4 xinsprite_5 := 15  - ( ( pix_x - sprite_x[5] ) >> sprite_double[5] );
        uint4 yinsprite_5 := ( pix_y - sprite_y[5] ) >> sprite_double[5];
        uint1 xinrange_5 := ( pix_x >= sprite_x[5] ) && ( pix_x < ( sprite_x[5] + spritesize_5 ) );
        uint1 yinrange_5 := ( pix_y >= sprite_y[5] ) && ( pix_y < ( sprite_y[5] + spritesize_5 ) );
        uint1 pix_visible_5 := sprite_active[5] && xinrange_5 && yinrange_5 && ( tiles_5.rdata0[ xinsprite_5, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_5 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_6[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_6 := sprite_double[6] ? 32 : 16;
        uint4 xinsprite_6 := 15  - ( ( pix_x - sprite_x[6] ) >> sprite_double[6] );
        uint4 yinsprite_6 := ( pix_y - sprite_y[6] ) >> sprite_double[6];
        uint1 xinrange_6 := ( pix_x >= sprite_x[6] ) && ( pix_x < ( sprite_x[6] + spritesize_6 ) );
        uint1 yinrange_6 := ( pix_y >= sprite_y[6] ) && ( pix_y < ( sprite_y[6] + spritesize_6 ) );
        uint1 pix_visible_6 := sprite_active[6] && xinrange_6 && yinrange_6 && ( tiles_6.rdata0[ xinsprite_6, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_6 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_7[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_7 := sprite_double[7] ? 32 : 16;
        uint4 xinsprite_7 := 15  - ( ( pix_x - sprite_x[7] ) >> sprite_double[7] );
        uint4 yinsprite_7 := ( pix_y - sprite_y[7] ) >> sprite_double[7];
        uint1 xinrange_7 := ( pix_x >= sprite_x[7] ) && ( pix_x < ( sprite_x[7] + spritesize_7 ) );
        uint1 yinrange_7 := ( pix_y >= sprite_y[7] ) && ( pix_y < ( sprite_y[7] + spritesize_7 ) );
        uint1 pix_visible_7 := sprite_active[7] && xinrange_7 && yinrange_7 && ( tiles_7.rdata0[ xinsprite_7, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_7 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_8[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_8 := sprite_double[8] ? 32 : 16;
        uint4 xinsprite_8 := 15  - ( ( pix_x - sprite_x[8] ) >> sprite_double[8] );
        uint4 yinsprite_8 := ( pix_y - sprite_y[8] ) >> sprite_double[8];
        uint1 xinrange_8 := ( pix_x >= sprite_x[8] ) && ( pix_x < ( sprite_x[8] + spritesize_8 ) );
        uint1 yinrange_8 := ( pix_y >= sprite_y[8] ) && ( pix_y < ( sprite_y[8] + spritesize_8 ) );
        uint1 pix_visible_8 := sprite_active[8] && xinrange_8 && yinrange_8 && ( tiles_8.rdata0[ xinsprite_8, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_8 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_9[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_9 := sprite_double[9] ? 32 : 16;
        uint4 xinsprite_9 := 15  - ( ( pix_x - sprite_x[9] ) >> sprite_double[9] );
        uint4 yinsprite_9 := ( pix_y - sprite_y[9] ) >> sprite_double[9];
        uint1 xinrange_9 := ( pix_x >= sprite_x[9] ) && ( pix_x < ( sprite_x[9] + spritesize_9 ) );
        uint1 yinrange_9 := ( pix_y >= sprite_y[9] ) && ( pix_y < ( sprite_y[9] + spritesize_9 ) );
        uint1 pix_visible_9 := sprite_active[9] && xinrange_9 && yinrange_9 && ( tiles_9.rdata0[ xinsprite_9, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_9 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_10[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_10 := sprite_double[10] ? 32 : 16;
        uint4 xinsprite_10 := 15  - ( ( pix_x - sprite_x[10] ) >> sprite_double[10] );
        uint4 yinsprite_10 := ( pix_y - sprite_y[10] ) >> sprite_double[10];
        uint1 xinrange_10 := ( pix_x >= sprite_x[10] ) && ( pix_x < ( sprite_x[10] + spritesize_10 ) );
        uint1 yinrange_10 := ( pix_y >= sprite_y[10] ) && ( pix_y < ( sprite_y[10] + spritesize_10 ) );
        uint1 pix_visible_10 := sprite_active[10] && xinrange_10 && yinrange_10 && ( tiles_10.rdata0[ xinsprite_10, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_10 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_11[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_11 := sprite_double[11] ? 32 : 16;
        uint4 xinsprite_11 := 15  - ( ( pix_x - sprite_x[11] ) >> sprite_double[11] );
        uint4 yinsprite_11 := ( pix_y - sprite_y[11] ) >> sprite_double[11];
        uint1 xinrange_11 := ( pix_x >= sprite_x[11] ) && ( pix_x < ( sprite_x[11] + spritesize_11 ) );
        uint1 yinrange_11 := ( pix_y >= sprite_y[11] ) && ( pix_y < ( sprite_y[11] + spritesize_11 ) );
        uint1 pix_visible_11 := sprite_active[11] && xinrange_11 && yinrange_11 && ( tiles_11.rdata0[ xinsprite_11, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_11 = uninitialised;
        // Sprite Tiles
        dualport_bram uint16 tiles_12[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_12 := sprite_double[12] ? 32 : 16;
        uint4 xinsprite_12 := 15  - ( ( pix_x - sprite_x[12] ) >> sprite_double[12] );
        uint4 yinsprite_12 := ( pix_y - sprite_y[12] ) >> sprite_double[12];
        uint1 xinrange_12 := ( pix_x >= sprite_x[12] ) && ( pix_x < ( sprite_x[12] + spritesize_12 ) );
        uint1 yinrange_12 := ( pix_y >= sprite_y[12] ) && ( pix_y < ( sprite_y[12] + spritesize_12 ) );
        uint1 pix_visible_12 := sprite_active[12] && xinrange_12 && yinrange_12 && ( tiles_12.rdata0[ xinsprite_12, 1 ] == 1 );

        // Collision detection flag
        uint16      detect_collision_12 = uninitialised;

    // Expand Sprite Update Deltas
    int11   deltax := { {9{spriteupdate( sprite_update ).dxsign}}, spriteupdate( sprite_update ).dx };
    int11   deltay := { {9{spriteupdate( sprite_update ).dysign}}, spriteupdate( sprite_update ).dy };

    // Set read and write address for the tiles
        tiles_0.addr0 := sprite_tile_number[0] * 16 + yinsprite_0;
        tiles_0.wenable0 := 0;
        tiles_0.wenable1 := 1;
        tiles_1.addr0 := sprite_tile_number[1] * 16 + yinsprite_1;
        tiles_1.wenable0 := 0;
        tiles_1.wenable1 := 1;
        tiles_2.addr0 := sprite_tile_number[2] * 16 + yinsprite_2;
        tiles_2.wenable0 := 0;
        tiles_2.wenable1 := 1;
        tiles_3.addr0 := sprite_tile_number[3] * 16 + yinsprite_3;
        tiles_3.wenable0 := 0;
        tiles_3.wenable1 := 1;
        tiles_4.addr0 := sprite_tile_number[4] * 16 + yinsprite_4;
        tiles_4.wenable0 := 0;
        tiles_4.wenable1 := 1;
        tiles_5.addr0 := sprite_tile_number[5] * 16 + yinsprite_5;
        tiles_5.wenable0 := 0;
        tiles_5.wenable1 := 1;
        tiles_6.addr0 := sprite_tile_number[6] * 16 + yinsprite_6;
        tiles_6.wenable0 := 0;
        tiles_6.wenable1 := 1;
        tiles_7.addr0 := sprite_tile_number[7] * 16 + yinsprite_7;
        tiles_7.wenable0 := 0;
        tiles_7.wenable1 := 1;
        tiles_8.addr0 := sprite_tile_number[8] * 16 + yinsprite_8;
        tiles_8.wenable0 := 0;
        tiles_8.wenable1 := 1;
        tiles_9.addr0 := sprite_tile_number[9] * 16 + yinsprite_9;
        tiles_9.wenable0 := 0;
        tiles_9.wenable1 := 1;
        tiles_10.addr0 := sprite_tile_number[10] * 16 + yinsprite_10;
        tiles_10.wenable0 := 0;
        tiles_10.wenable1 := 1;
        tiles_11.addr0 := sprite_tile_number[11] * 16 + yinsprite_11;
        tiles_11.wenable0 := 0;
        tiles_11.wenable1 := 1;
        tiles_12.addr0 := sprite_tile_number[12] * 16 + yinsprite_12;
        tiles_12.wenable0 := 0;
        tiles_12.wenable1 := 1;

    // Default to transparent
    sprite_layer_display := 0;

    // Sprite details reader
    sprite_read_active := sprite_active[ sprite_set_number ];
    sprite_read_double := sprite_double[ sprite_set_number ];
    sprite_read_colour := sprite_colour[ sprite_set_number ];
    sprite_read_x := sprite_x[ sprite_set_number ];
    sprite_read_y := sprite_y[ sprite_set_number ];
    sprite_read_tile := sprite_tile_number[ sprite_set_number ];

    // Write to the sprite_layer
    // Set tile bitmaps, x coordinate, y coordinate, colour, tile number, visibility, double
    always {
        // WRITE BITMAP TO SPRITE TILE
        if( sprite_writer_active ) {
            switch( sprite_writer_sprite ) {
                    case 0: {
                        tiles_0.addr1 = sprite_writer_line;
                        tiles_0.wdata1 = sprite_writer_bitmap;
                    }
                    case 1: {
                        tiles_1.addr1 = sprite_writer_line;
                        tiles_1.wdata1 = sprite_writer_bitmap;
                    }
                    case 2: {
                        tiles_2.addr1 = sprite_writer_line;
                        tiles_2.wdata1 = sprite_writer_bitmap;
                    }
                    case 3: {
                        tiles_3.addr1 = sprite_writer_line;
                        tiles_3.wdata1 = sprite_writer_bitmap;
                    }
                    case 4: {
                        tiles_4.addr1 = sprite_writer_line;
                        tiles_4.wdata1 = sprite_writer_bitmap;
                    }
                    case 5: {
                        tiles_5.addr1 = sprite_writer_line;
                        tiles_5.wdata1 = sprite_writer_bitmap;
                    }
                    case 6: {
                        tiles_6.addr1 = sprite_writer_line;
                        tiles_6.wdata1 = sprite_writer_bitmap;
                    }
                    case 7: {
                        tiles_7.addr1 = sprite_writer_line;
                        tiles_7.wdata1 = sprite_writer_bitmap;
                    }
                    case 8: {
                        tiles_8.addr1 = sprite_writer_line;
                        tiles_8.wdata1 = sprite_writer_bitmap;
                    }
                    case 9: {
                        tiles_9.addr1 = sprite_writer_line;
                        tiles_9.wdata1 = sprite_writer_bitmap;
                    }
                    case 10: {
                        tiles_10.addr1 = sprite_writer_line;
                        tiles_10.wdata1 = sprite_writer_bitmap;
                    }
                    case 11: {
                        tiles_11.addr1 = sprite_writer_line;
                        tiles_11.wdata1 = sprite_writer_bitmap;
                    }
                    case 12: {
                        tiles_12.addr1 = sprite_writer_line;
                        tiles_12.wdata1 = sprite_writer_bitmap;
                    }
            }
        }

        switch( sprite_layer_write ) {
            case 1: { sprite_active[ sprite_set_number ] = sprite_set_active; }
            case 2: { sprite_tile_number[ sprite_set_number ] = sprite_set_tile; }
            case 3: { sprite_colour[ sprite_set_number ] = sprite_set_colour; }
            case 4: { sprite_x[ sprite_set_number ] = sprite_set_x; }
            case 5: { sprite_y[ sprite_set_number ] = sprite_set_y; }
            case 6: { sprite_double[ sprite_set_number ] = sprite_set_double; }
            case 10: {
                // Perform sprite update
                sprite_colour[ sprite_set_number ] = ( spriteupdate( sprite_update ).colour_act ) ? spriteupdate( sprite_update ).colour : sprite_colour[ sprite_set_number ];
                sprite_tile_number[ sprite_set_number ] = ( spriteupdate( sprite_update ).tile_act ) ? sprite_tile_number[ sprite_set_number ] + 1 : sprite_tile_number[ sprite_set_number ];

                sprite_x[ sprite_set_number ] = (__signed( sprite_x[ sprite_set_number ] ) < __signed(-16)) ? 640 :
                                                ( (__signed( sprite_x[ sprite_set_number ] ) > __signed(640)) ? -15 : sprite_x[ sprite_set_number ] + deltax );
                sprite_y[ sprite_set_number ] = (__signed( sprite_y[ sprite_set_number ] ) < __signed(-16)) ? 480 :
                                                ( (__signed( sprite_y[ sprite_set_number ] ) > __signed(480)) ? -15 : sprite_y[ sprite_set_number ] + deltay );

                sprite_active[ sprite_set_number ] = ( ( ( (__signed( sprite_x[ sprite_set_number ] ) < __signed(-16)) ||
                                                        (__signed( sprite_x[ sprite_set_number ] ) > __signed(640)) ) && ( spriteupdate( sprite_update ).x_act ) ) ||
                                                        ( ( (__signed( sprite_y[ sprite_set_number ] ) < __signed(-16)) ||
                                                        (__signed( sprite_y[ sprite_set_number ] ) > __signed(480)) ) && spriteupdate( sprite_update ).y_act ) ) ?
                                                        0 : sprite_active[ sprite_set_number ];
            }
        }
    }

    // Render the sprite layer
    while(1) {

        if( pix_vblank ) {
            // RESET collision detection
                detect_collision_0 = 0;
                detect_collision_1 = 0;
                detect_collision_2 = 0;
                detect_collision_3 = 0;
                detect_collision_4 = 0;
                detect_collision_5 = 0;
                detect_collision_6 = 0;
                detect_collision_7 = 0;
                detect_collision_8 = 0;
                detect_collision_9 = 0;
                detect_collision_10 = 0;
                detect_collision_11 = 0;
                detect_collision_12 = 0;
        } else {
            if( pix_active ) {
                    if(  ( pix_visible_0 ) ) {
                        pix_red = sprite_colour[0][4,2];
                        pix_green = sprite_colour[0][2,2];
                        pix_blue = sprite_colour[0][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_0 = detect_collision_0 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_1 ) ) {
                        pix_red = sprite_colour[1][4,2];
                        pix_green = sprite_colour[1][2,2];
                        pix_blue = sprite_colour[1][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_1 = detect_collision_1 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_2 ) ) {
                        pix_red = sprite_colour[2][4,2];
                        pix_green = sprite_colour[2][2,2];
                        pix_blue = sprite_colour[2][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_2 = detect_collision_2 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_3 ) ) {
                        pix_red = sprite_colour[3][4,2];
                        pix_green = sprite_colour[3][2,2];
                        pix_blue = sprite_colour[3][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_3 = detect_collision_3 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_4 ) ) {
                        pix_red = sprite_colour[4][4,2];
                        pix_green = sprite_colour[4][2,2];
                        pix_blue = sprite_colour[4][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_4 = detect_collision_4 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_5 ) ) {
                        pix_red = sprite_colour[5][4,2];
                        pix_green = sprite_colour[5][2,2];
                        pix_blue = sprite_colour[5][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_5 = detect_collision_5 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_6 ) ) {
                        pix_red = sprite_colour[6][4,2];
                        pix_green = sprite_colour[6][2,2];
                        pix_blue = sprite_colour[6][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_6 = detect_collision_6 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_7 ) ) {
                        pix_red = sprite_colour[7][4,2];
                        pix_green = sprite_colour[7][2,2];
                        pix_blue = sprite_colour[7][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_7 = detect_collision_7 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_8 ) ) {
                        pix_red = sprite_colour[8][4,2];
                        pix_green = sprite_colour[8][2,2];
                        pix_blue = sprite_colour[8][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_8 = detect_collision_8 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_9 ) ) {
                        pix_red = sprite_colour[9][4,2];
                        pix_green = sprite_colour[9][2,2];
                        pix_blue = sprite_colour[9][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_9 = detect_collision_9 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_10 ) ) {
                        pix_red = sprite_colour[10][4,2];
                        pix_green = sprite_colour[10][2,2];
                        pix_blue = sprite_colour[10][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_10 = detect_collision_10 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_11 ) ) {
                        pix_red = sprite_colour[11][4,2];
                        pix_green = sprite_colour[11][2,2];
                        pix_blue = sprite_colour[11][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_11 = detect_collision_11 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_12 ) ) {
                        pix_red = sprite_colour[12][4,2];
                        pix_green = sprite_colour[12][2,2];
                        pix_blue = sprite_colour[12][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_12 = detect_collision_12 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
            }
        }

        // Output collision detection
        if( ( pix_x == 639 ) && ( pix_y == 479 ) ) {
                collision_0 = detect_collision_0;
                collision_1 = detect_collision_1;
                collision_2 = detect_collision_2;
                collision_3 = detect_collision_3;
                collision_4 = detect_collision_4;
                collision_5 = detect_collision_5;
                collision_6 = detect_collision_6;
                collision_7 = detect_collision_7;
                collision_8 = detect_collision_8;
                collision_9 = detect_collision_9;
                collision_10 = detect_collision_10;
                collision_11 = detect_collision_11;
                collision_12 = detect_collision_12;
        }
    }
}

bitfield tilemapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint5   tilenumber
}

algorithm tilemap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   tilemap_display,

    // Set TM at x, y, character with foreground and background
    input uint6 tm_x,
    input uint6 tm_y,
    input uint5 tm_character,
    input uint6 tm_foreground,
    input uint7 tm_background,
    input uint1 tm_write,

    // For setting tile bitmaps
    input   uint5   tile_writer_tile,
    input   uint4   tile_writer_line,
    input   uint16  tile_writer_bitmap,
    input   uint1   tile_writer_write,

    // For scrolling/wrapping
    input   uint4   tm_scrollwrap,
    output  uint4   tm_lastaction,
    output  uint8   tm_active
) <autorun> {
    // Tile Map 32 x 16 x 16
    dualport_bram uint16 tiles16x16[ 512 ] = { 0, pad(0) };

    // 42 x 32 tile map, allows for pixel scrolling with border
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    dualport_bram uint18 tiles[1344] = { 18b100000000000000000, pad(18b100000000000000000) };

    // Scroll position - -15 to 0 to 15
    // -15 or 15 will trigger appropriate scroll when next moved in that direction
    int5    tm_offset_x = 0;
    int5    tm_offset_y = 0;

    // Scroller/Wrapper storage
    uint1   tm_scroll = uninitialized;
    uint6   x_cursor = uninitialized;
    uint6   y_cursor = uninitialized;
    uint11  y_cursor_addr = uninitialized;
    uint18  new_tile = uninitialized;
    uint18  scroll_tile = uninitialized;

    // CS address
    uint11  tmcsaddr = uninitialized;

    // Character position on the screen x 0-41, y 0-31 * 42 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    // Adjust for the offsets, effective 0 point margin is ( 1,1 ) to ( 40,30 ) with a 1 tile border
    uint11  xtmpos :=  ( pix_active ? pix_x + ( 11d18 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) : ( 11d16 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) ) >> 4;
    uint11  ytmpos := (( pix_vblank ? ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) : pix_y + ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) ) >> 4) * 42;

    // Derive the x and y coordinate within the current 16x16 tilemap block x 0-7, y 0-15
    // Needs adjusting for the offsets
    uint4   xintm := { 1b0, (pix_x) & 15 } + tm_offset_x;
    uint4   yintm := { 1b0, (pix_y) & 15 } + tm_offset_y;

    // Derive the actual pixel in the current character
    uint1   tmpixel := tiles16x16.rdata0[15 - xintm,1];

    // Set up reading of the tilemap
    tiles.addr0 := xtmpos + ytmpos;
    tiles.wenable0 := 0;
    tiles.wenable1 := 0;

    // Setup the reading and writing of the tiles16x16
    tiles16x16.addr0 :=  tilemapentry(tiles.rdata0).tilenumber * 16 + yintm;
    tiles16x16.wenable0 := 0;
    tiles16x16.wenable1 := 1;

    // Default to transparent
    tilemap_display := pix_active && (( tmpixel ) || ( ~tilemapentry(tiles.rdata0).alpha ));

    // Default to 0,0 and transparent
    tiles.addr1 = 0; tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };

    while(1) {
        // Render the tilemap
        if( tilemap_display ) {
            // Determine if background or foreground
            pix_red = tmpixel ? tiles.rdata0[9,2] : tiles.rdata0[15,2];
            pix_green = tmpixel ? tiles.rdata0[7,2] : tiles.rdata0[13,2];
            pix_blue = tmpixel ?  tiles.rdata0[5,2] : tiles.rdata0[11,2];
        }

        // Update tiles
        if( tile_writer_write ) {
            tiles16x16.addr1 = tile_writer_tile * 16 + tile_writer_line;
            tiles16x16.wdata1 = tile_writer_bitmap;
        }

        // Write character to the tilemap
        switch( tm_write ) {
            case 1: {
                tiles.addr1 = tm_x + tm_y * 42;
                tiles.wdata1 = { tm_background, tm_foreground, tm_character };
                tiles.wenable1 = 1;
            }
        }

        switch( tm_active ) {
            case 0: {
                // Perform Scrolling/Wrapping
                switch( tm_scrollwrap ) {
                    // LEFT
                    case 1: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 2: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 41;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 3: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 21;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 4: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 61;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }
                    // LEFT
                    case 5: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 6: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 41;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 7: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 21;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 8: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 61;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // CLEAR
                    case 9: {
                        tm_active = 81;
                    }
                }
            }

            // SCROLL/WRAP LEFT
            case 1: {
                y_cursor = 0;
                y_cursor_addr = 0;

                tm_active = 2;
            }
            case 2: {
                // New row
                x_cursor = 0;
                tiles.addr1 = y_cursor_addr;

                tm_active = 3;
            }
            case 3: {
                new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles.rdata1;

                tm_active = 4;
            }
            case 4: {
                tiles.addr1 = ( x_cursor + 1 ) + y_cursor_addr;

                tm_active = 5;
            }
            case 5: {
                scroll_tile = tiles.rdata1;

                tm_active = 6;
            }
            case 6: {
                tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                tiles.wdata1 = scroll_tile;
                tiles.wenable1 = 1;

                tm_active = 7;
            }
            case 7: {
                x_cursor = x_cursor + 1;

                tm_active = 8;
            }
            case 8: {
                tm_active = ( x_cursor < 41 ) ? 4 : 9;
            }
            case 9: {
                tiles.addr1 = ( 41 ) + y_cursor_addr;
                tiles.wdata1 = new_tile;
                tiles.wenable1 = 1;

                y_cursor = y_cursor + 1;
                y_cursor_addr = y_cursor_addr + 42;

                tm_active = 10;
            }
            case 10: {
                tm_active = ( y_cursor < 32 ) ? 2 : 11;
            }
            case 11: {
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP RIGHT
            case 21: {
                y_cursor = 0;
                y_cursor_addr = 0;

                tm_active = 22;
            }
            case 22: {
                // New row
                x_cursor = 41;
                tiles.addr1 = 41 + y_cursor_addr;

                tm_active = 23;
            }
            case 23: {
                new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles.rdata1;

                tm_active = 24;
            }
            case 24: {
                tiles.addr1 = ( x_cursor - 1 ) + y_cursor_addr;

                tm_active = 25;
            }
            case 25: {
                scroll_tile = tiles.rdata1;

                tm_active = 26;
            }
            case 26: {
                tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                tiles.wdata1 = scroll_tile;
                tiles.wenable1 = 1;

                tm_active = 27;
            }
            case 27: {
                x_cursor = x_cursor - 1;

                tm_active = 28;
            }
            case 28: {
                tm_active = ( x_cursor > 0 ) ? 24 : 29;
            }

            case 29: {
                tiles.addr1 = y_cursor_addr;
                tiles.wdata1 = new_tile;
                tiles.wenable1 = 1;

                y_cursor = y_cursor + 1;
                y_cursor_addr = y_cursor_addr + 42;

                tm_active = 30;
            }
            case 30: {
                tm_active = ( y_cursor < 32 ) ? 32 : 31;
            }

            case 31: {
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP UP
            case 41: {
                x_cursor = 0;

                tm_active = 42;
            }
            case 42: {
                // New Column
                y_cursor = 0;
                y_cursor_addr = 0;
                tiles.addr1 = x_cursor;

                tm_active = 43;
            }
            case 43: {
                new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles.rdata1;

                tm_active = 44;
            }
            case 44: {
                tiles.addr1 = x_cursor + y_cursor_addr + 42;

                tm_active = 45;
            }
            case 45: {
                scroll_tile = tiles.rdata1;

                tm_active = 46;
            }
            case 46: {
                tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                tiles.wdata1 = scroll_tile;
                tiles.wenable1 = 1;

                tm_active = 47;
            }
            case 47: {
                y_cursor = y_cursor + 1;
                y_cursor_addr = y_cursor_addr + 42;

                tm_active = 48;
            }
            case 48: {
                tm_active = ( y_cursor < 31 ) ? 44 : 49;
            }
            case 49: {
                tiles.addr1 = x_cursor + 1302;
                tiles.wdata1 = new_tile;
                tiles.wenable1 = 1;

                x_cursor = x_cursor + 1;

                tm_active = 50;
            }
            case 50: {
                tm_active = ( x_cursor < 42 ) ? 42 : 51;
            }
            case 51: {
                tm_offset_y = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP DOWN
            case 61: {
                x_cursor = 0;

                tm_active = 62;
            }
            case 62: {
                // New Column
                y_cursor = 31;
                y_cursor_addr = 1302;
                tiles.addr1 = x_cursor;

                tm_active = 63;
            }
            case 63: {
                new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles.rdata1;

                tm_active = 64;
            }
            case 64: {
                tiles.addr1 = x_cursor + y_cursor_addr - 42;

                tm_active = 65;
            }
            case 65: {
                scroll_tile = tiles.rdata1;

                tm_active = 66;
            }
            case 66: {
                tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                tiles.wdata1 = scroll_tile;
                tiles.wenable1 = 1;

                tm_active = 67;
            }
            case 67: {
                y_cursor = y_cursor - 1;
                y_cursor_addr = y_cursor_addr - 42;

                tm_active = 68;
            }
            case 68: {
                tm_active = ( y_cursor > 0 ) ? 64 : 69;
            }
            case 69: {
                tiles.addr1 = x_cursor;
                tiles.wdata1 = new_tile;
                tiles.wenable1 = 1;

                x_cursor = x_cursor + 1;

                tm_active = 70;
            }
            case 70: {
                tm_active = ( x_cursor < 42 ) ? 62 : 71;
            }
            case 71: {
                tm_offset_y = 0;
                tm_active = 0;
            }

            // CLEAR
            case 81: {
                tmcsaddr = 0;
                tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };

                tm_active = 82;
            }
            case 82: {
                tiles.addr1 = tmcsaddr;
                tiles.wenable1 = 1;
                tmcsaddr = tmcsaddr + 1;
                tm_active = 83;
            }
            case 83: {
                tm_active = ( tmcsaddr < 1344 ) ? 82: 84;
            }
            case 84: {
                tm_offset_x = 0;
                tm_offset_y = 0;
                tm_active = 0;
            }
        }
    }
}

// Runs at 50MHz
algorithm apu(
    // Waveform selected 0 = square, 1 = sawtooth, 2 = triangle, 3 = sine wave, 4 = noise
    input   uint3   waveform,
    // Note selected 0 = silence, 1 - x = Deep C through to Double High D (gives 64 distint notes)
    input   uint6   note,

    // Duration in ms, 1000 = 1 second,
    input   uint16  duration,
    output! uint1   audio_active,

    // Activate the APU (select the channel, 1, 2 or 3(?) )
    input   uint2   apu_write,

    output! uint4   audio_output,

    input uint16 staticGenerator
) <autorun> {
    // 32 step points per waveform
    brom uint4 waveformtable_1[] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,

        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6
    };
    brom uint4 waveformtable_2[] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,

        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6
    };

    // Calculated as 25MHz / note frequency / 32 to give 32 step points per note
    brom uint16 frequencytable_1[64] = {
        0,
        47778, 45097, 42566, 40177, 37922, 35793, 33784, 31888, 30098, 28409, 26815, 25310,     // 1 = C 2 or Deep C
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 13 = C 3
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 25 = C 4 or Middle C
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 37 = C 5 or Tenor C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 49 = C 6 or Soprano C
        1493, 1409, 1330                                                                        // 61 = C 7 or Double High C
    };
    brom uint16 frequencytable_2[64] = {
        0,
        47778, 45097, 42566, 40177, 37922, 35793, 33784, 31888, 30098, 28409, 26815, 25310,     // 1 = C 2 or Deep C
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 13 = C 3
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 25 = C 4 or Middle C
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 37 = C 5 or Tenor C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 49 = C 6 or Soprano C
        1493, 1409, 1330                                                                        // 61 = C 7 or Double High C
    };

    uint3   waveform_1 = uninitialized;
    uint6   note_1 = uninitialized;
    uint5   point_1 = uninitialized;
    uint16  counter50mhz_1 = uninitialized;
    uint16  counter1khz_1 = uninitialized;
    uint16  milliseconds_1 = uninitialized;
    uint3   waveform_2 = uninitialized;
    uint6   note_2 = uninitialized;
    uint5   point_2 = uninitialized;
    uint16  counter50mhz_2 = uninitialized;
    uint16  counter1khz_2 = uninitialized;
    uint16  milliseconds_2 = uninitialized;

    uint16  duration_1 = uninitialized;
    uint16  duration_2 = uninitialized;

    waveformtable_1.addr := waveform_1 * 32 + point_1;
    waveformtable_2.addr := waveform_2 * 32 + point_2;
    frequencytable_1.addr := note_1;
    frequencytable_2.addr := note_2;

    audio_active := ( duration_1 > 0) || ( duration_2 > 0 );

    always {
        if( ( duration_1 != 0 ) && ( counter50mhz_1 == 0 ) ) {
            audio_output = ( waveform_1 == 4 ) ? staticGenerator : waveformtable_1.rdata;
        }
        if( ( duration_2 != 0 ) && ( counter50mhz_2 == 0 ) ) {
            audio_output = ( waveform_2 == 4 ) ? staticGenerator : waveformtable_2.rdata;
        }
    }

    while(1) {
        switch( apu_write) {
            case 1: {
                // Latch the selected note, waveform and duration
                waveform_1 = waveform;
                note_1 = note;
                duration_1 = duration;
                milliseconds_1 = 0;
                point_1 = 0;
                counter50mhz_1 = 0;
                counter1khz_1 = 25000;
            }
            case 2: {
                // Latch the selected note, waveform and duration
                waveform_2 = waveform;
                note_2 = note;
                duration_2 = duration;
                milliseconds_2 = 0;
                point_2 = 0;
                counter50mhz_2 = 0;
                counter1khz_2 = 25000;
            }
            default: {
                if( duration_1 != 0 ) {
                    counter50mhz_1 = ( counter50mhz_1 != 0 ) ? counter50mhz_1 - 1 : frequencytable_1.rdata;
                    point_1 = ( counter50mhz_1 != 0 ) ? point_1 : point_1 + 1;
                    counter1khz_1 = ( counter1khz_1 != 0 ) ? counter1khz_1 - 1 : 50000;
                    duration_1 = ( counter1khz_1 != 0 ) ? duration_1 : duration_1 - 1;
                }
                if( duration_2 != 0 ) {
                    counter50mhz_2 = ( counter50mhz_2 != 0 ) ? counter50mhz_2 - 1 : frequencytable_2.rdata;
                    point_2 = ( counter50mhz_2 != 0 ) ? point_2 : point_2 + 1;
                    counter1khz_2 = ( counter1khz_2 != 0 ) ? counter1khz_2 - 1 : 50000;
                    duration_2 = ( counter1khz_2 != 0 ) ? duration_2 : duration_2 - 1;
                }
            }
        }
   }
}

// Hardware Accelerated Multiplication and Division
// UNSIGNED / SIGNED 32 by 32 bit division giving 32 bit remainder and quotient

algorithm divideremainder (
    input   uint32  dividend,
    input   uint32  divisor,
    input   uint1   dosigned,

    input   uint1   start,
    output  uint1   active,

    output  uint32  quotient,
    output  uint32  remainder
) <autorun> {
    uint32  dividend_copy = uninitialized;
    uint32  divisor_copy = uninitialized;

    uint1   resultsign = uninitialized;
    uint6   bit = uninitialized;

    active = 0;

    while(1) {
        if( start ) {
            active = 1;
            bit = 32;

            if( divisor == 0 ) {
                // DIVISON by ZERO
                quotient = 32hffffffff;
                remainder = dividend;
                active = 0;
            } else {
                quotient = 0;
                remainder = 0;

                dividend_copy = ( dosigned == 0 ) ? dividend : ( dividend[31,1] ? -dividend : dividend );
                divisor_copy = ( dosigned == 0 ) ? divisor : ( divisor[31,1] ? -divisor : divisor );
                resultsign = ( dosigned == 0 ) ? 0 : dividend[31,1] != divisor[31,1];

                ++:

                while( bit != 0 ) {
                    if( __unsigned( { remainder[0,31], dividend_copy[bit - 1,1] } ) >= __unsigned(divisor_copy) ) {
                        remainder = { remainder[0,31], dividend_copy[bit - 1,1] } - divisor_copy;
                        quotient[bit - 1,1] = 1;
                    } else {
                        remainder = { remainder[0,31], dividend_copy[bit - 1,1] };
                    }
                    bit = bit - 1;
                }

                ++:

                quotient = resultsign ? -quotient : quotient;
                active = 0;
            }
        }
    }
}

// UNSIGNED / SIGNED 32 by 32 bit multiplication giving 64 bit product
// DSP BLOCKS

algorithm multiplicationDSP (
    input   uint32  factor_1,
    input   uint32  factor_2,
    input   uint2   dosigned,

    input   uint1   start,
    output  uint1   active,

    output  uint64  product
) <autorun> {
    uint32  factor_1_copy := ( dosigned == 0 ) ? factor_1 : ( ( factor_1[31,1] ) ? -factor_1 : factor_1 );
    uint32  factor_2_copy := ( dosigned != 1 ) ? factor_2 : ( ( factor_2[31,1] ) ? -factor_2 : factor_2 );

    uint18  A := { 2b0, factor_1_copy[16,16] };
    uint18  B := { 2b0, factor_1_copy[0,16] };
    uint18  C := { 2b0, factor_2_copy[16,16] };
    uint18  D := { 2b0, factor_2_copy[0,16] };

    uint1   resultsign := ( dosigned == 0 ) ? 0 : ( ( dosigned == 1 ) ? ( factor_1[31,1] != factor_2[31,1] ) : factor_1[31,1] );

    while(1) {
        if( start ) {
            active = 1;
            ++:
            product = D*B + { D*A, 16b0 } + { C*B, 16b0 } + { C*A, 32b0 };
            ++:
            product = resultsign ? -product : product;
            active = 0;
        }
    }
}

// 7 bit colour either ALPHA (background or lower layer) or red, green, blue { Arrggbb }
bitfield colour7 {
    uint1   alpha,
    uint2   red,
    uint2   green,
    uint2   blue
}

// 6 bit colour red, green, blue { rrggbb }
bitfield colour6 {
    uint2   red,
    uint2   green,
    uint2   blue
}

// Simplify access to high/low word
bitfield words {
    uint16  hword,
    uint16  lword
}

// Simplify access to high/low byte
bitfield bytes {
    uint8   byte1,
    uint8   byte0
}

// Simplify access to 4bit nibbles (used to extract shift left/right amount)
bitfield nibbles {
    uint4   nibble3,
    uint4   nibble2,
    uint4   nibble1,
    uint4   nibble0
}

algorithm memmap_io (
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // VGA/HDMI
    output! uint8   video_r,
    output! uint8   video_g,
    output! uint8   video_b,
    input   uint1   vblank,
    input   uint1   pix_active,
    input   uint10  pix_x,
    input   uint10  pix_y,

    // CLOCKS
    input   uint1   clock_50mhz,
    input   uint1   video_clock,
    input   uint1   video_reset,

    // Memory access
    input   uint16  memoryAddress,
    input   uint16  writeData,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    output! uint16  readData,
) <autorun> {
    // 1hz timers (p1hz used for systemClock, timer1hz for user purposes)
    uint16 systemClock = uninitialized;
    pulse1hz p1hz <@clock_50mhz> (
        counter1hz :> systemClock,
    );
    pulse1hz timer1hz <@clock_50mhz> ( );

    // 1khz timers (sleepTimer used for sleep command, timer1khz for user purposes)
    pulse1khz sleepTimer <@clock_50mhz> ( );
    pulse1khz timer1khz <@clock_50mhz> ( );

    // RNG random number generator
    uint16 staticGenerator = 0;
    random rng <@clock_50mhz> (
        g_noise_out :> staticGenerator
    );

    // UART tx and rx
    // UART written in Silice by https://github.com/sylefeb/Silice
    uart_out uo;
    uart_sender usend (
        io      <:> uo,
        uart_tx :>  uart_tx
    );
    uart_in ui;
    uart_receiver urecv (
        io      <:> ui,
        uart_rx <:  uart_rx
    );

    // CREATE DISPLAY LAYERS
    // BACKGROUND
    uint2   background_r = uninitialized;
    uint2   background_g = uninitialized;
    uint2   background_b = uninitialized;
    background background_generator <@video_clock,!video_reset>  (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> background_r,
        pix_green  :> background_g,
        pix_blue   :> background_b,
        staticGenerator <: staticGenerator
    );

    // TILEMAP
    uint2   tilemap_r = uninitialized;
    uint2   tilemap_g = uninitialized;
    uint2   tilemap_b = uninitialized;
    uint1   tilemap_display = uninitialized;

    tilemap tile_map <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> tilemap_r,
        pix_green  :> tilemap_g,
        pix_blue   :> tilemap_b,
        tilemap_display :> tilemap_display,
    );

    // Bitmap Window
    uint2   bitmap_r = uninitialized;
    uint2   bitmap_g = uninitialized;
    uint2   bitmap_b = uninitialized;
    // From GPU to set a pixel
    uint1   bitmap_display = uninitialized;
    int11   bitmap_x_write = uninitialized;
    int11   bitmap_y_write = uninitialized;
    uint7   bitmap_colour_write = uninitialized;
    uint2   bitmap_write = uninitialized;

    bitmap bitmap_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> bitmap_r,
        pix_green  :> bitmap_g,
        pix_blue   :> bitmap_b,
        bitmap_display :> bitmap_display,
        bitmap_x_write <: bitmap_x_write,
        bitmap_y_write <: bitmap_y_write,
        bitmap_colour_write <: bitmap_colour_write,
        bitmap_write <: bitmap_write
    );

    // Lower Sprite Layer - Between BACKGROUND and BITMAP
    // Upper Sprite Layer - Between BITMAP and CHARACTER MAP
    uint2   lower_sprites_r = uninitialized;
    uint2   lower_sprites_g = uninitialized;
    uint2   lower_sprites_b = uninitialized;
    uint1   lower_sprites_display = uninitialized;
    uint2   upper_sprites_r = uninitialized;
    uint2   upper_sprites_g = uninitialized;
    uint2   upper_sprites_b = uninitialized;
    uint1   upper_sprites_display = uninitialized;

    sprite_layer lower_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> lower_sprites_r,
        pix_green  :> lower_sprites_g,
        pix_blue   :> lower_sprites_b,
        sprite_layer_display :> lower_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: upper_sprites_display
    );

    sprite_layer upper_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> upper_sprites_r,
        pix_green  :> upper_sprites_g,
        pix_blue   :> upper_sprites_b,
        sprite_layer_display :> upper_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: lower_sprites_display
    );

    // Character Map Window
    uint2   character_map_r = uninitialized;
    uint2   character_map_g = uninitialized;
    uint2   character_map_b = uninitialized;
    uint1   character_map_display = uninitialized;

    character_map character_map_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> character_map_r,
        pix_green  :> character_map_g,
        pix_blue   :> character_map_b,
        character_map_display :> character_map_display
    );

    // Terminal window at the bottom of the screen
    uint2   terminal_r = uninitialized;
    uint2   terminal_g = uninitialized;
    uint2   terminal_b = uninitialized;
    uint1   terminal_display = uninitialized;

    terminal terminal_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> terminal_r,
        pix_green  :> terminal_g,
        pix_blue   :> terminal_b,
        terminal_display :> terminal_display,
        timer1hz   <: systemClock
    );

    // Combine the display layers for display
    multiplex_display display <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> video_r,
        pix_green  :> video_g,
        pix_blue   :> video_b,

        background_r <: background_r,
        background_g <: background_g,
        background_b <: background_b,

        tilemap_r <: tilemap_r,
        tilemap_g <: tilemap_g,
        tilemap_b <: tilemap_b,
        tilemap_display <: tilemap_display,

        lower_sprites_r <: lower_sprites_r,
        lower_sprites_g <: lower_sprites_g,
        lower_sprites_b <: lower_sprites_b,
        lower_sprites_display <: lower_sprites_display,

        bitmap_r <: bitmap_r,
        bitmap_g <: bitmap_g,
        bitmap_b <: bitmap_b,
        bitmap_display <: bitmap_display,

        upper_sprites_r <: upper_sprites_r,
        upper_sprites_g <: upper_sprites_g,
        upper_sprites_b <: upper_sprites_b,
        upper_sprites_display <: upper_sprites_display,

        character_map_r <: character_map_r,
        character_map_g <: character_map_g,
        character_map_b <: character_map_b,
        character_map_display <: character_map_display,

        terminal_r <: terminal_r,
        terminal_g <: terminal_g,
        terminal_b <: terminal_b,
        terminal_display <: terminal_display
    );

    // Left and Right audio channels
    // Sync'd with video_clock
    apu apu_processor_L <@clock_50mhz> (
        staticGenerator <: staticGenerator,
        audio_output :> audio_l
    );
    apu apu_processor_R <@clock_50mhz> (
        staticGenerator <: staticGenerator,
        audio_output :> audio_r
    );

    gpu gpu_processor <@video_clock,!video_reset> (
        bitmap_x_write :> bitmap_x_write,
        bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write,
        bitmap_write :> bitmap_write,
    );

    // UART input FIFO (4096 character) as dualport bram (code from @sylefeb)
    dualport_bram uint8 uartInBuffer[4096] = uninitialized;
    uint13  uartInBufferNext = 0;
    uint13  uartInBufferTop = 0;

    // UART output FIFO (16 character) as dualport bram (code from @sylefeb)
    dualport_bram uint8 uartOutBuffer[256] = uninitialized;
    uint8   uartOutBufferNext = 0;
    uint8   uartOutBufferTop = 0;
    uint8   newuartOutBufferTop = 0;

    // Co-Processor reset counter
    uint2   coProReset = 0;

    // register buttons
    uint7 reg_btns = 0;
    reg_btns ::= btns;

    // UART Buffers
    uartInBuffer.wenable0  := 0;  // always read  on port 0
    uartInBuffer.wenable1  := 1;  // always write on port 1
    uartInBuffer.addr0     := uartInBufferNext; // FIFO reads on next
    uartInBuffer.addr1     := uartInBufferTop;  // FIFO writes on top

    uartOutBuffer.wenable0 := 0; // always read  on port 0
    uartOutBuffer.wenable1 := 1; // always write on port 1
    uartOutBuffer.addr0    := uartOutBufferNext; // FIFO reads on next
    uartOutBuffer.addr1    := uartOutBufferTop;  // FIFO writes on top

    // Setup the UART
    uo.data_in_ready := 0; // maintain low

    // RESET Timer Co-Processor Controls
    p1hz.resetCounter := 0;
    sleepTimer.resetCounter := 0;
    timer1hz.resetCounter := 0;
    timer1khz.resetCounter := 0;
    rng.resetRandom := 0;

    // RESET Co-Processor Controls
    background_generator.background_write := 0;
    tile_map.tile_writer_write := 0;
    tile_map.tm_write := 0;
    tile_map.tm_scrollwrap := 0;
    lower_sprites.sprite_layer_write := 0;
    lower_sprites.sprite_writer_active := 0;
    bitmap_window.bitmap_write_offset := 0;
    gpu_processor.gpu_write := 0;
    gpu_processor.draw_vector := 0;
    gpu_processor.dl_start := 0;
    gpu_processor.blit1_writer_active := 0;
    gpu_processor.vertices_writer_write := 0;
    gpu_processor.dl_writer_write := 0;
    upper_sprites.sprite_layer_write := 0;
    upper_sprites.sprite_writer_active := 0;
    character_map_window.tpu_write := 0;
    terminal_window.terminal_write := 0;
    apu_processor_L.apu_write := 0;
    apu_processor_R.apu_write := 0;

    // UART input and output buffering
    always {
        // READ from UART if character available and store
        if( ui.data_out_ready ) {
            // writes at uartInBufferTop (code from @sylefeb)
            uartInBuffer.wdata1  = ui.data_out;
            uartInBufferTop      = uartInBufferTop + 1;
        }
        // WRITE to UART if characters in buffer and UART is ready
        if( (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy ) ) {
            // reads at uartOutBufferNext (code from @sylefeb)
            uo.data_in      = uartOutBuffer.rdata0;
            uo.data_in_ready     = 1;
            uartOutBufferNext = uartOutBufferNext + 1;
        }
    }

    // Setup the terminal
    terminal_window.showterminal = 1;
    terminal_window.showcursor = 1;

    while(1) {
        // Update UART output buffer top if character has been put into buffer
        uartOutBufferTop = newuartOutBufferTop;

        // READ IO Memory
        if( memoryRead ) {
            switch( memoryAddress ) {
                // UART, LEDS, BUTTONS and CLOCK
                case 16h8000: { readData = { 8b0, uartInBuffer.rdata0 }; uartInBufferNext = uartInBufferNext + 1; }
                case 16h8004: { readData = { 14b0, ( uartOutBufferTop + 1 == uartOutBufferNext ), ( uartInBufferNext != uartInBufferTop )}; }
                case 16h8008: { readData = { 9b0, reg_btns[0,7] }; }
                case 16h800c: { readData = leds; }
                case 16h8010: { readData = systemClock; }

                // BACKGROUND

                // TILE MAP
                case 16h8230: { readData = tile_map.tm_lastaction; }
                case 16h8234: { readData = tile_map.tm_active; }

                // LOWER SPRITE LAYER
                case 16h8304: { readData = lower_sprites.sprite_read_active; }
                case 16h8308: { readData = lower_sprites.sprite_read_tile; }
                case 16h830c: { readData = lower_sprites.sprite_read_colour; }
                case 16h8310: { readData = { {5{lower_sprites.sprite_read_x[10,1]}}, lower_sprites.sprite_read_x }; }
                case 16h8314: { readData = { {5{lower_sprites.sprite_read_y[10,1]}}, lower_sprites.sprite_read_y }; }
                case 16h8318: { readData = lower_sprites.sprite_read_double; }

                case 16h8330: { readData = lower_sprites.collision_0; }
                case 16h8332: { readData = lower_sprites.collision_1; }
                case 16h8334: { readData = lower_sprites.collision_2; }
                case 16h8336: { readData = lower_sprites.collision_3; }
                case 16h8338: { readData = lower_sprites.collision_4; }
                case 16h833a: { readData = lower_sprites.collision_5; }
                case 16h833c: { readData = lower_sprites.collision_6; }
                case 16h833e: { readData = lower_sprites.collision_7; }
                case 16h8340: { readData = lower_sprites.collision_8; }
                case 16h8342: { readData = lower_sprites.collision_9; }
                case 16h8344: { readData = lower_sprites.collision_10; }
                case 16h8346: { readData = lower_sprites.collision_11; }
                case 16h8348: { readData = lower_sprites.collision_12; }

                // GPU and BITMAP
                case 16h841c: { readData = gpu_processor.gpu_active; }
                case 16h8448: { readData = gpu_processor.vector_block_active; }
                case 16h8458: { readData = gpu_processor.display_list_active; }
                case 16h84b0: { readData = bitmap_window.bitmap_colour_read; }

                // UPPER SPRITE LAYER
                case 16h8504: { readData = upper_sprites.sprite_read_active; }
                case 16h8508: { readData = upper_sprites.sprite_read_tile; }
                case 16h850c: { readData = upper_sprites.sprite_read_colour; }
                case 16h8510: { readData = { {5{upper_sprites.sprite_read_x[10,1]}}, upper_sprites.sprite_read_x }; }
                case 16h8514: { readData = { {5{upper_sprites.sprite_read_y[10,1]}}, upper_sprites.sprite_read_y }; }
                case 16h8518: { readData = upper_sprites.sprite_read_double; }

                case 16h8530: { readData = upper_sprites.collision_0; }
                case 16h8532: { readData = upper_sprites.collision_1; }
                case 16h8534: { readData = upper_sprites.collision_2; }
                case 16h8536: { readData = upper_sprites.collision_3; }
                case 16h8538: { readData = upper_sprites.collision_4; }
                case 16h853a: { readData = upper_sprites.collision_5; }
                case 16h853c: { readData = upper_sprites.collision_6; }
                case 16h853e: { readData = upper_sprites.collision_7; }
                case 16h8540: { readData = upper_sprites.collision_8; }
                case 16h8542: { readData = upper_sprites.collision_9; }
                case 16h8544: { readData = upper_sprites.collision_10; }
                case 16h8546: { readData = upper_sprites.collision_11; }
                case 16h8548: { readData = upper_sprites.collision_12; }

                // CHARACTER MAP
                case 16h8614: { readData = character_map_window.tpu_active; }

                // TERMINAL
                case 16h8700: { readData = terminal_window.terminal_active; }

                // AUDIO
                case 16h8808: { readData = apu_processor_L.audio_active; }
                case 16h8818: { readData = apu_processor_R.audio_active; }

                // TIMERS and RNG
                case 16h8900: { readData = staticGenerator; }
                case 16h8910: { readData = timer1hz.counter1hz; }
                case 16h8920: { readData = timer1khz.counter1khz; }
                case 16h8930: { readData = sleepTimer.counter1khz; }

                // VBLANK
                case 16h8ff0: { readData = vblank; }
            }
        }

        // WRITE IO Memory
        if( memoryWrite ) {
            switch( memoryAddress ) {
                // UART, LEDS
                case 16h8000: { uartOutBuffer.wdata1 = writeData[0,8]; newuartOutBufferTop = uartOutBufferTop + 1; }
                case 16h800c: { leds = writeData; }

                // BACKGROUND
                case 16h8100: { background_generator.backgroundcolour = writeData; background_generator.background_write = 1; }
                case 16h8104: { background_generator.backgroundcolour_alt = writeData; background_generator.background_write = 2; }
                case 16h8108: { background_generator.backgroundcolour_mode = writeData; background_generator.background_write = 3; }

                // TILE MAP
                case 16h8200: { tile_map.tm_x = writeData; }
                case 16h8204: { tile_map.tm_y = writeData; }
                case 16h8208: { tile_map.tm_character = writeData; }
                case 16h820c: { tile_map.tm_background = writeData; }
                case 16h8210: { tile_map.tm_foreground = writeData; }
                case 16h8214: { tile_map.tm_write = 1; }

                case 16h8220: { tile_map.tile_writer_tile = writeData; }
                case 16h8224: { tile_map.tile_writer_line = writeData; }
                case 16h8228: { tile_map.tile_writer_bitmap = writeData; tile_map.tile_writer_write = 1; }

                case 16h8230: { tile_map.tm_scrollwrap = writeData; }

                // LOWER SPRITE LAYER
                case 16h8300: { lower_sprites.sprite_set_number = writeData; }
                case 16h8304: { lower_sprites.sprite_set_active = writeData; lower_sprites.sprite_layer_write = 1; }
                case 16h8308: { lower_sprites.sprite_set_tile = writeData; lower_sprites.sprite_layer_write = 2; }
                case 16h830c: { lower_sprites.sprite_set_colour = writeData; lower_sprites.sprite_layer_write = 3; }
                case 16h8310: { lower_sprites.sprite_set_x = writeData; lower_sprites.sprite_layer_write = 4; }
                case 16h8314: { lower_sprites.sprite_set_y = writeData; lower_sprites.sprite_layer_write = 5; }
                case 16h8318: { lower_sprites.sprite_set_double = writeData; lower_sprites.sprite_layer_write = 6; }
                case 16h831c: { lower_sprites.sprite_update = writeData; lower_sprites.sprite_layer_write = 10; }

                case 16h8320: { lower_sprites.sprite_writer_sprite = writeData; }
                case 16h8324: { lower_sprites.sprite_writer_line = writeData; }
                case 16h8328: { lower_sprites.sprite_writer_bitmap = writeData; lower_sprites.sprite_writer_active = 1; }

                // GPU and BITMAP
                case 16h8400: { gpu_processor.gpu_x = writeData; }
                case 16h8404: { gpu_processor.gpu_y = writeData; }
                case 16h8408: { gpu_processor.gpu_colour = writeData; }
                case 16h840c: { gpu_processor.gpu_param0 = writeData; }
                case 16h8410: { gpu_processor.gpu_param1 = writeData; }
                case 16h8414: { gpu_processor.gpu_param2 = writeData; }
                case 16h8418: { gpu_processor.gpu_param3 = writeData; }
                case 16h841c: { gpu_processor.gpu_write = writeData; }

                case 16h8420: { gpu_processor.vector_block_number = writeData; }
                case 16h8424: { gpu_processor.vector_block_colour = writeData; }
                case 16h8428: { gpu_processor.vector_block_xc = writeData; }
                case 16h842c: { gpu_processor.vector_block_yc = writeData; }
                case 16h8430: { gpu_processor.draw_vector = 1; }

                case 16h8434: { gpu_processor.vertices_writer_block = writeData; }
                case 16h8438: { gpu_processor.vertices_writer_vertex = writeData; }
                case 16h843c: { gpu_processor.vertices_writer_xdelta = writeData; }
                case 16h8440: { gpu_processor.vertices_writer_ydelta = writeData; }
                case 16h8444: { gpu_processor.vertices_writer_active = writeData; }
                case 16h8448: { gpu_processor.vertices_writer_write = 1; }

                case 16h8450: { gpu_processor.dl_start_entry = writeData; }
                case 16h8454: { gpu_processor.dl_finish_entry = writeData; }
                case 16h8458: { gpu_processor.dl_start = 1; }

                case 16h845c: { gpu_processor.dl_writer_entry_number = writeData; }
                case 16h8460: { gpu_processor.dl_writer_active = writeData; }
                case 16h8464: { gpu_processor.dl_writer_colour = writeData; }
                case 16h8468: { gpu_processor.dl_writer_x = writeData; }
                case 16h846c: { gpu_processor.dl_writer_y = writeData; }
                case 16h8470: { gpu_processor.dl_writer_p0 = writeData; }
                case 16h8474: { gpu_processor.dl_writer_p1 = writeData; }
                case 16h8478: { gpu_processor.dl_writer_p2 = writeData; }
                case 16h847c: { gpu_processor.dl_writer_p3 = writeData; }
                case 16h8480: { gpu_processor.dl_writer_write = 1; }

                case 16h8490: { gpu_processor.blit1_writer_tile = writeData; }
                case 16h8494: { gpu_processor.blit1_writer_line = writeData; }
                case 16h8498: { gpu_processor.blit1_writer_bitmap = writeData;  gpu_processor.blit1_writer_active = 1; }

                case 16h84a0: { bitmap_window.bitmap_write_offset = writeData; }

                case 16h84b0: { bitmap_window.bitmap_x_read = writeData; }
                case 16h84b4: { bitmap_window.bitmap_y_read = writeData; }

                // UPPER SPRITE LAYER
                case 16h8500: { upper_sprites.sprite_set_number = writeData; }
                case 16h8504: { upper_sprites.sprite_set_active = writeData; upper_sprites.sprite_layer_write = 1; }
                case 16h8508: { upper_sprites.sprite_set_tile = writeData; upper_sprites.sprite_layer_write = 2; }
                case 16h850c: { upper_sprites.sprite_set_colour = writeData; upper_sprites.sprite_layer_write = 3; }
                case 16h8510: { upper_sprites.sprite_set_x = writeData; upper_sprites.sprite_layer_write = 4; }
                case 16h8514: { upper_sprites.sprite_set_y = writeData; upper_sprites.sprite_layer_write = 5; }
                case 16h8518: { upper_sprites.sprite_set_double = writeData; upper_sprites.sprite_layer_write = 6; }
                case 16h851c: { upper_sprites.sprite_update = writeData; upper_sprites.sprite_layer_write = 10; }

                case 16h8520: { upper_sprites.sprite_writer_sprite = writeData; }
                case 16h8524: { upper_sprites.sprite_writer_line = writeData; }
                case 16h8528: { upper_sprites.sprite_writer_bitmap = writeData; upper_sprites.sprite_writer_active = 1; }

                // CHARACTER MAP
                case 16h8600: { character_map_window.tpu_x = writeData; }
                case 16h8604: { character_map_window.tpu_y = writeData; }
                case 16h8608: { character_map_window.tpu_character = writeData; }
                case 16h860c: { character_map_window.tpu_background = writeData; }
                case 16h8610: { character_map_window.tpu_foreground = writeData; }
                case 16h8614: { character_map_window.tpu_write = writeData; }

                // TERMINAL
                case 16h8700: { terminal_window.terminal_character = writeData; terminal_window.terminal_write = 1; }
                case 16h8704: { terminal_window.showterminal = writeData; }

                // AUDIO
                case 16h8800: { apu_processor_L.waveform = writeData; }
                case 16h8804: { apu_processor_L.note = writeData; }
                case 16h8808: { apu_processor_L.duration = writeData; }
                case 16h880c: { apu_processor_L.apu_write = writeData; }
                case 16h8810: { apu_processor_R.waveform = writeData; }
                case 16h8814: { apu_processor_R.note = writeData; }
                case 16h8818: { apu_processor_R.duration = writeData; }
                case 16h881c: { apu_processor_R.apu_write = writeData; }

                // TIMERS and RNG
                case 16h8900: { rng.resetRandom = 1; }
                case 16h8910: { timer1hz.resetCounter = 1; }
                case 16h8920: { timer1khz.resetCount = writeData; timer1khz.resetCounter = 1; }
                case 16h8930: { sleepTimer.resetCount = writeData; sleepTimer.resetCounter = 1; }

            }
        }
    } // while(1)
}


import('../common/ulx3s_clk_50_25.v')
import('../common/reset_conditioner.v')

// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// Risc-V RV32IM ( user instructions with no-interrupts / traps / exceptions )

// RISC-V INSTRUCTION BITFIELDS
bitfield    Btype {
    uint1   immediate_bits_12,
    uint6   immediate_bits_10_5,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint4   immediate_bits_4_1,
    uint1   immediate_bits_11,
    uint7   opcode
}

bitfield    Itype {
    uint12  immediate,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    ItypeSHIFT {
    uint7   function7,
    uint5   shiftCount,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    Jtype {
    uint1   immediate_bits_20,
    uint10  immediate_bits_10_1,
    uint1   immediate_bits_11,
    uint8   immediate_bits_19_12,
    uint5   destReg,
    uint7   opcode
}

bitfield    Rtype {
    uint7   function7,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opCode
}

bitfield Stype {
    uint7  immediate_bits_11_5,
    uint5  sourceReg2,
    uint5  sourceReg1,
    uint3  function3,
    uint5  immediate_bits_4_0,
    uint7  opcode
}

bitfield Utype {
    uint20 immediate_bits_31_12,
    uint5  destReg,
    uint7  opCode
}

algorithm main(
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // HDMI OUTPUT
    output  uint4   gpdi_dp,
    output  uint4   gpdi_dn,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r

) {
    // VGA/HDMI Display
    uint1   video_reset = uninitialized;
    uint1   video_clock = uninitialized;
    uint1   pll_lock = uninitialized;

    // Generate the 100MHz SDRAM and 25MHz VIDEO clocks
    uint1 clock_50mhz = uninitialized;
    ulx3s_clk_50_25 clk_gen (
        clkin    <: clock,
        clkout0  :> clock_50mhz,
        clkout1  :> video_clock,
        locked   :> pll_lock
    );

    // Video Reset
    reset_conditioner vga_rstcond (
        rcclk <: video_clock ,
        in  <: reset,
        out :> video_reset
    );

    // Status of the screen, if in range, if in vblank, actual pixel x and y
    uint1   vblank = uninitialized;
    uint1   pix_active = uninitialized;
    uint10  pix_x  = uninitialized;
    uint10  pix_y  = uninitialized;

    // VGA or HDMI driver
    uint8   video_r = uninitialized;
    uint8   video_g = uninitialized;
    uint8   video_b = uninitialized;

    hdmi video<@clock,!reset> (
        vblank  :> vblank,
        active  :> pix_active,
        x       :> pix_x,
        y       :> pix_y,
        gpdi_dp :> gpdi_dp,
        gpdi_dn :> gpdi_dn,
        red     <: video_r,
        green   <: video_g,
        blue    <: video_b
    );

    // RISC-V REGISTERS
    bram int32 registers_1[32] = { 0, pad(0) };
    bram int32 registers_2[32] = { 0, pad(0) };

    // RISC-V PROGRAM COUNTER
    uint32  pc = 0;
    uint32  newPC = uninitialized;
    uint1   takeBranch = uninitialized;

    // RISC-V INSTRUCTION and DECODE
    uint32  instruction = uninitialized;
    uint7   opCode := Utype(instruction).opCode;
    uint3   function3 := Rtype(instruction).function3;
    uint7   function7 := Rtype(instruction).function7;

    // RISC-V SOURCE REGISTER VALUES and IMMEDIATE VALUE and DESTINATION REGISTER ADDRESS
    int32   sourceReg1 := registers_1.rdata;
    int32   sourceReg2 := registers_2.rdata;
    uint32  immediateValue := { {20{instruction[31,1]}}, Itype(instruction).immediate };
    uint5   destReg := Rtype(instruction).destReg;

    // RISC-V ALU RESULTS
    int32   result = uninitialized;
    int32   Uresult := { Utype(instruction).immediate_bits_31_12, 12b0 };
    uint1   writeRegister = uninitialized;

    // RISC-V ADDRESS CALCULATIONS
    int32   jumpAddress := { {12{Jtype(instruction).immediate_bits_20}}, Jtype(instruction).immediate_bits_19_12, Jtype(instruction).immediate_bits_11, Jtype(instruction).immediate_bits_10_1, 1b0 } + pc;
    int32   branchOffset := { {20{Btype(instruction).immediate_bits_12}}, Btype(instruction).immediate_bits_11, Btype(instruction).immediate_bits_10_5, Btype(instruction).immediate_bits_4_1, 1b0 };
    int32   loadAddress := immediateValue + sourceReg1;
    int32   storeAddress := { {20{instruction[31,1]}}, Stype(instruction).immediate_bits_11_5, Stype(instruction).immediate_bits_4_0 } + sourceReg1;

    // Setup Memory Mapped I/O
    memmap_io IO_Map (
        leds :> leds,
        btns <: btns,

        // UART
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,

        // AUDIO
        audio_l :> audio_l,
        audio_r :> audio_r,

        // VGA/HDMI
        video_r :> video_r,
        video_g :> video_g,
        video_b :> video_b,
        vblank <: vblank,
        pix_active <: pix_active,
        pix_x <: pix_x,
        pix_y <: pix_y,

        // CLOCKS
        clock_50mhz <: clock_50mhz,
        video_clock <:video_clock,
        video_reset <: video_reset
    );

    // BRAM and SDRAM Controller
    memorymap memoryController ();

    // MULTIPLICATION and DIVISION units
    divideremainder dividerunit <@clock_50mhz> (
        dividend <: sourceReg1,
        divisor <: sourceReg2
    );
    multiplicationDSP multiplicationuint <@clock_50mhz> (
        factor_1 <: sourceReg1,
        factor_2 <: sourceReg2
    );

    // MULTIPLICATION and DIVISION Start Flags
    dividerunit.start := 0;
    multiplicationuint.start := 0;

    // RAM/IO Read/Write Flags
    memoryController.writeSize := 0;
    memoryController.readSize := 0;
    IO_Map.memoryWrite := 0;
    IO_Map.memoryRead := 0;

    // REGISTER Read/Write Flags
    registers_1.addr := Rtype(instruction).sourceReg1;
    registers_1.wenable := 0;
    registers_2.addr := Rtype(instruction).sourceReg2;
    registers_2.wenable := 0;

    while(1) {
        // RISC-V
        writeRegister = 1;
        takeBranch = 0;
        newPC = pc + 4;

        // FETCH - 32 bit instruction
        memoryController.address = pc;
        memoryController.readSize = 3;
        ++:
        while( memoryController.memoryBusy ) {}
        instruction = memoryController.readData;
        ++:
        ++:

        // DECODE + EXECUTE
        switch( { opCode[6,1], opCode[4,1] } ) {
            case 2b00: {
                // LOAD STORE
                switch( opCode[5,1] ) {
                    case 1b0: {
                        // LOAD execute even if rd == 0 as may be discarding values in a buffer
                        switch( loadAddress[15,1] ) {
                            case 0: {
                                memoryController.address = loadAddress;
                                memoryController.readSize = ( function3 & 3 ) + 1;
                                ++:
                                while( memoryController.memoryBusy ) {}
                                switch( function3 & 3 ) {
                                    case 2b00: { result = function3[2,1] ? { 24b0, memoryController.readData[0,8] } : { {24{memoryController.readData[7,1]}}, memoryController.readData[0,8] }; }
                                    case 2b01: { result =  function3[2,1] ? { 16b0, memoryController.readData[0,16] } : { {16{memoryController.readData[15,1]}}, memoryController.readData[0,16] }; }
                                    case 2b10: { result = memoryController.readData; }
                                }
                            }

                            case 1: {
                                IO_Map.memoryAddress = loadAddress[0,16];
                                IO_Map.memoryRead = 1;
                                switch( function3 & 3 ) {
                                    case 2b00: { result = function3[2,1] ? { 24b0, IO_Map.readData[0,8] } : { {24{IO_Map.readData[7,1]}}, IO_Map.readData[0,8] }; }
                                    case 2b01: { result = function3[2,1] ? { 16b0, IO_Map.readData } : { {16{IO_Map.readData[15,1]}}, IO_Map.readData }; }
                                    case 2b10: { result = IO_Map.readData; }
                                }
                            }
                        }
                    }
                    case 1b1: {
                        // STORE
                        writeRegister = 0;
                        switch( storeAddress[15,1] ) {
                            case 1b0: {
                                memoryController.address = storeAddress;
                                memoryController.writeData = sourceReg2;
                                memoryController.writeSize = ( function3 & 3 ) + 1;
                            }
                            case 1b1: {
                                IO_Map.memoryAddress = storeAddress[0,16];
                                IO_Map.writeData = sourceReg2[0,16];
                                IO_Map.memoryWrite = 1;
                            }
                        }
                    }
                }
            }

            case 2b01: {
                // AUIPC LUI ALUI ALUR
                switch( opCode[2,1] ) {
                    case 1b0: {
                        if( ( opCode[5,1] == 1 ) && ( function7[0,1] == 1 ) ) {
                            // M EXTENSION
                            switch( function3[2,1] ) {
                                case 1b0: {
                                    // MULTIPLICATION
                                    multiplicationuint.dosigned = ( function3[1,1] == 0 ) ? 1 : ( ( function3[0,1] == 0 ) ? 2 : 0 );
                                    multiplicationuint.start = 1;
                                    ++:
                                    while( multiplicationuint.active ) {}
                                    result = ( function3 == 0 ) ? multiplicationuint.product[0,32] : multiplicationuint.product[32,32];
                                }
                                case 1b1: {
                                    // DIVISION / REMAINDER
                                    dividerunit.dosigned = ~function3[0,1];
                                    dividerunit.start = 1;
                                    ++:
                                    while( dividerunit.active ) {}
                                    result = function3[1,1] ? dividerunit.remainder : dividerunit.quotient;
                                }
                            }
                        } else {
                            // I ALU OPERATIONS
                            switch( function3 ) {
                                case 3b000: { result = ( ( opCode[5,1] == 1 ) && ( function7[5,1] == 1 ) ) ? sourceReg1 - sourceReg2 : ( ( opCode[5,1] == 1 ) ? sourceReg1 + sourceReg2 : sourceReg1 + immediateValue ); }
                                case 3b001: { result = sourceReg1 << ( ( opCode[5,1] == 1 ) ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount ); }
                                case 3b010: { result = __signed( sourceReg1 ) < __signed( ( ( opCode[5,1] == 1 ) ? sourceReg2 : immediateValue ) ) ? 32b1 : 32b0; }
                                case 3b011: {
                                    switch( opCode[5,1] ) {
                                        case 1b0: { result = ( immediateValue == 1 ) ? ( ( sourceReg1 == 0 ) ? 32b1 : 32b0 ) : ( __unsigned( sourceReg1 ) < __unsigned( immediateValue ) ? 32b1 : 32b0 ); }
                                        case 1b1: { result = ( Rtype(instruction).sourceReg1 == 0 ) ? ( ( sourceReg2 != 0 ) ? 32b1 : 32b0 ) : ( __unsigned( sourceReg1 ) < __unsigned( sourceReg2 ) ? 32b1 : 32b0 ); }
                                    }
                                }
                                case 3b100: { result = sourceReg1 ^ ( ( opCode[5,1] == 1 ) ? sourceReg2 : immediateValue ); }
                                case 3b101: {
                                    result = ( function7[5,1] == 1 ) ? __signed(sourceReg1) >>> ( ( opCode[5,1] == 1 ) ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount ) :
                                                                        sourceReg1 >> ( ( opCode[5,1] == 1 ) ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );
                                }
                                case 3b110: { result = sourceReg1 | ( ( opCode[5,1] == 1 ) ? sourceReg2 : immediateValue ); }
                                case 3b111: { result = sourceReg1 & ( ( opCode[5,1] == 1 ) ? sourceReg2 : immediateValue ); }
                            }
                        }
                    }
                    case 1b1: {
                        // AUIPC LUI
                        result = ( opCode[5,1] == 0 ) ? Uresult + pc : Uresult;
                    }
                }
            }

            case 2b10: {
                // JUMP BRANCH
                switch( opCode[2,1] ) {
                    case 1b0: {
                        // BRANCH on CONDITION
                        writeRegister = 0;
                        switch( function3 ) {
                            case 3b000: { takeBranch = ( sourceReg1 == sourceReg2 ) ? 1 : 0; }
                            case 3b001: { takeBranch = ( sourceReg1 != sourceReg2 ) ? 1 : 0; }
                            case 3b100: { takeBranch = ( __signed(sourceReg1) < __signed(sourceReg2) ) ? 1 : 0; }
                            case 3b101: { takeBranch = ( __signed(sourceReg1) >= __signed(sourceReg2) )  ? 1 : 0; }
                            case 3b110: { takeBranch = ( __unsigned(sourceReg1) < __unsigned(sourceReg2) ) ? 1 : 0; }
                            case 3b111: { takeBranch = ( __unsigned(sourceReg1) >= __unsigned(sourceReg2) ) ? 1 : 0; }
                        }
                    }
                    case 1b1: {
                        // JUMP AND LINK / JUMP AND LINK REGISTER
                        result = pc + 4;
                        newPC = ( opCode[3,1] == 1 ) ? jumpAddress : loadAddress;
                    }
                }
            }
        }

        ++:

        // NEVER write to registers[0]
        if( writeRegister && ( destReg != 0 ) ) {
            registers_1.addr = destReg;
            registers_1.wdata = result;
            registers_1.wenable = 1;
            registers_2.addr = destReg;
            registers_2.wdata = result;
            registers_2.wenable = 1;
        }

        pc = takeBranch ? pc + branchOffset : newPC;
    } // RISC-V
}

// NON I/O MEMORY switch between BRAM and SDRAM ( when implemented )

algorithm memorymap (
    input   uint32  address,
    input   uint32  writeData,
    output  uint32  readData,

    input   uint2   writeSize,
    input   uint2   readSize,

    output  uint1   memoryBusy
) <autorun> {
    // BRAM FAST MEMORY
    bram uint32 ram[8192] = {
    32h00008137, 32h00002097, 32h3a0080e7, 32h00000317,
    32h00830067, 32h00000000, 32h00008067, 32h000037b7,
    32h9147a703, 32h00074783, 32h0017f793, 32hfe078ce3,
    32h000037b7, 32h9107a783, 32h0007c503, 32h00008067,
    32h00050793, 32h00100713, 32h04a77263, 32h0ff00713,
    32h04a76a63, 32h00002737, 32h7d472683, 32h00f00613,
    32h0ff00713, 32h00a66463, 32h00f00713, 32h01071713,
    32h41075713, 32h0006d503, 32h01051513, 32h41055513,
    32h00e57533, 32hfea7e8e3, 32h00008067, 32h02050863,
    32h000027b7, 32h7d47a783, 32h0007d503, 32h00157513,
    32h00008067, 32h00002737, 32h7d472703, 32h00075503,
    32h01051513, 32h01055513, 32hfea7eae3, 32h00008067,
    32h000027b7, 32h7cc7a783, 32h00a79023, 32h00008067,
    32h000027b7, 32h7cc7a703, 32h00075783, 32h01079793,
    32h4107d793, 32hfe079ae3, 32h00008067, 32h00157793,
    32h02078a63, 32h000027b7, 32h7f47a783, 32h00c78023,
    32h000027b7, 32h7f07a783, 32h00d78023, 32h000027b7,
    32h7ec7a783, 32h00e79023, 32h000027b7, 32h7e87a783,
    32h00b78023, 32h00257513, 32h02050a63, 32h000027b7,
    32h7e47a783, 32h00c78023, 32h000027b7, 32h7e07a783,
    32h00d78023, 32h000027b7, 32h7dc7a783, 32h00e79023,
    32h000027b7, 32h7d87a783, 32h00b78023, 32h00008067,
    32h000037b7, 32h8f87a783, 32h00a78023, 32h000037b7,
    32h8f47a783, 32h00b78023, 32h000037b7, 32h8f07a783,
    32h00c78023, 32h00008067, 32h000037b7, 32h9007a783,
    32h00a78023, 32h00008067, 32h000027b7, 32h7c47a703,
    32h00074783, 32h0ff7f793, 32hfe078ce3, 32h00008067,
    32h000037b7, 32h8ec7a783, 32h00a78023, 32h000037b7,
    32h8e87a783, 32h00b78023, 32h000037b7, 32h8e47a783,
    32h00c78023, 32h000037b7, 32h8e07a783, 32h00d78023,
    32h000037b7, 32h8dc7a783, 32h00e78023, 32h000037b7,
    32h8d87a783, 32h00100713, 32h00e78023, 32h00008067,
    32h000037b7, 32h8d47a783, 32h00a78023, 32h000037b7,
    32h8d07a783, 32h00b78023, 32h000037b7, 32h8cc7a783,
    32h00c79023, 32h00008067, 32h000037b7, 32h8c47a703,
    32h00074783, 32h0ff7f793, 32hfe079ce3, 32h000037b7,
    32h8c87a783, 32h00a78023, 32h00008067, 32h000037b7,
    32h8a07a703, 32h00074783, 32h0ff7f793, 32hfe079ce3,
    32h00008067, 32hff010113, 32h00112623, 32h00812423,
    32h00912223, 32h01212023, 32h00050913, 32h00058493,
    32h00060413, 32h00000097, 32hfc8080e7, 32h000037b7,
    32h8b87a783, 32h01278023, 32h000037b7, 32h8c07a783,
    32h00979023, 32h000037b7, 32h8bc7a783, 32h00879023,
    32h000037b7, 32h8a47a783, 32h00100713, 32h00e78023,
    32h00c12083, 32h00812403, 32h00412483, 32h00012903,
    32h01010113, 32h00008067, 32hfe010113, 32h00112e23,
    32h00812c23, 32h00912a23, 32h01212823, 32h01312623,
    32h01412423, 32h00050a13, 32h00058993, 32h00060913,
    32h00068493, 32h00070413, 32h00000097, 32hf44080e7,
    32h000037b7, 32h8b87a783, 32h01478023, 32h000037b7,
    32h8c07a783, 32h01379023, 32h000037b7, 32h8bc7a783,
    32h01279023, 32h000037b7, 32h8b47a783, 32h00979023,
    32h000037b7, 32h8b07a783, 32h00879023, 32h000037b7,
    32h8a47a783, 32h00200713, 32h00e78023, 32h01c12083,
    32h01812403, 32h01412483, 32h01012903, 32h00c12983,
    32h00812a03, 32h02010113, 32h00008067, 32hff010113,
    32h00112623, 32h1df00713, 32h27f00693, 32h00000613,
    32h00000593, 32h04000513, 32h00000097, 32hf40080e7,
    32h00c12083, 32h01010113, 32h00008067, 32hfe010113,
    32h00112e23, 32h00812c23, 32h00912a23, 32h01212823,
    32h01312623, 32h01412423, 32h00050a13, 32h00058993,
    32h00060913, 32h00068493, 32h00070413, 32h00000097,
    32he70080e7, 32h000037b7, 32h8b87a783, 32h01478023,
    32h000037b7, 32h8c07a783, 32h01379023, 32h000037b7,
    32h8bc7a783, 32h01279023, 32h000037b7, 32h8b47a783,
    32h00979023, 32h000037b7, 32h8b07a783, 32h00879023,
    32h000037b7, 32h8a47a783, 32h00300713, 32h00e78023,
    32h01c12083, 32h01812403, 32h01412483, 32h01012903,
    32h00c12983, 32h00812a03, 32h02010113, 32h00008067,
    32hfe010113, 32h00112e23, 32h00812c23, 32h00912a23,
    32h01212823, 32h01312623, 32h00050993, 32h00058913,
    32h00060493, 32h00068413, 32h00000097, 32hdd4080e7,
    32h000037b7, 32h8b87a783, 32h01378023, 32h000037b7,
    32h8c07a783, 32h01279023, 32h000037b7, 32h8bc7a783,
    32h00979023, 32h000037b7, 32h8b47a783, 32h00879023,
    32h000037b7, 32h8a47a783, 32h00400713, 32h00e78023,
    32h01c12083, 32h01812403, 32h01412483, 32h01012903,
    32h00c12983, 32h02010113, 32h00008067, 32hfe010113,
    32h00112e23, 32h00812c23, 32h00912a23, 32h01212823,
    32h01312623, 32h00050993, 32h00058913, 32h00060493,
    32h00068413, 32h00000097, 32hd48080e7, 32h000037b7,
    32h8b87a783, 32h01378023, 32h000037b7, 32h8c07a783,
    32h01279023, 32h000037b7, 32h8bc7a783, 32h00979023,
    32h000037b7, 32h8b47a783, 32h00879023, 32h000037b7,
    32h8a47a783, 32h00600713, 32h00e78023, 32h01c12083,
    32h01812403, 32h01412483, 32h01012903, 32h00c12983,
    32h02010113, 32h00008067, 32hfe010113, 32h00112e23,
    32h00812c23, 32h00912a23, 32h01212823, 32h01312623,
    32h01412423, 32h01512223, 32h01612023, 32h00050b13,
    32h00058a93, 32h00060a13, 32h00068993, 32h00070913,
    32h00078493, 32h00080413, 32h00000097, 32hca4080e7,
    32h000037b7, 32h8b87a783, 32h01678023, 32h000037b7,
    32h8c07a783, 32h01579023, 32h000037b7, 32h8bc7a783,
    32h01479023, 32h000037b7, 32h8b47a783, 32h01379023,
    32h000037b7, 32h8b07a783, 32h01279023, 32h000037b7,
    32h8ac7a783, 32h00979023, 32h000037b7, 32h8a87a783,
    32h00879023, 32h000037b7, 32h8a47a783, 32h00700713,
    32h00e78023, 32h01c12083, 32h01812403, 32h01412483,
    32h01012903, 32h00c12983, 32h00812a03, 32h00412a83,
    32h00012b03, 32h02010113, 32h00008067, 32h000037b7,
    32h8887a703, 32h00074783, 32h0ff7f793, 32hfe079ce3,
    32h000037b7, 32h89c7a783, 32h00a78023, 32h000037b7,
    32h8987a783, 32h00b78023, 32h000037b7, 32h8947a783,
    32h00c79023, 32h000037b7, 32h8907a783, 32h00d79023,
    32h000037b7, 32h88c7a783, 32h00100713, 32h00e78023,
    32h00008067, 32h000037b7, 32h8847a783, 32h00a78023,
    32h000037b7, 32h8807a783, 32h00b78023, 32h000037b7,
    32h87c7a783, 32h00c78023, 32h000037b7, 32h8787a783,
    32h00d78023, 32h000037b7, 32h8747a783, 32h00e78023,
    32h000037b7, 32h8707a783, 32h00100713, 32h00e78023,
    32h00008067, 32h00050863, 32h00100313, 32h06650063,
    32h00008067, 32h00003537, 32h86c52503, 32h00b50023,
    32h000035b7, 32h8685a583, 32h00c58023, 32h00003637,
    32h86462603, 32h01060023, 32h00003637, 32h86062603,
    32h00d60023, 32h000036b7, 32h85c6a683, 32h00e69023,
    32h00003737, 32h85872703, 32h00f71023, 32h000037b7,
    32h8547a783, 32h01178023, 32h00008067, 32h00003537,
    32h83c52503, 32h00b50023, 32h000035b7, 32h8385a583,
    32h00c58023, 32h00003637, 32h83462603, 32h01060023,
    32h00003637, 32h83062603, 32h00d60023, 32h000036b7,
    32h82c6a683, 32h00e69023, 32h00003737, 32h82872703,
    32h00f71023, 32h000037b7, 32h8247a783, 32h01178023,
    32h00008067, 32h02051263, 32h00159593, 32h000037b7,
    32h8407a783, 32h00b785b3, 32h0005d503, 32h01051513,
    32h01055513, 32h00008067, 32h00159593, 32h000037b7,
    32h8107a783, 32h00b785b3, 32h0005d503, 32h01051513,
    32h01055513, 32h00008067, 32h0a051863, 32h000037b7,
    32h86c7a783, 32h00b78023, 32h00500793, 32h14c7e463,
    32h00261613, 32h000037b7, 32h91878793, 32h00f60633,
    32h00062783, 32h00078067, 32h000037b7, 32h8687a783,
    32h0007c503, 32h0ff57513, 32h00008067, 32h000037b7,
    32h8647a783, 32h0007c503, 32h0ff57513, 32h00008067,
    32h000037b7, 32h8607a783, 32h0007c503, 32h0ff57513,
    32h00008067, 32h000037b7, 32h85c7a783, 32h0007d503,
    32h01051513, 32h01055513, 32h00008067, 32h000037b7,
    32h8587a783, 32h0007d503, 32h01051513, 32h01055513,
    32h00008067, 32h000037b7, 32h8547a783, 32h0007c503,
    32h0ff57513, 32h00008067, 32h000037b7, 32h83c7a783,
    32h00b78023, 32h00500793, 32h08c7ee63, 32h00261613,
    32h000037b7, 32h93078793, 32h00f60633, 32h00062783,
    32h00078067, 32h000037b7, 32h8387a783, 32h0007c503,
    32h0ff57513, 32h00008067, 32h000037b7, 32h8347a783,
    32h0007c503, 32h0ff57513, 32h00008067, 32h000037b7,
    32h8307a783, 32h0007c503, 32h0ff57513, 32h00008067,
    32h000037b7, 32h82c7a783, 32h0007d503, 32h01051513,
    32h01055513, 32h00008067, 32h000037b7, 32h8287a783,
    32h0007d503, 32h01051513, 32h01055513, 32h00008067,
    32h000037b7, 32h8247a783, 32h0007c503, 32h0ff57513,
    32h00008067, 32h00008067, 32h00050863, 32h00100793,
    32h02f50263, 32h00008067, 32h000037b7, 32h86c7a783,
    32h00b78023, 32h000037b7, 32h8507a783, 32h00c79023,
    32h00008067, 32h000037b7, 32h83c7a783, 32h00b78023,
    32h000037b7, 32h8207a783, 32h00c79023, 32h00008067,
    32h00050863, 32h00100793, 32h02f50863, 32h00008067,
    32h000037b7, 32h84c7a783, 32h00b78023, 32h000037b7,
    32h8487a783, 32h00c78023, 32h000037b7, 32h8447a783,
    32h00d79023, 32h00008067, 32h000037b7, 32h81c7a783,
    32h00b78023, 32h000037b7, 32h8187a783, 32h00c78023,
    32h000037b7, 32h8147a783, 32h00d79023, 32h00008067,
    32h000027b7, 32h7f87a703, 32h00074783, 32h0ff7f793,
    32hfe079ce3, 32h00300793, 32h00f70023, 32h00008067,
    32h000037b7, 32h80c7a783, 32h00a78023, 32h000037b7,
    32h8087a783, 32h00b78023, 32h000037b7, 32h8007a783,
    32h00c78023, 32h000027b7, 32h7fc7a783, 32h00d78023,
    32h000027b7, 32h7f87a783, 32h00100693, 32h00d78023,
    32h00074603, 32h02060e63, 32h000025b7, 32h00003837,
    32h00200513, 32h7f85a683, 32h0006c783, 32h0ff7f793,
    32hfe079ce3, 32h80482783, 32h00c78023, 32h7f85a783,
    32h00a78023, 32h00170713, 32h00074603, 32hfc061ce3,
    32h00008067, 32hfd010113, 32h02112623, 32h02812423,
    32h02912223, 32h03212023, 32h01312e23, 32h01412c23,
    32h01512a23, 32h01612823, 32h01712623, 32h00000a93,
    32h00003bb7, 32h00000993, 32h08000a13, 32h00c00b13,
    32ha68b8493, 32h00098413, 32h0ffaf913, 32h0004d683,
    32h00040613, 32h00090593, 32h00098513, 32h00000097,
    32hea4080e7, 32h0004d683, 32h00040613, 32h00090593,
    32h00100513, 32h00000097, 32he8c080e7, 32h00140413,
    32h0ff47413, 32h00248493, 32hfd4412e3, 32h001a8a93,
    32h010a9a93, 32h410ada93, 32hfb6a94e3, 32h02c12083,
    32h02812403, 32h02412483, 32h02012903, 32h01c12983,
    32h01812a03, 32h01412a83, 32h01012b03, 32h00c12b83,
    32h03010113, 32h00008067, 32hff010113, 32h00112623,
    32h00812423, 32h00912223, 32h01212023, 32h000037b7,
    32h00a034b3, 32h00849493, 32hb6878793, 32h009784b3,
    32h00000413, 32h08000913, 32h0004d683, 32h00040613,
    32h00b00593, 32h00000513, 32h00000097, 32hdf8080e7,
    32h0004d683, 32h00040613, 32h00b00593, 32h00100513,
    32h00000097, 32hde0080e7, 32h00140413, 32h0ff47413,
    32h00248493, 32hfd2412e3, 32h00c12083, 32h00812403,
    32h00412483, 32h00012903, 32h01010113, 32h00008067,
    32hff010113, 32h00112623, 32h00000713, 32h00000693,
    32h00100613, 32h00000593, 32h00000513, 32h00000097,
    32ha98080e7, 32h00a00713, 32h00500693, 32h00100613,
    32h00100593, 32h00000513, 32h00000097, 32ha7c080e7,
    32h00600713, 32h00000693, 32h00100613, 32h00200593,
    32h00000513, 32h00000097, 32ha60080e7, 32h00a00713,
    32h0fb00693, 32h00100613, 32h00300593, 32h00000513,
    32h00000097, 32ha44080e7, 32h00000713, 32h00000693,
    32h00100613, 32h00400593, 32h00000513, 32h00000097,
    32ha28080e7, 32h00000713, 32h00000693, 32h00000613,
    32h00500593, 32h00000513, 32h00000097, 32ha0c080e7,
    32h00c12083, 32h01010113, 32h00008067, 32hff010113,
    32h00112623, 32h00812423, 32h00912223, 32h01212023,
    32h000034b7, 32hd6848493, 32h00000413, 32h08000913,
    32h0004d683, 32h00040613, 32h00c00593, 32h00000513,
    32h00000097, 32hcc0080e7, 32h0004d683, 32h00040613,
    32h00c00593, 32h00100513, 32h00000097, 32hca8080e7,
    32h00140413, 32h0ff47413, 32h00248493, 32hfd2412e3,
    32h00c12083, 32h00812403, 32h00412483, 32h00012903,
    32h01010113, 32h00008067, 32hfe010113, 32h00112e23,
    32h00812c23, 32h00912a23, 32h01212823, 32h01312623,
    32h01412423, 32h01512223, 32h01612023, 32h00900513,
    32hfffff097, 32h4e8080e7, 32h00003a37, 32he68a0a13,
    32h00100913, 32h00000b13, 32h01000993, 32h00900a93,
    32h000a0493, 32h000b0413, 32h0004d603, 32h00040593,
    32h00090513, 32hfffff097, 32h48c080e7, 32h00140413,
    32h0ff47413, 32h00248493, 32hff3410e3, 32h00190913,
    32h0ff97913, 32h020a0a13, 32hfd5914e3, 32h01500713,
    32h04000693, 32h00100613, 32h00400593, 32h00400513,
    32hfffff097, 32h400080e7, 32h01500713, 32h04000693,
    32h00200613, 32h00500593, 32h00400513, 32hfffff097,
    32h3e4080e7, 32h01500713, 32h04000693, 32h00300613,
    32h00400593, 32h00500513, 32hfffff097, 32h3c8080e7,
    32h01500713, 32h04000693, 32h00400613, 32h00500593,
    32h00500513, 32hfffff097, 32h3ac080e7, 32h01400713,
    32h04000693, 32h00100613, 32h00e00593, 32h01200513,
    32hfffff097, 32h390080e7, 32h01400713, 32h04000693,
    32h00200613, 32h00f00593, 32h01200513, 32hfffff097,
    32h374080e7, 32h01400713, 32h04000693, 32h00300613,
    32h00e00593, 32h01300513, 32hfffff097, 32h358080e7,
    32h01400713, 32h04000693, 32h00400613, 32h00f00593,
    32h01300513, 32hfffff097, 32h33c080e7, 32h00500713,
    32h04000693, 32h00100613, 32h01c00593, 32h02200513,
    32hfffff097, 32h320080e7, 32h00500713, 32h04000693,
    32h00200613, 32h01d00593, 32h02200513, 32hfffff097,
    32h304080e7, 32h00500713, 32h04000693, 32h00300613,
    32h01c00593, 32h02300513, 32hfffff097, 32h2e8080e7,
    32h00500713, 32h04000693, 32h00400613, 32h01d00593,
    32h02300513, 32hfffff097, 32h2cc080e7, 32h02a00713,
    32h04000693, 32h00500613, 32h00200593, 32h02400513,
    32hfffff097, 32h2b0080e7, 32h02a00713, 32h04000693,
    32h00600613, 32h00300593, 32h02400513, 32hfffff097,
    32h294080e7, 32h02a00713, 32h04000693, 32h00700613,
    32h00200593, 32h02500513, 32hfffff097, 32h278080e7,
    32h02a00713, 32h04000693, 32h00800613, 32h00300593,
    32h02500513, 32hfffff097, 32h25c080e7, 32h01000713,
    32h04000693, 32h00500613, 32h01a00593, 32h00600513,
    32hfffff097, 32h240080e7, 32h01000713, 32h04000693,
    32h00600613, 32h01b00593, 32h00600513, 32hfffff097,
    32h224080e7, 32h01000713, 32h04000693, 32h00700613,
    32h01a00593, 32h00700513, 32hfffff097, 32h208080e7,
    32h01000713, 32h04000693, 32h00800613, 32h01b00593,
    32h00700513, 32hfffff097, 32h1ec080e7, 32h01c12083,
    32h01812403, 32h01412483, 32h01012903, 32h00c12983,
    32h00812a03, 32h00412a83, 32h00012b03, 32h02010113,
    32h00008067, 32hff010113, 32h00112623, 32hfffff097,
    32h380080e7, 32h06400713, 32h06400693, 32h00000613,
    32h00000593, 32h03800513, 32hfffff097, 32h2c0080e7,
    32h06400813, 32h03200793, 32h06400713, 32h06400693,
    32h02100613, 32h06400593, 32h03f00513, 32hfffff097,
    32h52c080e7, 32h06400813, 32h04200793, 32h06400713,
    32h06400693, 32h03200613, 32h06400593, 32h00200513,
    32hfffff097, 32h508080e7, 32h03200713, 32h02100693,
    32h00000613, 32h00000593, 32h00200513, 32hfffff097,
    32h25c080e7, 32h01a00693, 32h01900613, 32h01900593,
    32h03f00513, 32hfffff097, 32h448080e7, 32h00c00713,
    32h01900693, 32h00000613, 32h00000593, 32h03f00513,
    32hfffff097, 32h228080e7, 32h00c00693, 32h01900613,
    32h01900593, 32h00200513, 32hfffff097, 32h414080e7,
    32h06400813, 32h00000793, 32h06400713, 32h04300693,
    32h02100613, 32h00000593, 32h03f00513, 32hfffff097,
    32h47c080e7, 32h06400813, 32h00000793, 32h06400713,
    32h03200693, 32h03200613, 32h00000593, 32h00200513,
    32hfffff097, 32h458080e7, 32h02500713, 32h01900693,
    32h00c00613, 32h00000593, 32h00200513, 32hfffff097,
    32h1ac080e7, 32h06400713, 32h00800693, 32h02500613,
    32h00000593, 32h00200513, 32hfffff097, 32h190080e7,
    32h00c12083, 32h01010113, 32h00008067, 32hfe010113,
    32h00112e23, 32h00812c23, 32h00912a23, 32h01212823,
    32h01312623, 32h01412423, 32h01512223, 32h01612023,
    32h00003937, 32hf9090913, 32h01890993, 32h00100413,
    32h00000493, 32h01500a13, 32h01900b13, 32h00c00a93,
    32h04c0006f, 32h00d5b513, 32h00154513, 32hff358593,
    32h00000893, 32h00000813, 32h00000793, 32h00000713,
    32h00000693, 32h00000613, 32h0ff5f593, 32hfffff097,
    32h518080e7, 32h048b6e63, 32h00148493, 32h00140413,
    32h0ff47413, 32h00190913, 32h00198993, 32h0ff4f593,
    32hfaba6ae3, 32h00090023, 32h00098023, 32h00d5b513,
    32h00154513, 32hfabae4e3, 32h00000893, 32h00000813,
    32h00000793, 32h00000713, 32h00000693, 32h00000613,
    32h00000513, 32hfffff097, 32h4c0080e7, 32hfadff06f,
    32hfffff097, 32h14c080e7, 32h000037b7, 32h9007a783,
    32h00078023, 32h00700613, 32h00100593, 32h02a00513,
    32hfffff097, 32hf10080e7, 32h00000097, 32hd9c080e7,
    32h00900513, 32hfffff097, 32hfc4080e7, 32h00000097,
    32haac080e7, 32hfffff097, 32h77c080e7, 32h00000097,
    32h818080e7, 32h00000513, 32h00000097, 32h8d0080e7,
    32h00000097, 32h950080e7, 32h00000097, 32ha04080e7,
    32h000037b7, 32hfc079823, 32h000037b7, 32hfc079723,
    32h000027b7, 32h13800713, 32h7ce79123, 32h000027b7,
    32h0e800713, 32h7ce79023, 32h000037b7, 32hfc079323,
    32h000037b7, 32hfc079223, 32h000037b7, 32hfc079123,
    32h000037b7, 32hfc07a423, 32h01c12083, 32h01812403,
    32h01412483, 32h01012903, 32h00c12983, 32h00812a03,
    32h00412a83, 32h00012b03, 32h02010113, 32h00008067,
    32h00003737, 32hf9070713, 32h00000793, 32h0ff00513,
    32h01600613, 32h0140006f, 32h00178793, 32h0ff7f793,
    32h00170713, 32h00c78a63, 32h00074683, 32hfe0696e3,
    32h00078513, 32hfe5ff06f, 32h00008067, 32hfe010113,
    32h00112e23, 32h00812c23, 32h00912a23, 32h01212823,
    32h01312623, 32h01412423, 32h01512223, 32h00050a93,
    32h00000097, 32hfa0080e7, 32h0ff00793, 32h10f50263,
    32h00050913, 32h000029b7, 32h00002a37, 32h27f00513,
    32hfffff097, 32hcb0080e7, 32h00050413, 32h1df00513,
    32hfffff097, 32hca0080e7, 32h00050493, 32h0ff57713,
    32h0ff47693, 32h7c299783, 32hfc078613, 32h02c6c263,
    32h04078793, 32h00d7ce63, 32h00070793, 32h7c0a1703,
    32hfc070693, 32h00d7c663, 32h04070713, 32hfaf758e3,
    32h00090993, 32h000037b7, 32hf9078793, 32h012787b3,
    32h01578023, 32h00200793, 32h00300513, 32h00fa8463,
    32h00700513, 32hfffff097, 32hc3c080e7, 32h000037b7,
    32hf9078793, 32h013787b3, 32h00a78c23, 32h00b93a13,
    32h001a4a13, 32h00a00793, 32h0127f663, 32hff590913,
    32h0ff97913, 32h01f00513, 32hfffff097, 32hc08080e7,
    32h00050993, 32h00600513, 32hfffff097, 32hbf8080e7,
    32hffea8893, 32h02098693, 32h0018b893, 32h0ff57813,
    32h0ff4f793, 32h0ff47713, 32h0ff6f693, 32h00100613,
    32h00090593, 32h000a0513, 32hfffff097, 32h26c080e7,
    32h01c12083, 32h01812403, 32h01412483, 32h01012903,
    32h00c12983, 32h00812a03, 32h00412a83, 32h02010113,
    32h00008067, 32hfe010113, 32h00112e23, 32h00812c23,
    32h00912a23, 32h01212823, 32h01312623, 32h000034b7,
    32hf9048493, 32h01848913, 32h00000413, 32h01600993,
    32h00048023, 32h00090023, 32h00000893, 32h00000813,
    32h00000793, 32h00000713, 32h00000693, 32h00000613,
    32h00040593, 32h00000513, 32hfffff097, 32h1ec080e7,
    32h00000893, 32h00000813, 32h00000793, 32h00000713,
    32h00000693, 32h00000613, 32h00040593, 32h00100513,
    32hfffff097, 32h1c4080e7, 32h00140413, 32h0ff47413,
    32h00148493, 32h00190913, 32hf9341ce3, 32h000037b7,
    32hfcc7d483, 32h01049713, 32h01075713, 32h00400793,
    32h00e7f463, 32h00400493, 32h00448493, 32h0ff4f493,
    32h00000413, 32h00200513, 32h00000097, 32hde4080e7,
    32h00140413, 32h0ff47413, 32hfe9466e3, 32h01c12083,
    32h01812403, 32h01412483, 32h01012903, 32h00c12983,
    32h02010113, 32h00008067, 32hfd010113, 32h02112623,
    32h02812423, 32h02912223, 32h03212023, 32h01312e23,
    32h01412c23, 32h01512a23, 32h01612823, 32h01712623,
    32h01812423, 32h01912223, 32h01a12023, 32h00003937,
    32hf9090913, 32h01890a13, 32h0f500493, 32h00000413,
    32h00100c13, 32h00a00c93, 32h00003d37, 32ha68d0d13,
    32h00200b93, 32h00300b13, 32h01600a93, 32h0580006f,
    32h00b43513, 32h00154513, 32h00048593, 32h008ce463,
    32h00040593, 32h000a4783, 32h00179793, 32h00fd07b3,
    32h5007d603, 32hfffff097, 32h324080e7, 32h03c0006f,
    32h0009c783, 32h05678463, 32h00140413, 32h0ff47413,
    32h00190913, 32h00148493, 32h0ff4f493, 32h001a0a13,
    32h07540463, 32h00090993, 32h00094783, 32hfff78793,
    32h0ff7f793, 32hf8fc7ee3, 32h0009c783, 32hfcfbf2e3,
    32hfff78793, 32h00f98023, 32hfb9ff06f, 32h00098023,
    32h00b43513, 32h00154513, 32h00048593, 32h008ce463,
    32h00040593, 32h00000893, 32h00000813, 32h00000793,
    32h00000713, 32h00000693, 32h00000613, 32hfffff097,
    32h038080e7, 32hf85ff06f, 32h02c12083, 32h02812403,
    32h02412483, 32h02012903, 32h01c12983, 32h01812a03,
    32h01412a83, 32h01012b03, 32h00c12b83, 32h00812c03,
    32h00412c83, 32h00012d03, 32h03010113, 32h00008067,
    32h000037b7, 32hf9078793, 32h01678693, 32h00000513,
    32h00c0006f, 32h00178793, 32h00d78e63, 32h0007c703,
    32hfe070ae3, 32h00150513, 32h01051513, 32h41055513,
    32hfe5ff06f, 32h01051513, 32h01055513, 32h00008067,
    32hfe010113, 32h00112e23, 32h00812c23, 32h00912a23,
    32h01212823, 32h01312623, 32h00050413, 32h000039b7,
    32h00002937, 32h000024b7, 32h00000893, 32hfc69c803,
    32h7c091783, 32h7c249703, 32h00050693, 32h00100613,
    32h00b00593, 32h00000513, 32hfffff097, 32hf6c080e7,
    32h00000893, 32hfc69c803, 32h7c091783, 32h7c249703,
    32h00040693, 32h00100613, 32h00b00593, 32h00100513,
    32hfffff097, 32hf44080e7, 32h01c12083, 32h01812403,
    32h01412483, 32h01012903, 32h00c12983, 32h02010113,
    32h00008067, 32h000037b7, 32hfc67d683, 32h00700713,
    32h20d76063, 32h00269793, 32h00003737, 32h94870713,
    32h00e787b3, 32h0007a783, 32h00078067, 32h000027b7,
    32h7c079783, 32h1d000713, 32h00f05863, 32hfff78793,
    32h01079713, 32h41075713, 32h000027b7, 32h7ce79023,
    32h00008067, 32h000027b7, 32h7c279783, 32h26f00693,
    32h00000713, 32h00f6c863, 32h00178793, 32h01079713,
    32h41075713, 32h000027b7, 32h7ce79123, 32h000027b7,
    32h7c079783, 32h1d000713, 32h00f05863, 32hfff78793,
    32h01079713, 32h41075713, 32h000027b7, 32h7ce79023,
    32h00008067, 32h000027b7, 32h7c279783, 32h26f00693,
    32h00000713, 32h00f6c863, 32h00178793, 32h01079713,
    32h41075713, 32h000027b7, 32h7ce79123, 32h00008067,
    32h000027b7, 32h7c279783, 32h26f00693, 32h00000713,
    32h00f6c863, 32h00178793, 32h01079713, 32h41075713,
    32h000027b7, 32h7ce79123, 32h000027b7, 32h7c079783,
    32h1cf00693, 32h00000713, 32h00f6c863, 32h00178793,
    32h01079713, 32h41075713, 32h000027b7, 32h7ce79023,
    32h00008067, 32h000027b7, 32h7c079783, 32h1cf00693,
    32h00000713, 32h00f6c863, 32h00178793, 32h01079713,
    32h41075713, 32h000027b7, 32h7ce79023, 32h00008067,
    32h000027b7, 32h7c279783, 32h27000713, 32h00f05863,
    32hfff78793, 32h01079713, 32h41075713, 32h000027b7,
    32h7ce79123, 32h000027b7, 32h7c079783, 32h1cf00693,
    32h00000713, 32h00f6c863, 32h00178793, 32h01079713,
    32h41075713, 32h000027b7, 32h7ce79023, 32h00008067,
    32h000027b7, 32h7c279783, 32h27000713, 32h00f05863,
    32hfff78793, 32h01079713, 32h41075713, 32h000027b7,
    32h7ce79123, 32h00008067, 32h000027b7, 32h7c279783,
    32h27000713, 32h00f05863, 32hfff78793, 32h01079713,
    32h41075713, 32h000027b7, 32h7ce79123, 32h000027b7,
    32h7c079783, 32h1d000713, 32h00f05863, 32hfff78793,
    32h01079713, 32h41075713, 32h000027b7, 32h7ce79023,
    32h00008067, 32hfe010113, 32h00112e23, 32h000037b7,
    32h98878793, 32h0007a603, 32h0047a683, 32h0087a703,
    32h00c12023, 32h00d12223, 32h00e12423, 32h00c7c783,
    32h00f10623, 32h000037b7, 32hfce7d683, 32h00b10793,
    32h00610593, 32h00a00613, 32h02c6f733, 32h02c6d6b3,
    32h03070713, 32h00e78023, 32hfff78793, 32hfeb796e3,
    32h000037b7, 32hfd07d683, 32h00d036b3, 32h40d006b3,
    32h02a6f693, 32h00010713, 32h01568693, 32h04000613,
    32h00100593, 32h02200513, 32hfffff097, 32hfb8080e7,
    32h01c12083, 32h02010113, 32h00008067, 32hff010113,
    32h00112623, 32h000037b7, 32hfd07d783, 32h00200713,
    32h02e78863, 32h00300713, 32h00e78863, 32h00100713,
    32h04e79863, 32h0340006f, 32h1d000693, 32h26000613,
    32h03f00593, 32h00000513, 32hfffff097, 32hb94080e7,
    32h1d000693, 32h24000613, 32h03f00593, 32h00000513,
    32hfffff097, 32hb7c080e7, 32h1d000693, 32h22000613,
    32h03f00593, 32h00000513, 32hfffff097, 32hb64080e7,
    32h00c12083, 32h01010113, 32h00008067, 32hff010113,
    32h00112623, 32h00812423, 32h00912223, 32h00000413,
    32h00000493, 32h000037b7, 32hfc679683, 32h000037b7,
    32hfcd79123, 32h01069713, 32h01075713, 32h00700793,
    32h02e7ec63, 32h00269693, 32h000037b7, 32h96878793,
    32h00f686b3, 32h0006a783, 32h00078067, 32h000027b7,
    32h7c279403, 32h000027b7, 32h7c07d483, 32hff648493,
    32h01049493, 32h4104d493, 32h00000893, 32h00200813,
    32h00048793, 32h00040713, 32h03c00693, 32h00100613,
    32h00c00593, 32h00000513, 32hfffff097, 32hb6c080e7,
    32h00000893, 32h00000813, 32h00048793, 32h00040713,
    32h03000693, 32h00100613, 32h00c00593, 32h00100513,
    32hfffff097, 32hb44080e7, 32h08000713, 32h03d00693,
    32h00400613, 32h00200593, 32h00300513, 32hffffe097,
    32h530080e7, 32h00c12083, 32h00812403, 32h00412483,
    32h01010113, 32h00008067, 32h000027b7, 32h7c27d403,
    32h00840413, 32h01041413, 32h41045413, 32h000027b7,
    32h7c07d483, 32hff648493, 32h01049493, 32h4104d493,
    32hf59ff06f, 32h000027b7, 32h7c27d403, 32h00a40413,
    32h01041413, 32h41045413, 32h000027b7, 32h7c079483,
    32hf39ff06f, 32h000027b7, 32h7c27d403, 32h00a40413,
    32h01041413, 32h41045413, 32h000027b7, 32h7c07d483,
    32h00a48493, 32h01049493, 32h4104d493, 32hf0dff06f,
    32h000027b7, 32h7c279403, 32h000027b7, 32h7c07d483,
    32h00a48493, 32h01049493, 32h4104d493, 32heedff06f,
    32h000027b7, 32h7c27d403, 32hff640413, 32h01041413,
    32h41045413, 32h000027b7, 32h7c07d483, 32h00a48493,
    32h01049493, 32h4104d493, 32hec1ff06f, 32h000027b7,
    32h7c27d403, 32hff640413, 32h01041413, 32h41045413,
    32h000027b7, 32h7c079483, 32hea1ff06f, 32h000027b7,
    32h7c27d403, 32hff640413, 32h01041413, 32h41045413,
    32h000027b7, 32h7c07d483, 32hff648493, 32h01049493,
    32h4104d493, 32he75ff06f, 32hff010113, 32h00112623,
    32h00812423, 32h00912223, 32h00003437, 32ha6840413,
    32h000034b7, 32hfc249783, 32h00179793, 32h00f407b3,
    32h5187d603, 32h00c00593, 32h00000513, 32hfffff097,
    32hc2c080e7, 32hfc249783, 32h00179793, 32h00f40433,
    32h51845603, 32h00c00593, 32h00100513, 32hfffff097,
    32hc0c080e7, 32h00c12083, 32h00812403, 32h00412483,
    32h01010113, 32h00008067, 32h000027b7, 32h7d07a783,
    32h0007d783, 32h01079793, 32h4107d793, 32h00003737,
    32hfc071703, 32h00f71463, 32h00008067, 32hff010113,
    32h00112623, 32h00812423, 32h00000097, 32hc4c080e7,
    32h00002437, 32h7d042783, 32h0007d703, 32h000037b7,
    32hfce79023, 32h00500513, 32hffffe097, 32h480080e7,
    32h7d042783, 32h0007d783, 32h0037f793, 32h00200713,
    32h08e78a63, 32h0ef76063, 32h02078e63, 32h00100713,
    32h0ee79663, 32h000037b7, 32hfd07d783, 32h0e079063,
    32h00003737, 32h9cc70713, 32h00f00693, 32h04000613,
    32h01200593, 32h01000513, 32hfffff097, 32hc18080e7,
    32h0bc0006f, 32h000037b7, 32hfd07d783, 32h02078263,
    32h1f400713, 32h00100693, 32h00000613, 32h00100593,
    32h00100513, 32hffffe097, 32h2c8080e7, 32h0900006f,
    32h00003737, 32h99870713, 32h00300693, 32h04000613,
    32h01200593, 32h01000513, 32hfffff097, 32hbc8080e7,
    32h06c0006f, 32h000037b7, 32hfd07d783, 32h02078263,
    32h1f400713, 32h00200693, 32h00000613, 32h00100593,
    32h00200513, 32hffffe097, 32h278080e7, 32h0400006f,
    32h00003737, 32ha0070713, 32h03c00693, 32h04000613,
    32h01200593, 32h01000513, 32hfffff097, 32hb78080e7,
    32h01c0006f, 32h000037b7, 32hfd07d783, 32h02078063,
    32h00600513, 32hffffe097, 32h374080e7, 32h00c12083,
    32h00812403, 32h01010113, 32h00008067, 32h00003737,
    32ha3470713, 32h03000693, 32h04000613, 32h01200593,
    32h01000513, 32hfffff097, 32hb2c080e7, 32hfc5ff06f,
    32hfd010113, 32h02112623, 32h02812423, 32h02912223,
    32h03212023, 32h01312e23, 32h01412c23, 32h01512a23,
    32h01612823, 32h01712623, 32h00050493, 32h00058913,
    32h00060993, 32hfffff097, 32h3ec080e7, 32h0ff00793,
    32h0ef50063, 32h00050413, 32h00050a13, 32h000037b7,
    32hf9078793, 32h00a787b3, 32h00978023, 32h00200793,
    32h00300513, 32h00f48463, 32h00700513, 32hffffe097,
    32h0e4080e7, 32h000037b7, 32hf9078793, 32h014787b3,
    32h00a78c23, 32h00b43b93, 32h001bcb93, 32h00a00793,
    32h0087f663, 32hff540413, 32h0ff47413, 32h01f00513,
    32hffffe097, 32h0b0080e7, 32h00050a13, 32h00f00513,
    32hffffe097, 32h0a0080e7, 32h00050a93, 32h00f00513,
    32hffffe097, 32h090080e7, 32h00050b13, 32h00600513,
    32hffffe097, 32h080080e7, 32hffe48893, 32hff898793,
    32h00fb07b3, 32hff890913, 32h012a8933, 32h020a0693,
    32h0018b893, 32h0ff57813, 32h01079793, 32h4107d793,
    32h01091713, 32h41075713, 32h0ff6f693, 32h00100613,
    32h00040593, 32h000b8513, 32hffffe097, 32h6dc080e7,
    32h02c12083, 32h02812403, 32h02412483, 32h02012903,
    32h01c12983, 32h01812a03, 32h01412a83, 32h01012b03,
    32h00c12b83, 32h03010113, 32h00008067, 32hfd010113,
    32h02112623, 32h02812423, 32h02912223, 32h03212023,
    32h01312e23, 32h01412c23, 32h01512a23, 32h01612823,
    32h01712623, 32h01812423, 32h00c00593, 32h00000513,
    32hffffe097, 32h734080e7, 32h7ff57513, 32h00051e63,
    32h00c00593, 32h00100513, 32hffffe097, 32h71c080e7,
    32h7ff57513, 32h0a050663, 32h1f400713, 32h00800693,
    32h00400613, 32h00200593, 32h00300513, 32hffffe097,
    32h040080e7, 32h00000413, 32h0ff00a13, 32h00000513,
    32h00000593, 32h00001937, 32h01600493, 32h00a00993,
    32h0100006f, 32hff640593, 32h0ff5f593, 32h00078413,
    32hffffe097, 32h6c4080e7, 32h01257533, 32h01051513,
    32h01055513, 32h00050463, 32h00040a13, 32h00140793,
    32h0ff7f793, 32h00978c63, 32h00b7b513, 32h00154513,
    32h00078593, 32hfcf9e0e3, 32hfc5ff06f, 32h0ff00793,
    32h02fa0063, 32h000a0a93, 32h000037b7, 32hf9078793,
    32h014787b3, 32h0007c703, 32h00200793, 32h02e7fa63,
    32h02c12083, 32h02812403, 32h02412483, 32h02012903,
    32h01c12983, 32h01812a03, 32h01412a83, 32h01012b03,
    32h00c12b83, 32h00812c03, 32h03010113, 32h00008067,
    32h00000893, 32h00000813, 32h00000793, 32h00000713,
    32h00000693, 32h00000613, 32h00c00593, 32h00000513,
    32hffffe097, 32h554080e7, 32h00000893, 32h00000813,
    32h00000793, 32h00000713, 32h00000693, 32h00000613,
    32h00c00593, 32h00100513, 32hffffe097, 32h52c080e7,
    32h000036b7, 32hfce6d783, 32h00378793, 32h00003737,
    32hf9070713, 32h01470733, 32h00074703, 32h40e787b3,
    32hfcf69723, 32h00ba3493, 32h0014c493, 32h00a00793,
    32h0147f663, 32hff5a0a13, 32h0ffa7a13, 32h00200613,
    32h000a0593, 32h00048513, 32hffffe097, 32h5e0080e7,
    32h0ff57b93, 32h00300613, 32h000a0593, 32h00048513,
    32hffffe097, 32h5c8080e7, 32h01051913, 32h41095913,
    32h00400613, 32h000a0593, 32h00048513, 32hffffe097,
    32h5ac080e7, 32h01051993, 32h4109d993, 32h00500613,
    32h000a0593, 32h00048513, 32hffffe097, 32h590080e7,
    32h0ff57c13, 32h000037b7, 32hf9078793, 32h015787b3,
    32h0007c703, 32h00200793, 32h04f70263, 32h000c0893,
    32h00700813, 32h00098793, 32h00090713, 32h000b8693,
    32h00100613, 32h000a0593, 32h00048513, 32hffffe097,
    32h448080e7, 32h000037b7, 32hf9078793, 32h015787b3,
    32h01900713, 32h00e78023, 32he89ff06f, 32h000037b7,
    32hfcc7d783, 32h00078413, 32h00200713, 32h00f77463,
    32h00200413, 32h0ff47413, 32h00200713, 32h00140b13,
    32h0ffb7b13, 32h02f76463, 32h00000413, 32h00098613,
    32h00090593, 32h00100513, 32h00000097, 32hbf8080e7,
    32h00140413, 32hff6444e3, 32hf75ff06f, 32h00100513,
    32hffffe097, 32hd30080e7, 32h00140413, 32h00a40433,
    32h0ff47b13, 32hfd6042e3, 32hf55ff06f, 32hff010113,
    32h00112623, 32h00b00593, 32h00000513, 32hffffe097,
    32h468080e7, 32h7ff57513, 32h00051e63, 32h00b00593,
    32h00100513, 32hffffe097, 32h450080e7, 32h7ff57513,
    32h02050c63, 32h3e800713, 32h00100693, 32h00400613,
    32h00200593, 32h00300513, 32hffffe097, 32hd74080e7,
    32h00100513, 32hffffe097, 32h7d4080e7, 32h000037b7,
    32h04b00713, 32hfce79223, 32h00c12083, 32h01010113,
    32h00008067, 32hfe010113, 32h00112e23, 32h00812c23,
    32h00912a23, 32h01212823, 32h01312623, 32h01412423,
    32h01512223, 32h01612023, 32h000037b7, 32h9147a783,
    32h0007c783, 32h0017f793, 32h02078063, 32h00003437,
    32hffffe097, 32hc3c080e7, 32h91442783, 32h0007c783,
    32h0017f793, 32hfe0796e3, 32hfffff097, 32hd64080e7,
    32h00003437, 32h00003937, 32h000034b7, 32h00300a93,
    32h00002a37, 32h13800993, 32h0e40006f, 32h00003737,
    32hfcc75783, 32h00178793, 32hfcf71623, 32hfffff097,
    32h078080e7, 32h1040006f, 32hfffff097, 32h6b4080e7,
    32h1cc0006f, 32hfffff097, 32h380080e7, 32h1d40006f,
    32h000037b7, 32h90c7a783, 32h0007c783, 32h0087f793,
    32h1e079463, 32h01500513, 32hfffff097, 32h2c8080e7,
    32h000037b7, 32hfc47d783, 32hfff78793, 32h01079793,
    32h0107d793, 32h00f00713, 32h24f77263, 32h000037b7,
    32hfc479703, 32h01000793, 32h2ae7ca63, 32h00000893,
    32h00000813, 32h00000793, 32h00000713, 32h00000693,
    32h00000613, 32h00c00593, 32h00000513, 32hffffe097,
    32h228080e7, 32h00000893, 32h00000813, 32h00000793,
    32h00000713, 32h00000693, 32h00000613, 32h00c00593,
    32h00100513, 32hffffe097, 32h200080e7, 32hfffff097,
    32h0ac080e7, 32hffffe097, 32hbdc080e7, 32hfc842783,
    32h00178793, 32hfcf42423, 32hfffff097, 32h1e8080e7,
    32h90892703, 32h000037b7, 32hfc07d783, 32h0077f793,
    32h00f51533, 32h0ff57513, 32h00a70023, 32hfffff097,
    32h1c4080e7, 32hee0504e3, 32hffffe097, 32hc60080e7,
    32h000027b7, 32h7cc7a783, 32h00800713, 32h00e79023,
    32h00000097, 32h808080e7, 32hfd04d783, 32hee078ae3,
    32h000037b7, 32hfc479783, 32h24079063, 32hfc842703,
    32h00377713, 32h06071663, 32h00003737, 32h90c72683,
    32h0006c703, 32h02077713, 32h02070463, 32h00003737,
    32hfc671703, 32h00700613, 32h00070863, 32hfff70713,
    32h01071613, 32h41065613, 32h00003737, 32hfcc71323,
    32h0006c703, 32h04077713, 32h02070463, 32h00003737,
    32hfc671703, 32h00700693, 32h00d70863, 32h00170793,
    32h01079793, 32h4107d793, 32h00003737, 32hfcf71323,
    32h00000613, 32h00c00593, 32h00000513, 32hffffe097,
    32h1fc080e7, 32h00051c63, 32h000037b7, 32h90c7a783,
    32h0007c783, 32h0027f793, 32he20798e3, 32h000037b7,
    32h90c7a783, 32h0007c783, 32h0047f793, 32he20794e3,
    32h03f00513, 32hfffff097, 32h10c080e7, 32hfffff097,
    32h6bc080e7, 32h00000097, 32ha08080e7, 32h00000097,
    32hcf0080e7, 32hea9ff06f, 32hffffe097, 32hd34080e7,
    32hffffe097, 32h3a0080e7, 32hfc042423, 32hfd549823,
    32h000037b7, 32hfc079723, 32h000037b7, 32hfc079623,
    32h7d3a1123, 32h000027b7, 32h0e800713, 32h7ce79023,
    32h000037b7, 32hfc079323, 32h00003b37, 32hfc0b1223,
    32h000037b7, 32hfc079123, 32hfffff097, 32h3d4080e7,
    32hfffff097, 32he04080e7, 32hfc4b5783, 32hfff78793,
    32h01079793, 32h0107d793, 32h00f00713, 32hdaf774e3,
    32hfd04d783, 32hda0780e3, 32hdc5ff06f, 32h00b00593,
    32h00000513, 32hffffe097, 32h0d0080e7, 32h7ff57513,
    32hda0516e3, 32h00b00593, 32h00100513, 32hffffe097,
    32h0b8080e7, 32h7ff57513, 32hd8051ae3, 32h00003737,
    32hfc475783, 32hfff78793, 32h01079793, 32h4107d793,
    32hfcf71223, 32h00078c63, 32hfd04d783, 32hd60798e3,
    32hfffff097, 32h8d4080e7, 32hd65ff06f, 32hffffe097,
    32hc50080e7, 32hfd04d783, 32hfff78793, 32hfcf49823,
    32hfffff097, 32h32c080e7, 32hfd1ff06f, 32h0000e637,
    32h00b00593, 32h00000513, 32hffffe097, 32h1f0080e7,
    32h00010637, 32h84060613, 32h00b00593, 32h00100513,
    32hffffe097, 32h1d8080e7, 32h00003737, 32hfc475783,
    32hfff78793, 32h01079793, 32h4107d793, 32hfcf71223,
    32h01000713, 32hd0e794e3, 32h00000513, 32hffffe097,
    32h3bc080e7, 32hcf9ff06f, 32hfff78793, 32h01079793,
    32h0107d793, 32h00f00713, 32hccf76ae3, 32hca9ff06f,
    32h013800e8, 32h00008ff0, 32h00008930, 32h00008920,
    32h00008910, 32h00008900, 32h0000881c, 32h00008818,
    32h00008814, 32h00008810, 32h0000880c, 32h00008808,
    32h00008804, 32h00008800, 32h00008614, 32h00008610,
    32h0000860c, 32h00008608, 32h00008604, 32h00008600,
    32h00008530, 32h00008528, 32h00008524, 32h00008520,
    32h0000851c, 32h00008518, 32h00008514, 32h00008510,
    32h0000850c, 32h00008508, 32h00008504, 32h00008500,
    32h00008330, 32h00008328, 32h00008324, 32h00008320,
    32h0000831c, 32h00008318, 32h00008314, 32h00008310,
    32h0000830c, 32h00008308, 32h00008304, 32h00008300,
    32h00008448, 32h00008440, 32h0000843c, 32h00008444,
    32h00008438, 32h00008434, 32h00008448, 32h00008430,
    32h0000842c, 32h00008428, 32h00008424, 32h00008420,
    32h0000841c, 32h0000841c, 32h00008418, 32h00008414,
    32h00008410, 32h0000840c, 32h00008408, 32h00008404,
    32h00008400, 32h00008234, 32h00008230, 32h00008228,
    32h00008224, 32h00008220, 32h00008214, 32h00008210,
    32h0000820c, 32h00008208, 32h00008204, 32h00008200,
    32h00008108, 32h00008104, 32h00008100, 32h00008700,
    32h00008704, 32h00008700, 32h0000800c, 32h00008008,
    32h00008000, 32h00008004, 32h00000818, 32h0000082c,
    32h00000840, 32h00000854, 32h0000086c, 32h00000884,
    32h000008c4, 32h000008d8, 32h000008ec, 32h00000900,
    32h00000918, 32h00000930, 32h000017ec, 32h00001814,
    32h00001864, 32h00001890, 32h000018e4, 32h00001910,
    32h00001960, 32h00001988, 32h00001b3c, 32h00001bd8,
    32h00001c04, 32h00001c24, 32h00001c50, 32h00001c70,
    32h00001c9c, 32h00001cbc, 32h726f6353, 32h30302065,
    32h30303030, 32h00000000, 32h20202020, 32h20202020,
    32h6c655720, 32h656d6f63, 32h206f7420, 32h63736952,
    32h4543492d, 32h4120562d, 32h72657473, 32h7364696f,
    32h20202020, 32h20202020, 32h00000000, 32h40207942,
    32h6e626f72, 32h20353167, 32h69775428, 32h72657474,
    32h72662029, 32h57206d6f, 32h65746968, 32h64697262,
    32h202c6567, 32h746f6353, 32h646e616c, 32h00000000,
    32h20202020, 32h20202020, 32h20202020, 32h20202020,
    32h65725020, 32h55207373, 32h6f742050, 32h61747320,
    32h20207472, 32h20202020, 32h20202020, 32h20202020,
    32h00000000, 32h20202020, 32h20202020, 32h72572020,
    32h65747469, 32h6e69206e, 32h6c695320, 32h20656369,
    32h40207962, 32h656c7973, 32h20626566, 32h20202020,
    32h20202020, 32h00000000, 32h0ff807f0, 32h1fff1ffe,
    32hffff3fff, 32hfffcfffe, 32h7fffffff, 32h7ffe7fff,
    32h3ffc3ffc, 32h00f00ff8, 32h3c1c1008, 32hffff7f1e,
    32h7ffe7ffe, 32h3ff03ff8, 32h0ff81ff8, 32h7ffe1ffc,
    32h7ffeffff, 32h18783dfc, 32h1f8e0787, 32h67fc0fde,
    32hfffefffc, 32h7fffffff, 32h3ff87ffc, 32h7ffe3ffc,
    32hfffeffff, 32h73f83ffc, 32h3f981800, 32h1ffe3ffc,
    32h1ffe1ffe, 32hffff7ffe, 32hffffffff, 32hfffefffe,
    32h1ff03ffc, 32h018007c0, 32h1ffc0ff0, 32h3ffe1ffe,
    32h7fff3fff, 32hffff7fff, 32hfffeffff, 32h7ffcfffc,
    32h3ff03ffc, 32h07e03ff0, 32h00000000, 32h01800000,
    32h03e003c0, 32h07fc07f8, 32h1ffc0ffc, 32h0ff81ff8,
    32h000001f0, 32h00000000, 32h0fe00600, 32h3ffc1ff8,
    32hfffe7ffe, 32h1fff0fff, 32h3fff1fff, 32h7ffe7fff,
    32h3c383e7c, 32h30003800, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h01000100, 32h07c00380,
    32h0fe007c0, 32h0fe00fe0, 32h1ff01ff0, 32h3ff81ff0,
    32h7efc3ff8, 32h0000783c, 32h001e0001, 32h07fe007e,
    32hfffc1ffe, 32h3ff87ffc, 32h07f81ff8, 32h01f003f8,
    32h00e001f0, 32h00200060, 32h60000000, 32h7f007800,
    32h7ff87ff0, 32h1fff3ff8, 32h3ff83ff8, 32h7ff07ff0,
    32h60007800, 32h00000000, 32h00600020, 32h01f000e0,
    32h03f801f0, 32h1ff807f8, 32h7ffc3ff8, 32h1ffefffc,
    32h007e07fe, 32h0001001e, 32h3c1e0000, 32h1ffc3f7e,
    32h0ff81ffc, 32h0ff80ff8, 32h07f007f0, 32h03e007f0,
    32h01c003e0, 32h00800080, 32h06000400, 32h0f800700,
    32h1fc00f80, 32h1ff81fe0, 32h3ffe1ffc, 32h7ff83fff,
    32h7e007fe0, 32h80007800, 32h00000000, 32h001e0006,
    32h07fe00fe, 32h3ffc1ffc, 32h3ffcfff8, 32h07fe1ffc,
    32h001e00fe, 32h00000006, 32h78008000, 32h7fe07e00,
    32h3fff7ff8, 32h1ffc3ffe, 32h1fe01ff8, 32h0f801fc0,
    32h07000f80, 32h04000600, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h03000000, 32h60100302,
    32h00006000, 32h80180419, 32h42060020, 32h18200006,
    32h00811800, 32h40100400, 32h00000000, 32h00000000,
    32h01000000, 32h07c00100, 32h01000100, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h04400000, 32h01000280, 32h04400280, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h01000000, 32h07c00380, 32h01000380, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h05400000, 32h07c00380, 32h05400380, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h01000000, 32h07c00100, 32h01000100, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h04400000, 32h01000280, 32h04400280, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h01000000, 32h07c00380, 32h01000380, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h05400000, 32h07c00380, 32h05400380, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h00000000, 32h00000000, 32h003f001f, 32h01ff00ff,
    32h03ff03ff, 32h07fc07ff, 32h37c71ff1, 32h33f1279c,
    32h011f1fc7, 32h003f00ff, 32h00000000, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h00000000, 32h00000000, 32hf000c000, 32hff00f800,
    32he700f900, 32h74000c00, 32h1c00c400, 32hf8007c00,
    32hf000f800, 32h8000e000, 32h00000000, 32h00000000,
    32h00000000, 32h00000000, 32h00000000, 32h00000000,
    32h00000000, 32h00030001, 32h00c4007e, 32h01900088,
    32h03200110, 32h000303f1, 32h00050006, 32h00080022,
    32h00240480, 32h00900020, 32h00400000, 32h00100000,
    32h00000000, 32h00000000, 32h007e0000, 32h1e0207e2,
    32he6047006, 32h198c8f0c, 32h0f181998, 32h00600630,
    32hd0c06060, 32h4300a180, 32h0a008600, 32hc2003200,
    32h9c008200, 32hc000f000, 32h00000000, 32h00000000,
    32h00000000, 32h00000000, 32h00090039, 32h003f000f,
    32h003a0031, 32h0011000a, 32h000e0017, 32h0037003e,
    32h01b201a0, 32h01920183, 32h01960198, 32h01b60184

        , pad(uninitialized)
    };

    uint1   active = 0;

    ram.wenable := 0;
    memoryBusy := ( writeSize > 0 ) || ( readSize > 0 ) ? 1 : active;

    while(1) {
        if( writeSize > 0 ) {
            active = 1;
            ram.addr = address[2,14];
            switch( writeSize ) {
                case 1: {
                    // 8 bit
                    ++:
                    switch( address[0,2] ) {
                        case 2b00: { ram.wdata = { ram.rdata[8,24], writeData[0,8] }; }
                        case 2b01: { ram.wdata = { ram.rdata[16,16], writeData[0,8], ram.rdata[0,8] }; }
                        case 2b10: { ram.wdata = { ram.rdata[24,8], writeData[0,8], ram.rdata[0,16] }; }
                        case 2b11: { ram.wdata = { writeData[0,8], ram.rdata[0,24] }; }
                    }
                }
                case 2: {
                    // 16 bit
                    ++:
                    switch( address[1,1] ) {
                        case 1b0: { ram.wdata = { ram.rdata[16,16], writeData[0,16] }; }
                        case 1b1: { ram.wdata = { writeData[0,16], ram.rdata[0,16] }; }
                    }
                }
                case 3: {
                    // 32 bit
                    ram.wdata = writeData;
                }
            }
            ram.wenable = 1;
            active = 0;
        }

        if( readSize > 0 ) {
            active = 1;

            ram.addr = address[2,14];
            ++:
            switch( readSize ) {
                case 1: {
                    // 8 bit
                    switch( address[0,2] ) {
                        case 2b00: { readData = { 24b0, ram.rdata[0,8] }; }
                        case 2b01: { readData = { 24b0, ram.rdata[8,8] }; }
                        case 2b10: { readData = { 24b0, ram.rdata[16,8] }; }
                        case 2b11: { readData = { 24b0, ram.rdata[24,8] }; }
                    }
                }
                case 2: {
                    // 16 bit
                    switch( address[1,1] ) {
                        case 1b0: { readData = { 16b0, ram.rdata[0,16] }; }
                        case 1b1: { readData = { 16b0, ram.rdata[16,16] }; }
                    }
                }
                case 3: {
                    // 32 bit
                    readData = ram.rdata;
                }
            }
            active = 0;
        }
    }
}


