// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface dualbram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface dualbram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// simple dual port BRAM

interface simple_dualbram_port0 {
  output! addr0,
  input   rdata0,
}

interface simple_dualbram_port1 {
  output! addr1,
  output! wenable1,
  output! wdata1,
}

interface bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----


// HDMI + UART + SDCARD + SDRAM Driver Includes
// SL 2020-09-05
// Silice HDMI driver
//
// 640x480, 250MHz TMDS from 25MHz pixel clock
//
// Currently limited to the ULX3S, but should be relatively easy to port,
// pending pll and differential serial output primitives
//
// See also
// - https://www.digikey.com/eewiki/pages/viewpage.action?pageId=36569119
// - https://www.fpga4fun.com/HDMI.html
// - https://github.com/lawrie/ulx3s_examples/blob/master/hdmi/tmds_encoder.v
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//
//  A copy of the license full text is included in
//  the distribution, please refer to it for details.

import('hdmi_clock.v')
import('differential_pair.v')
import('hdmi_differential_pairs.v')

// ----------------------------------------------------

algorithm tmds_encoder(
  input   uint8  data,
  input   uint2  ctrl,
  input   uint1  data_or_ctrl,
  output  uint10 tmds
) <autorun> {

  uint9 q_m             = 0;
  int5  dc_bias         = 0;

  // tracks 'number on ones' in input
  uint4 num_ones        := data[0,1] + data[1,1] + data[2,1] + data[3,1]
                         + data[4,1] + data[5,1] + data[6,1] + data[7,1];
  // tracks 'numbers of ones minus number of zeros' in internal byte
  int5  diff_ones_zeros := q_m[0,1] + q_m[1,1] + q_m[2,1] + q_m[3,1]
                         + q_m[4,1] + q_m[5,1] + q_m[6,1] + q_m[7,1] - 6d4;

  // XOR chain on input
  int1  xored1          := data[1,1] ^ data[0,1];
  int1  xored2          := data[2,1] ^ xored1;
  int1  xored3          := data[3,1] ^ xored2;
  int1  xored4          := data[4,1] ^ xored3;
  int1  xored5          := data[5,1] ^ xored4;
  int1  xored6          := data[6,1] ^ xored5;
  int1  xored7          := data[7,1] ^ xored6;

  // XNOR chain on input
  int1  xnored1         := ~(data[1,1] ^ data[0,1]);
  int1  xnored2         := ~(data[2,1] ^ xnored1);
  int1  xnored3         := ~(data[3,1] ^ xnored2);
  int1  xnored4         := ~(data[4,1] ^ xnored3);
  int1  xnored5         := ~(data[5,1] ^ xnored4);
  int1  xnored6         := ~(data[6,1] ^ xnored5);
  int1  xnored7         := ~(data[7,1] ^ xnored6);

  always {
    // choice of encoding scheme (xor / xnor)
    if ((num_ones > 4) || (num_ones == 4 && data[0,1] == 0)) {
      q_m = { 1b0 , {xnored7,xnored6,xnored5,xnored4,xnored3,xnored2,xnored1} , data[0,1] };
    } else {
      q_m = { 1b1 , {xored7,xored6,xored5,xored4,xored3,xored2,xored1} , data[0,1] };
    }
    if (data_or_ctrl) {
      // output data
      if (dc_bias == 0 || diff_ones_zeros == 0) {
        tmds      = {~q_m[8,1] , q_m[8,1], (q_m[8,1] ? q_m[0,8] : ~q_m[0,8])};
        if (q_m[8,1] == 0) {
          dc_bias = dc_bias - diff_ones_zeros;
        } else {
          dc_bias = dc_bias + diff_ones_zeros;
        }
      } else {
        if (  (dc_bias > 0 && diff_ones_zeros > 0)
           || (dc_bias < 0 && diff_ones_zeros < 0) ) {
          tmds    = {1b1, q_m[8,1], ~q_m[0,8] };
          dc_bias = dc_bias + q_m[8,1] - diff_ones_zeros;
        } else {
          tmds    = {1b0,q_m};
          dc_bias = dc_bias - (~q_m[8,1]) + diff_ones_zeros;
        }
      }
    } else {
      // output control
      switch (ctrl) {
        case 2b00: { tmds = 10b1101010100; }
        case 2b01: { tmds = 10b0010101011; }
        case 2b10: { tmds = 10b0101010100; }
        case 2b11: { tmds = 10b1010101011; }
      }
      dc_bias = 0;
    }
  }

}

// ----------------------------------------------------

algorithm hdmi_ddr_shifter(
  input   uint10 data_r,
  input   uint10 data_g,
  input   uint10 data_b,
  output  uint8  p_outbits,
  output  uint8  n_outbits,
) <autorun> {
  uint3  mod5    = 0;
  uint10 shift_r = 0;
  uint10 shift_g = 0;
  uint10 shift_b = 0;
  uint2  clkbits = 0;
  always {
    shift_r   = (mod5 == 0) ?  data_r : shift_r[2,8];
    shift_g   = (mod5 == 0) ?  data_g : shift_g[2,8];
    shift_b   = (mod5 == 0) ?  data_b : shift_b[2,8];
    clkbits   = (mod5[0,2] < 2) ? 2b11 : ( (mod5 > 2) ? 2b00 : 2b01 );
    p_outbits = { clkbits , shift_b[0,2] , shift_g[0,2] , shift_r[0,2] };
    n_outbits = {~clkbits ,~shift_b[0,2] ,~shift_g[0,2] ,~shift_r[0,2] };
    mod5      = (mod5 == 4) ? 0 : (mod5 + 1);
  }
}

// ----------------------------------------------------

// Expects to run at 25 MHz (hdmi pixel clock)
algorithm hdmi(
  output  uint10 x,
  output  uint10 y,
  output  uint1  active,
  output  uint1  vblank,
  output! uint4  gpdi_dp,
  output! uint4  gpdi_dn,
  input   uint8  red,
  input   uint8  green,
  input   uint8  blue,
) <autorun> {

  uint10 cntx  = 0;
  uint10 cnty  = 0;

  uint1  hsync = 0;
  uint1  vsync = 0;

  // pll for tmds
  uint1  half_hdmi_clk = uninitialized;
  hdmi_clock pll(
    clk      <: clock,              //  25 MHz
    half_hdmi_clk :> half_hdmi_clk, // 125 MHz (half 250MHz HDMI, double data rate output)
  );

  uint2  null_ctrl  = 0;
  uint2  sync_ctrl  = 0;
  uint10 tmds_red   = 0;
  uint10 tmds_green = 0;
  uint10 tmds_blue  = 0;

  uint8  latch_red   = 0;
  uint8  latch_green = 0;
  uint8  latch_blue  = 0;
  uint2  prev_sync_ctrl = 0;
  uint1  prev_active    = 0;

  // encoders
  // => we use <:: to bind values from cycle start (ignoring changes during current cycle)
  tmds_encoder tmdsR(
    data        <:: latch_red,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_red
  );
  tmds_encoder tmdsG(
    data        <:: latch_green,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_green
  );
  tmds_encoder tmdsB(
    data        <:: latch_blue,
    ctrl        <:: prev_sync_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_blue
  );

  // shifter
  uint8 crgb_pos = 0;
  uint8 crgb_neg = 0;
  hdmi_ddr_shifter shift<@half_hdmi_clk>(
    data_r  <: tmds_red,
    data_g  <: tmds_green,
    data_b  <: tmds_blue,
    p_outbits :> crgb_pos,
    n_outbits :> crgb_neg,
  );

  hdmi_differential_pairs hdmi_out(
    clock   <: half_hdmi_clk,
    pos     <: crgb_pos,
    neg     <: crgb_neg,
    out_pos :> gpdi_dp,
    out_neg :> gpdi_dn );

  always {

    // record previous state of sync_ctrl and active,
    // we receive the r,b,g value for the x,y set below with a one cycle latency
    // these are then latched for the following cycle
    // thus we have to delay corresponding sync and active two cycles
    prev_sync_ctrl = sync_ctrl;
    prev_active    = active;

    // synchronization bits
    hsync          = (cntx > 655) && (cntx < 752);
    vsync          = (cnty > 489) && (cnty < 492);
    sync_ctrl      = {vsync,hsync};
    // output active area
    active         = (cntx < 640) && (cnty < 480);
    // output vblank
    vblank         = (cnty >= 480);
    // output x,y
    x              = (cntx < 640) ? cntx : 0;
    y              = (cnty >= 480) ? 0 : cnty;
    // => we will get color result on next cycle

    // update coordinates
    cnty        = (cntx == 799) ? (cnty == 524 ? 0 : (cnty + 1)) : cnty;
    cntx        = (cntx == 799) ? 0 : (cntx + 1);

    // latch r,b,g received at this cycle, for previous coord
    // will be fed into HDMI encoders next cycle
    latch_red   = red;
    latch_green = green;
    latch_blue  = blue;

  }
}

// ----------------------------------------------------

// @sylefeb, 2020-10-08, simple UART in Silice
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

// UART config



// sender

// -> interface

group uart_out
{
  uint8 data_in = 0,
  uint1 data_in_ready = 0,
  uint1 busy = 0,
}

interface io_uart_out
{
  input  data_in,
  input  data_in_ready,
  output busy,
}

// -> algorithm

algorithm uart_sender(
  io_uart_out  io,
  output uint1 uart_tx
) <autorun> {
  
  uint10 interval      = 434;
  uint10 counter       = 0;

  uint11 transmit      = 0;

  always {    

    if (transmit > 1) {
      // keep transmitting
      if (counter == 0) {
        // keep going
        uart_tx  = transmit[0,1];
        transmit = {1b0,transmit[1,10]}; // goes to zero when done
      }
      counter = (counter == interval) ? 0 : (counter + 1);
    } else {
      // done
      uart_tx = 1;
      io.busy = 0;
      if (io.data_in_ready) {
        // start transmitting
        io.busy  = 1;
        transmit = {1b1,1b0,io.data_in,1b0};
      }
    }
  }

  uart_tx = 1;

}

// receiver

// -> interface

group uart_in
{
  uint8 data_out = 0,
  uint1 data_out_ready = 0,
}

interface io_uart_in
{
  output data_out,
  output data_out_ready,
}

// -> algorithm

algorithm uart_receiver(
  io_uart_in  io,
  input uint1 uart_rx
) <autorun> {
  
  uint10 interval      = 434;
  uint10 half_interval = 217;
  uint10 counter       = 0;

  uint4  receiving     = 0;
  uint10 received      = 0;

  uint1  latched_rx    = 0;

  always {     

    io.data_out_ready = 0; // maintain low

    if (receiving == 0) {
      if (latched_rx == 0) {
        // start receiving
        receiving = 10; // expecting 10 bits: start - data x8 - stop
        received  =  0;
        counter   = half_interval; // wait half-period
      }
    } else {
      if (counter == 0) { // right in the middle
        received  = {latched_rx,received[1,9]}; // read uart rx
        receiving = receiving - 1;
        counter   = interval;
        if (receiving == 0) {
          // done
          io.data_out       = received[1,8];
          io.data_out_ready = 1;
        }
      } else {
        counter   = counter - 1;
      }
    }

    latched_rx = uart_rx;

  }

}

// SL @sylefeb 2020-08
//
// Simple SDcard controller
// only supports SDHC/SDXC
//
// Stays in slow xfer mode
//
// Timings for   25 MHz
// Tested ok at  50 MHz
// Tested ok at 100 MHz
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

group sdcardio {
  uint32 addr_sector = 0,
  uint1  read_sector = 0,
  uint1  ready       = 0,
}

interface sdcardio_ctrl {
  input!  addr_sector,
  input!  read_sector,
  output  ready,
}

algorithm sdcard(
  output  uint1  sd_clk,
  output  uint1  sd_mosi,
  output  uint1  sd_csn,
  input   uint1  sd_miso,
  // read io
  sdcardio_ctrl  io,
  // storage
  simple_dualbram_port1 store
) <autorun> {
  
  // assert(sizeof(io.addr_sector) == 32);
  
  subroutine send(
    input  uint48   cmd,
    readwrites      sd_clk,
    writes          sd_mosi
  ) {
    uint16 count = 0;
    uint48 shift = uninitialized;
    shift        = cmd;
    while (count < 24576) { // 48 clock pulses @~400 kHz (assumes 50 MHz clock)
      if ((count&255) == 255) {      
        sd_clk  = ~sd_clk;
        if (!sd_clk) {
          sd_mosi = shift[47,1];
          shift   = {shift[0,47],1b0};
        }
      }
      count = count + 1;
    }
    sd_mosi = 1;
  }
  
  subroutine read(
    input  uint6    len,
    input  uint1    wait,
    output uint40   answer,
    input  uint8    rate,
    readwrites      sd_clk,
    writes          sd_mosi,
    reads           sd_miso
  ) {  
    uint16 count = 0;
    uint6  n     = 0;
    answer       = 40hffffffffff;
    while ( // will only stop on sd_clk == 0
      (wait && answer[len-1,1]) || ((!wait) && n < len)
    ) { // read answer
      if ((count&rate) == rate) { // swap clock
        sd_clk  = ~sd_clk;
        if (!sd_clk) {
          n       = n + 1;
          answer  = {answer[0,39],sd_miso};
        }
      }
      count = count + 1;      
    }
  }
  
  uint24 count  = 0;
  uint40 status = 0;
  uint48 cmd0   = 48b010000000000000000000000000000000000000010010101;
  uint48 cmd8   = 48b010010000000000000000000000000011010101010000111;
  uint48 cmd55  = 48b011101110000000000000000000000000000000000000001;
  uint48 acmd41 = 48b011010010100000000000000000000000000000000000001;
  uint48 cmd16  = 48b010100000000000000000000000000100000000000010101;
  uint48 cmd17  = 48b010100010000000000000000000000000000000001010101;
  //                 01ccccccaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrr1
  
  uint1  do_read_sector = 0;
  uint32 do_addr_sector = 0;
  
  store.wenable1 := 1; // writes
  
  always {
    
    if (io.read_sector) {
      do_read_sector = 1;
      do_addr_sector = io.addr_sector;
      io.ready = 0;
    }

  }
  
  sd_mosi = 1;
  sd_csn  = 1;
  sd_clk  = 0;

  // wait 2 msec (power up), @50 MHz
  count = 0;
  while (count < 100000) { count = count + 1; }
  
  // request SPI mode  
  count   = 0;
  while (count < 40960) { // 74+ clock pulses @~400 kHz (assumes 50 MHz clock)
    if ((count&255) == 255) {
      sd_clk = ~sd_clk;
    }
    count = count + 1;
  }

  sd_csn         = 0; 
  store.addr1    = 0;
  
  // init
  () <- send <- (cmd0);
  (status) <- read <- (8,1,255);
  
  () <- send <- (cmd8);
  (status) <- read <- (40,1,255);

  while (1) {
    () <- send <- (cmd55);
    (status) <- read <- (8,1,255);
    () <- send <- (acmd41);
    (status) <- read <- (8,1,255);
    if (status[0,8] == 0) {
      break;
    }
  }

  () <- send <- (cmd16);
  (status) <- read <- (8,1,255);

  io.ready = 1;  
  
  // ready to work
  while (1) {
    
    if (do_read_sector) {
      do_read_sector = 0;

      // read some!
      () <- send <- ({cmd17[40,8],do_addr_sector,cmd17[0,8]});

      (status) <- read <- (8,1,3); // response

      if (status[0,8] == 8h00) {
        (status) <- read <- (1,1,3); // start token
        
        store.addr1 = 0;
        (store.wdata1) <- read <- (8,0,3); // bytes  
        while (store.addr1 < 511) {
          (store.wdata1) <- read <- (8,0,3); // bytes          
          store.addr1 = store.addr1 + 1;
        }        
        (status) <- read <- (16,1,3); // CRC
        
        io.ready = 1;

      } else {
      
        io.ready = 1;

      }
    }
    
  }
  
}

// ------------------------- 

// -----------------------------------------------------------
// @sylefeb A SDRAM controller in Silice
//
// SDRAM interface definitions
//

// -----------------------------------------------------------

// SDRAM, r128w8 data exchange (1 byte write, 16 bytes burst read)
group sdram_r128w8_io
{
  uint26  addr       = 0,  // addressable bytes (internally deals with 16 bits wide sdram)
  uint1   rw         = 0,  // 0: read 1: write
  uint8   data_in    = 0,  //   8 bits write
  uint1   in_valid   = 0,  // pulse high to request a read/write
  uint128 data_out   = 0,  // 128 bits read (8x burst of 16 bits)
  uint1   done       = 0   // pulses high when done, both for reads and writes
}

// SDRAM, r16w16 data exchange (2 bytes write, 2 bytes read)
group sdram_r16w16_io
{
  uint26  addr       = 0,  // addressable bytes (internally deals with 16 bits wide sdram)
  uint1   rw         = 0,  // 0: read 1: write
  uint16  data_in    = 0,  //   8 bits write
  uint1   in_valid   = 0,  // pulse high to request a read/write
  uint16  data_out   = 0,  // 128 bits read (8x burst of 16 bits)
  uint1   done       = 0   // pulses high when done, both for reads and writes
}

// SDRAM, byte data exchange

group sdram_byte_io
{
  uint26  addr       = 0,
  uint1   rw         = 0,
  uint8   data_in    = 0,
  uint1   in_valid   = 0,
  uint8   data_out   = 0,
  uint1   done       = 0
}

// => NOTE how sdram_raw_io and sdram_byte_io are compatible in terms of named members
//         this allows using the same interface for both

// Interfaces

// interface for user
interface sdram_user {
  output  addr,
  output  rw,
  output  data_in,
  output  in_valid,
  input   data_out,
  input   done,
}

// interface for provider
interface sdram_provider {
  input   addr,
  input   rw,
  input   data_in,
  input   in_valid,
  output  data_out,
  output  done
}

// -----------------------------------------------------------

// -----------------------------------------------------------
// @sylefeb A SDRAM controller in Silice
//
// SDRAM controller with auto-precharge
// - expects a 16 bits wide SDRAM interface
// - read/writes 16 bits
//
// This is meant as a tutorial controller
//
// For easier compatiblity the input address is in
// byte addresss but the lower bit is ignored.
//
// Thus accesses must be aligned on 16 bits.
//
// AS4C32M16SB (e.g. some ULX3S)
// 4 banks, 8192 rows, 1024 columns, 16 bits words
// ============== addr ================================
//   25 24 | 23 -------- 11 | 10 ----- 1 | 0
//   bank  |     row        |   column   | byte (ignored)
// ====================================================

// IS42S16160G (e.g. some ULX3S)
// 4 banks, 8192 rows,  512 columns, 16 bits words
// ============== addr ================================
//   25 24 | 22 -------- 10 |  9 ----- 1 | 0
//   bank  |     row        |   column   | byte (ignored)
// ====================================================

// AS4C16M16SA (.e.g some MiSTer SDRAM)
// 4 banks, 8192 rows,  512 columns, 16 bits words
// ============== addr ================================
//   25 24 | 22 -------- 10 |  9 ----- 1 | 0
//   bank  |     row        |   column   | byte (ignored)
// ====================================================

//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//
//  A copy of the license full text is included in
//  the distribution, please refer to it for details.


import('inout16_set.v')

import('inout16_ff_ulx3s.v')
import('out1_ff_ulx3s.v')
import('out2_ff_ulx3s.v')
import('out13_ff_ulx3s.v')



// -----------------------------------------------------------

// this tiny circuitry is repeated every time we need to decompose
// the command into the pin assignments
circuitry command(
  output sdram_cs,output sdram_ras,output sdram_cas,output sdram_we,input cmd)
{
  sdram_cs  = cmd[3,1];
  sdram_ras = cmd[2,1];
  sdram_cas = cmd[1,1];
  sdram_we  = cmd[0,1];
}

// -----------------------------------------------------------

algorithm sdram_controller_autoprecharge_r16_w16(
        // sdram pins
        // => we use immediate (combinational) outputs as these are registered
        //    explicitely using dedicqted primitives when available / implemented
        output! uint1   sdram_cle,
        output! uint1   sdram_cs,
        output! uint1   sdram_cas,
        output! uint1   sdram_ras,
        output! uint1   sdram_we,
        output! uint2   sdram_dqm,
        output! uint2   sdram_ba,
        output! uint13  sdram_a,
        // data bus
        inout   uint16  sdram_dq,
        // interface
        sdram_provider sd,
) <autorun>
{

  // SDRAM commands
  uint4 CMD_UNSELECTED    = 4b1000;
  uint4 CMD_NOP           = 4b0111;
  uint4 CMD_ACTIVE        = 4b0011;
  uint4 CMD_READ          = 4b0101;
  uint4 CMD_WRITE         = 4b0100;
  uint4 CMD_TERMINATE     = 4b0110;
  uint4 CMD_PRECHARGE     = 4b0010;
  uint4 CMD_REFRESH       = 4b0001;
  uint4 CMD_LOAD_MODE_REG = 4b0000;

  // output pins are all registered
  // pay 1 in latency, gain in reduced delays and stability
  uint1   reg_sdram_cle = uninitialized;
  uint1   reg_sdram_cs  = uninitialized;
  uint1   reg_sdram_cas = uninitialized;
  uint1   reg_sdram_ras = uninitialized;
  uint1   reg_sdram_we  = uninitialized;
  uint2   reg_sdram_ba  = uninitialized;
  uint13  reg_sdram_a   = uninitialized;
  uint16  reg_dq_o      = 0;
  uint1   reg_dq_en     = 0;


  // bus input (data transits in and out through this)
  uint16 dq_i      = 0;
  // Note: the Verilator code path does not use that as Verilator does not support
  //  tri-state instead it uses three pins: dq_i, dq_o and dq_en to emulate the bus


  // implements a tri-state flip-flop on the output pins
  // this is vendor specific so defined in Verilog (inout16_ff_ulx3s.v)
  // however that is very important for stability
  inout16_ff_ulx3s ioset(
    clock           <:  clock,
    io_pin          <:> sdram_dq,
    io_write        <:: reg_dq_o,
    io_read         :>  dq_i,
    io_write_enable <:: reg_dq_en
  );
  // each pin also gets a special flip-flop on an output
  //                                           vvvvvvv output pin      vvvvv bound variable (tracking value at cycle start)
  out1_ff_ulx3s  off_sdram_cle(clock <: clock, pin :> sdram_cle, d <:: reg_sdram_cle);
  out1_ff_ulx3s  off_sdram_cs (clock <: clock, pin :> sdram_cs , d <:: reg_sdram_cs );
  out1_ff_ulx3s  off_sdram_cas(clock <: clock, pin :> sdram_cas, d <:: reg_sdram_cas);
  out1_ff_ulx3s  off_sdram_ras(clock <: clock, pin :> sdram_ras, d <:: reg_sdram_ras);
  out1_ff_ulx3s  off_sdram_we (clock <: clock, pin :> sdram_we , d <:: reg_sdram_we );
  out2_ff_ulx3s  off_sdram_ba (clock <: clock, pin :> sdram_ba , d <:: reg_sdram_ba );
  out13_ff_ulx3s off_sdram_a  (clock <: clock, pin :> sdram_a  , d <:: reg_sdram_a  );


  uint4  cmd = 7;

  uint1  work_todo   = 0;
  uint13 row         = 0;
  uint2  bank        = 0;
  uint10 col         = 0;
  uint16 data        = 0;
  uint1  do_rw       = 0;


  uint10 refresh_count = 750;

  // wait for incount cycles, incount >= 3
  subroutine wait(input uint16 incount)
  {
    // NOTE: waits 3 more than incount
    // +1 for sub entry,
    // +1 for sub exit,
    // +1 for proper loop length
    uint16 count = uninitialized;
    count = incount;
    while (count > 0) {
      count = count - 1;
    }
  }



  always { // always block is executed at every cycle before anything else
    // keep done low, pulse high when done
    sd.done = 0;
    // defaults to NOP command
    cmd = CMD_NOP;
    (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
    // track in valid here to ensure we never misss a request
    if (sd.in_valid) {
      // -> copy inputs, decompose the address in bank/row/column
      bank      = sd.addr[24, 2]; // bits 24-25
      row       = sd.addr[10, 13];
      col       = sd.addr[                      1, 9];
      data      = sd.data_in;
      do_rw     = sd.rw;
      // -> signal work to do
      work_todo = 1;
    }
  }

  // pre-init, wait before enabling clock
  reg_sdram_cle = 0;
  () <- wait <- (10100);
  reg_sdram_cle = 1;

  // init
  reg_sdram_a  = 0;
  reg_sdram_ba = 0;
  reg_dq_en    = 0;
  () <- wait <- (10100);

  // precharge all
  cmd      = CMD_PRECHARGE;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
  reg_sdram_a  = {2b0,1b1,10b0};
  () <- wait <- (0);

  // refresh 1
  cmd     = CMD_REFRESH;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
  () <- wait <- (4);

  // refresh 2
  cmd     = CMD_REFRESH;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
  () <- wait <- (4);

  // load mod reg
  cmd      = CMD_LOAD_MODE_REG;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
  reg_sdram_ba = 0;
  reg_sdram_a  = {3b000, 1b1, 2b00, 3b011/*CAS*/, 1b0, 3b000 /*no burst*/};
  () <- wait <- (0);

  reg_sdram_ba = 0;
  reg_sdram_a  = 0;
  cmd      = CMD_NOP;
  (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
  refresh_count = 750;

  // init done, start answering requests
  while (1) {

    // refresh?
    if (refresh_count == 0) {

      // refresh
      cmd           = CMD_REFRESH;
      (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
      // wait
      () <- wait <- (4);
      // -> reset count
      refresh_count = 750;

    } else {

      // decrease refresh count
      refresh_count = refresh_count - 1;

      // any pending request?
      if (work_todo) {
        work_todo = 0;

        // first, activate the row of the bank
        reg_sdram_ba = bank;
        reg_sdram_a  = row;
        cmd          = CMD_ACTIVE;
        (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
++:
++:

        // write or read?
        if (do_rw) {
          // __display("<sdram: write %x>",data);
          // write
          cmd       = CMD_WRITE;
          (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
          reg_dq_en     = 1;
          reg_sdram_a   = {2b0, 1b1/*auto-precharge*/, col};
          reg_dq_o      = data;
          // signal done
          sd.done       = 1;
++:       // wait one cycle to enforce tWR
        } else {
          // read
          cmd         = CMD_READ;
          (reg_sdram_cs,reg_sdram_ras,reg_sdram_cas,reg_sdram_we) = command(cmd);
          reg_dq_en       = 0;
          reg_sdram_a     = {2b0, 1b1/*auto-precharge*/, col};
++:       // wait CAS cycles
++:
++:
++:
++: // dq_i 2 cycles latency due to flip-flops on output and input path
++:
          // data is available
          sd.data_out = dq_i;
          sd.done     = 1;
        }

++: // enforce tRP
++:
++:

      } // work_todo
    } // refresh

  }
}

// -----------------------------------------------------------

// -----------------------------------------------------------
// @sylefeb A SDRAM controller in Silice
//
// SDRAM utilities
// - [sdram_half_speed_access] half speed bridge accross clock domains
// - [sdram_byte_readcache]    implements a byte read/write interface, caching the larger read access
// -----------------------------------------------------------

// wrapper for sdram from design running half-speed clock
// the wrapper runs full speed, the provided interface at half-speed
algorithm sdram_half_speed_access(
  sdram_provider sdh,
  sdram_user     sd
) <autorun> {

  uint1 half_clock = 0;
  uint2 done       = 0;

  sdh.done     := 0; // pulses high when ready
  sd .in_valid := 0; // pulses high when ready

  always {
    // buffer requests
    if (half_clock) { // read only on slow clock
      if (sdh.in_valid == 1) {
        // relay request
        sd.addr       = sdh.addr;
        sd.rw         = sdh.rw;
        sd.data_in    = sdh.data_in;
        sd.in_valid   = 1;
      }
    }
    // update 2-cycle 'done'
    done = done >> 1;
    // check if operation terminated
    if (sd.done == 1) {
      // done
      sdh.data_out = sd.rw ? sdh.data_out : sd.data_out; // update data_out on a read
      done         = 2b11;
    }
    // two-cycle out done
    sdh.done      = done[0,1];
    // half clock
    half_clock    = ~ half_clock;
  } // always

}

// -----------------------------------------------------------

// implements a simplified byte memory interface
algorithm sdram_byte_readcache(
  sdram_provider sdb,
  sdram_user     sdr,
) <autorun> {

  // cached reads
  sameas(sdr.data_out) cached = uninitialized;
  uint26  cached_addr         = 26h3FFFFFF;

  always {

    if (sdb.in_valid) {
      if (sdb.rw == 0) { // reading
        if (sdb.addr[4,22] == cached_addr[4,22]) {
          // in cache!
          sdb.data_out  = cached >> {sdb.addr[0,4],3b000};
          // no request
          sdr.in_valid  = 0;
          // done
          sdb.done      = 1;
        } else {
          // record addr to cache
          cached_addr   = sdb.addr;
          // issue read
          sdr.rw        = 0;
          sdr.addr      = {cached_addr[4,22],4b0000};
          sdr.in_valid  = 1;
          // not done
          sdb.done      = 0;
        }
      } else { // writing
        // issue write
        sdr.rw        = 1;
        sdr.addr      = sdb.addr;
        sdr.data_in   = sdb.data_in;
        sdr.in_valid  = 1;
        // not done
        sdb.done      = 0;
        // invalidate cache
        if (sdb.addr[4,22] == cached_addr[4,22]) {
          cached_addr = 26h3FFFFFF;
        }
      }
    } else {
      if (sdr.done) {
        // sdram is done
        if (sdr.rw == 0) {
          // -> fill cache
          cached        = sdr.data_out;
          // -> extract byte
          sdb.data_out  = cached >> {cached_addr[0,4],3b000};
        }
        // no request
        sdr.in_valid = 0;
        // done
        sdb.done     = 1;
      } else {
        // no request
        sdr.in_valid  = 0;
        // not done
        sdb.done      = 0;
      }
    }

  }

}

// -----------------------------------------------------------

// SL 2020-10-25

algorithm clean_reset(  
  output uint1 out
) <autorun> {
  uint8 counter       = 1;
  uint1 done         ::= (counter == 0);
  uint8 counter_next ::= done ? 0 : counter + 1;
  always {
    counter = counter_next;
    out     = ~ done;
  }
}



// Headers
// 7 bit colour either ALPHA (background or lower layer) or red, green, blue { Arrggbb }
bitfield colour7 {
    uint1   alpha,
    uint2   red,
    uint2   green,
    uint2   blue
}

// 6 bit colour red, green, blue { rrggbb }
bitfield colour6 {
    uint2   red,
    uint2   green,
    uint2   blue
}

// Entry in the charactermap
bitfield charactermapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint8   character
}

// Entry in the tilemap
bitfield tilemapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint5   tilenumber
}

// Vertex in the vector block
bitfield vectorentry {
    uint1   active,
    uint1   dxsign,
    uint5   dx,
    uint1   dysign,
    uint5   dy
}

// Sprite update flag
bitfield spriteupdate {
    uint1   y_act,              // 1 - kill when off screen, 0 - wrap
    uint1   x_act,              // 1 - kill when off screen, 0 - wrap
    uint1   tile_act,           // 1 - increase the tile number
    uint1   dysign,             // dy - 2's complement update for the y coordinate
    uint4   dy,
    uint1   dxsign,             // dx - 2's complement update for the x coordinate
    uint4   dx
}

// RISC-V BASE INSTRUCTION BITFIELDS
bitfield    Btype {
    uint1   immediate_bits_12,
    uint6   immediate_bits_10_5,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint4   immediate_bits_4_1,
    uint1   immediate_bits_11,
    uint7   opcode
}

bitfield    Itype {
    uint12  immediate,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    ItypeSHIFT {
    uint7   function7,
    uint5   shiftCount,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opcode
}

bitfield    Jtype {
    uint1   immediate_bits_20,
    uint10  immediate_bits_10_1,
    uint1   immediate_bits_11,
    uint8   immediate_bits_19_12,
    uint5   destReg,
    uint7   opcode
}

bitfield    Rtype {
    uint7   function7,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint5   destReg,
    uint7   opCode
}

bitfield Stype {
    uint7   immediate_bits_11_5,
    uint5   sourceReg2,
    uint5   sourceReg1,
    uint3   function3,
    uint5   immediate_bits_4_0,
    uint7   opcode
}

bitfield Utype {
    uint20  immediate_bits_31_12,
    uint5   destReg,
    uint7   opCode
}

// CSR Risc-V Access Instruction
bitfield    CSR {
    uint12  csr,
    uint5   rs1,
    uint3   function3,
    uint5   rd,
    uint7   opcode
}

// COMPRESSED Risc-V Instruction Bitfields
bitfield    CBalu {
    uint3   function3,
    uint1   ib_5,
    uint2   function2,
    uint3   rd_alt,
    uint2   logical2,
    uint3   rs2_alt,
    uint2   opcode
}
bitfield    CBalu50 {
    uint3   function3,
    uint1   ib_5,
    uint2   function2,
    uint3   rd_alt,
    uint5   ib_4_0,
    uint2   opcode
}
bitfield    CB {
    uint3   function3,
    uint1   offset_8,
    uint2   offset_4_3,
    uint3   rs1_alt,
    uint2   offset_7_6,
    uint2   offset_2_1,
    uint1   offset_5,
    uint2   opcode
}

bitfield    CI {
    uint3   function3,
    uint1   ib_5,
    uint5   rd,
    uint3   ib_4_2,
    uint2   ib_7_6,
    uint2   opcode
}
bitfield    CI50 {
    uint3   function3,
    uint1   ib_5,
    uint5   rd,
    uint5   ib_4_0,
    uint2   opcode
}
bitfield    CI94 {
    uint3   function3,
    uint1   ib_9,
    uint5   rd,
    uint1   ib_4,
    uint1   ib_6,
    uint2   ib_8_7,
    uint1   ib_5,
    uint2   opcode
}
bitfield    CIu94 {
    uint3   function3,
    uint2   ib_5_4,
    uint4   ib_9_6,
    uint1   ib_2,
    uint1   ib_3,
    uint3   rd_alt,
    uint2   opcode
}
bitfield    CIlui {
    uint3   function3,
    uint1   ib_17,
    uint5   rd,
    uint5   ib_16_12,
    uint2   opcode
}

bitfield    CJ {
    uint3   function3,
    uint1   ib_11,
    uint1   ib_4,
    uint2   ib_9_8,
    uint1   ib_10,
    uint1   ib_6,
    uint1   ib_7,
    uint3   ib_3_1,
    uint1   ib_5,
    uint2   opcode
}

bitfield    CL {
    uint3   function3,
    uint3   ib_5_3,
    uint3   rs1_alt,
    uint1   ib_2,
    uint1   ib_6,
    uint3   rd_alt,
    uint2   opcode
}

bitfield    CR {
    uint4   function4,
    uint5   rs1,
    uint5   rs2,
    uint2   opcode
}

bitfield    CS {
    uint3   function3,
    uint1   ib_5,
    uint2   ib_4_3,
    uint3   rs1_alt,
    uint1   ib_2,
    uint1   ib_6,
    uint3   rs2_alt,
    uint2   opcode
}

bitfield    CSS {
    uint3   function3,
    uint1   ib_5,
    uint3   ib_4_2,
    uint2   ib_7_6,
    uint5   rs2,
    uint2   opcode
}


// HELPER CIRCUITS

// MINIMUM OF 2 VALUES
circuitry min(
    input   value1,
    input   value2,
    output  minimum
) {
    minimum = ( value1 < value2 ) ? value1 : value2;
}

// MINIMUM OF 3 VALUES
circuitry min3(
    input   value1,
    input   value2,
    input   value3,
    output  minimum
) {
    minimum = ( value1 < value2 ) ? ( value1 < value3 ? value1 : value3 ) : ( value2 < value3 ? value2 : value3 );
}

// MAXIMUM OF 2 VALUES
circuitry max(
    input   value1,
    input   value2,
    output  maximum
) {
    maximum = ( value1 > value2 ) ? value1 : value2;
}

// MAXIMUM OF 3 VALUES
circuitry max3(
    input   value1,
    input   value2,
    input   value3,
    output  maximum
) {
    maximum = ( value1 > value2 ) ? ( value1 > value3 ? value1 : value3 ) : ( value2 > value3 ? value2 : value3 );
}

// ABSOLUTE VALUE
circuitry abs(
    input   value1,
    output  absolute
) {
    absolute = ( value1 < 0 ) ? -value1 : value1;
}

// ABSOLUTE DELTA ( DIFFERENCE )
circuitry absdelta(
    input   value1,
    input   value2,
    output  delta
) {
    delta = ( value1 < value2 ) ? value2 - value1 : value1 - value2;
}

// COPY COORDINATES
circuitry copycoordinates(
    input   x,
    input   y,
    output  x1,
    output  y1
) {
    x1 = x;
    y1 = y;
}

// SWAP COORDINATES
circuitry swapcoordinates(
    input   x,
    input   y,
    input   x1,
    input   y1,
    output  x2,
    output  y2,
    output  x3,
    output  y3
) {
    x2 = x1;
    y2 = y1;
    x3 = x;
    y3 = y;
}

// ADJUST COORDINATES BY DELTAS
circuitry deltacoordinates(
    input   x,
    input   dx,
    input   y,
    input   dy,
    output  xdx,
    output  ydy
) {
    xdx = x + dx;
    ydy = y + dy;
}

// CROP COORDINATES TO SCREEN RANGE
circuitry cropleft(
    input   x,
    output  x1
) {
    x1 = ( x < 0 ) ? 0 : x;
}
circuitry croptop(
    input   y,
    output  y1
) {
    y1 = ( y < 0 ) ? 0 : y;
}
circuitry cropright(
    input   x,
    output  x1
) {
    x1 = ( x > 639 ) ? 639 : x;
}
circuitry cropbottom(
    input   y,
    output  y1
) {
    y1 = ( y > 479 ) ? 479 : y;
}


// Multiplexed Display Includes
algorithm multiplex_display(
    input   uint10 pix_x,
    input   uint10 pix_y,
    input   uint1  pix_active,
    input   uint1  pix_vblank,
    output! uint8 pix_red,
    output! uint8 pix_green,
    output! uint8 pix_blue,

    // BACKGROUND
    input uint2 background_r,
    input uint2 background_g,
    input uint2 background_b,

    // TILEMAP
    input uint2 tilemap_r,
    input uint2 tilemap_g,
    input uint2 tilemap_b,
    input uint1 tilemap_display,

    // LOWER SPRITES
    input uint2 lower_sprites_r,
    input uint2 lower_sprites_g,
    input uint2 lower_sprites_b,
    input uint1 lower_sprites_display,

    // BITMAP
    input uint2 bitmap_r,
    input uint2 bitmap_g,
    input uint2 bitmap_b,
    input uint1 bitmap_display,

    // UPPER SPRITES
    input uint2 upper_sprites_r,
    input uint2 upper_sprites_g,
    input uint2 upper_sprites_b,
    input uint1 upper_sprites_display,

    // CHARACTER MAP
    input uint2 character_map_r,
    input uint2 character_map_g,
    input uint2 character_map_b,
    input uint1 character_map_display,

    // TERMINAL
    input uint2 terminal_r,
    input uint2 terminal_g,
    input uint2 terminal_b,
    input uint1 terminal_display
) <autorun> {
    // Output defaults to 0
    pix_red   := 0;
    pix_green := 0;
    pix_blue  := 0;

    // Draw the screen
    while (1) {
        // wait until pix_active THEN BACKGROUND -> TILEMAP -> LOWER SPRITES -> BITMAP -> UPPER SPRITES -> CHARACTER MAP -> TERMINAL
        if( pix_active ) {
            // Select the 2 bit r g or b and expand to 8 bit r g or b
            pix_red = ( terminal_display ) ? { {4{terminal_r}} } :
                        ( character_map_display ) ? { {4{character_map_r}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_r}} } :
                        ( bitmap_display ) ? { {4{bitmap_r}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_r}} } :
                        ( tilemap_display ) ? { {4{tilemap_r}} } :
                        { {4{background_r}} };
            pix_green = ( terminal_display ) ? { {4{terminal_g}} } :
                        ( character_map_display ) ? { {4{character_map_g}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_g}} } :
                        ( bitmap_display ) ? { {4{bitmap_g}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_g}} } :
                        ( tilemap_display ) ? { {4{tilemap_g}} } :
                        { {4{background_g}} };
            pix_blue = ( terminal_display ) ? { {4{terminal_b}} } :
                        ( character_map_display ) ? { {4{character_map_b}} } :
                        ( upper_sprites_display ) ? { {4{upper_sprites_b}} } :
                        ( bitmap_display ) ? { {4{bitmap_b}} } :
                        ( lower_sprites_display ) ? { {4{lower_sprites_b}} } :
                        ( tilemap_display ) ? { {4{tilemap_b}} } :
                        { {4{background_b}} };
        } // pix_active
    }
}

// Create 1hz (1 second counter, also can output the baseline 50MHz counter)
algorithm pulse1hz(
    output  uint16  counter1hz,
    input   uint1   resetCounter
) <autorun> {
    uint26  counter50mhz = 0;
    counter1hz = 0;

    while (1) {
        if( resetCounter == 1) {
            counter1hz = 0;
            counter50mhz = 0;
        } else {
            counter1hz = ( counter50mhz == 50000000 ) ? counter1hz + 1 : counter1hz;
            counter50mhz = ( counter50mhz == 50000000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// Create 1khz (1 milli-second counter)
algorithm pulse1khz(
    output  uint16  counter1khz,
    input   uint16  resetCount,
    input   uint1   resetCounter
) <autorun> {
    uint16 counter50mhz = 0;

    while (1) {
        if( resetCounter == 1 ) {
            counter1khz = resetCount;
            counter50mhz = 0;
        } else {
            counter1khz = ( counter1khz == 0 ) ? 0 : ( counter50mhz == 50000 ) ? counter1khz - 1 : counter1khz;
            counter50mhz = ( counter50mhz == 50000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// 16 bit random number generator
// Translation into Silice of LFSR_Plus.v
algorithm random(
    output  uint16  g_noise_out,
    output  uint16  u_noise_out,
    input   uint1   resetRandom
) <autorun> {
    uint16  rand_out = 0;
    uint16  rand_ff = 24b011000110111011010011101;
    uint18  rand_en_ff = 24b001100010011011101100101;
    uint16  temp_u_noise3 = 0;
    uint16  temp_u_noise2 = 0;
    uint16  temp_u_noise1 = 0;
    uint16  temp_u_noise0 = 0;
    uint16  temp_g_noise_nxt = uninitialized;

    g_noise_out := ( rand_en_ff[17,1] ) ? temp_g_noise_nxt : ( rand_en_ff[10,1] ) ? rand_out : g_noise_out;
    u_noise_out := ( rand_en_ff[17,1] ) ? rand_out : u_noise_out;

    while(1) {
        if( resetRandom ) {
            rand_en_ff = 24b001100010011011101100101;
            rand_ff = 24b011000110111011010011101;
            rand_out = 0;
            temp_u_noise3 = 0;
            temp_u_noise2 = 0;
            temp_u_noise1 = 0;
            temp_u_noise0 = 0;
            g_noise_out = 0;
            u_noise_out = 0;
        } else {
            rand_en_ff = {(rand_en_ff[7,1] ^ rand_en_ff[0,1]) , rand_en_ff[1,17]};
            rand_ff = { ( rand_ff[5,1] ^ rand_ff[3,1] ^ rand_ff[2,1] ^ rand_ff[0,1]) , rand_ff[1,15] };
            rand_out = rand_ff;
            temp_u_noise3 = { rand_out[15,1], rand_out[15,1], rand_out[2,13] };
            temp_u_noise2 = temp_u_noise3;
            temp_u_noise1 = temp_u_noise2;
            temp_u_noise0 = temp_u_noise1;
            temp_g_noise_nxt = ( rand_en_ff[9,1] ) ? __signed(temp_u_noise3) + __signed(temp_u_noise2) + __signed(temp_u_noise1) + __signed(temp_u_noise0) + __signed(g_noise_out) :
                                                    __signed(temp_u_noise3) + __signed(temp_u_noise2) + __signed(temp_u_noise1) + __signed(temp_u_noise0);
        }
    }
}

algorithm terminal(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   terminal_display,

    input   uint8   terminal_character,
    input   uint1   terminal_write,
    input   uint1   showterminal,
    input   uint1   showcursor,
    input   uint1   timer1hz,
    output  uint1   terminal_active
) <autorun> {
    // Character ROM 8x8 x 256
    brom uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // 80 x 4 character buffer for the input/output terminal
    simple_dualport_bram uint8 terminal[640] = uninitialized;
    simple_dualport_bram uint8 terminal_copy[640] = uninitialized;

    // Initial cursor position in the terminal, bottom left
    uint7 terminal_x = 0;
    uint3 terminal_y = 7;

    // Character position on the terminal x 0-79, y 0-7 * 80 ( fetch it one pixel ahead of the actual x pixel, so it is always ready )
    uint7 xterminalpos := ( pix_active ? pix_x + 2 : 0 ) >> 3;
    uint10 yterminalpos := (( pix_vblank ? 0 : pix_y - 416 ) >> 3) * 80;

    // Determine if cursor, and if cursor is flashing
    uint1 is_cursor := ( xterminalpos == terminal_x ) && ( ( ( pix_y - 416) >> 3 ) == terminal_y );

    // Derive the x and y coordinate within the current 8x8 terminal character block x 0-7, y 0-7
    uint3 xinterminal := (pix_x) & 7;
    uint3 yinterminal := (pix_y) & 7;

    // Derive the actual pixel in the current terminal
    uint1 terminalpixel := characterGenerator8x8.rdata[7 - xinterminal,1];

    // Terminal active (scroll) flag and temporary storage for scrolling
    uint10 terminal_scroll = 0;
    uint10 terminal_scroll_character = 0;

    // Setup the reading of the terminal memory
    terminal.addr0 := xterminalpos + yterminalpos;

    // Setup the writing to the terminal memory
    terminal.wenable1 := 1;
    terminal_copy.wenable1 := 1;

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr :=  terminal.rdata0 * 8 + yinterminal;

    // Default to transparent and active pixels always blue
    terminal_display := pix_active && showterminal && (pix_y > 415);
    pix_red := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_green := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_blue := 3;

    // Render the terminal
    while(1) {
        if( terminal_write ) {
            // Display character
            switch( terminal_character ) {
                case 8: {
                    // BACKSPACE, move back one character
                    if( terminal_x != 0 ) {
                        terminal_x = terminal_x - 1;
                        terminal.addr1 = terminal_x + terminal_y * 80;
                        terminal.wdata1 = 0;
                        terminal_copy.addr1 = terminal_x + terminal_y * 80;
                        terminal_copy.wdata1 = 0;
                    }
                }
                case 10: {
                    // LINE FEED, scroll
                    terminal_active = 1;
                }
                case 13: {
                    // CARRIAGE RETURN
                    terminal_x = 0;
                }
                default: {
                    // Display character
                    terminal.addr1 = terminal_x + terminal_y * 80;
                    terminal.wdata1 = terminal_character;
                    terminal_copy.addr1 = terminal_x + terminal_y * 80;
                    terminal_copy.wdata1 = terminal_character;
                    terminal_active = ( terminal_x == 79 ) ? 1 : 0;
                    terminal_x = ( terminal_x == 79 ) ? 0 : terminal_x + 1;
                }
            }
        } else {
            if( terminal_active ) {
                // SCROLL
                terminal_scroll = 0;
                ++:
                while( terminal_scroll < 560 ) {
                    // Retrieve character on the next line
                    terminal_copy.addr0 = terminal_scroll + 80;
                    ++:
                    terminal_scroll_character = terminal_copy.rdata0;
                    ++:
                    // Write retrieved character
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = terminal_scroll_character;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = terminal_scroll_character;

                    //++:
                    terminal_scroll = terminal_scroll + 1;
                }

                // BLANK LAST LINE
                while( terminal_scroll < 640 ) {
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = 0;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = 0;

                    terminal_scroll = terminal_scroll + 1;
                }

                terminal_active = 0;
            }
        }
    }
}

algorithm character_map(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   character_map_display,

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint5   tpu_y,
    input   uint8   tpu_character,
    input   uint6   tpu_foreground,
    input   uint7   tpu_background,
    input   uint3   tpu_write,

    output  uint1   tpu_active
) <autorun> {
    // Character ROM 8x16
    brom uint8 characterGenerator8x16[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h81, 8ha5, 8h81, 8h81, 8hbd, 8h99, 8h81, 8h81, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8hff, 8hdb, 8hff, 8hff, 8hc3, 8he7, 8hff, 8hff, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h6c, 8hfe, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8he7, 8he7, 8he7, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h7e, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h1e, 8h0e, 8h1a, 8h32, 8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h33, 8h3f, 8h30, 8h30, 8h30, 8h30, 8h70, 8hf0, 8he0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8h63, 8h7f, 8h63, 8h63, 8h63, 8h63, 8h67, 8he7, 8he6, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8hdb, 8h3c, 8he7, 8h3c, 8hdb, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h80, 8hc0, 8he0, 8hf0, 8hf8, 8hfe, 8hf8, 8hf0, 8he0, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h02, 8h06, 8h0e, 8h1e, 8h3e, 8hfe, 8h3e, 8h1e, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8hdb, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h1b, 8h1b, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h7c, 8hc6, 8h60, 8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h28, 8h6c, 8hfe, 8h6c, 8h28, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h38, 8h7c, 8h7c, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8h7c, 8h7c, 8h38, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h24, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h7c, 8hc6, 8hc2, 8hc0, 8h7c, 8h06, 8h06, 8h86, 8hc6, 8h7c, 8h18, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hc2, 8hc6, 8h0c, 8h18, 8h30, 8h60, 8hc6, 8h86, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h30, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h18, 8h0c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h18, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h02, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hd6, 8hd6, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h38, 8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h06, 8h3c, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h0c, 8h0c, 8h1e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hfc, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h60, 8hc0, 8hc0, 8hfc, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h06, 8h06, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h06, 8h06, 8h0c, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h0c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hde, 8hde, 8hde, 8hdc, 8hc0, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h66, 8h66, 8h66, 8h66, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf8, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hde, 8hc6, 8hc6, 8h66, 8h3a, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he6, 8h66, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf0, 8h60, 8h60, 8h60, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hde, 8h7c, 8h0c, 8h0e, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h60, 8h38, 8h0c, 8h06, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h7e, 8h5a, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8hee, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8h6c, 8h7c, 8h38, 8h38, 8h7c, 8h6c, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h86, 8h0c, 8h18, 8h30, 8h60, 8hc2, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h80, 8hc0, 8he0, 8h70, 8h38, 8h1c, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h78, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc0, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h0c, 8h0c, 8h3c, 8h6c, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h6c, 8h76, 8h66, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h06, 8h06, 8h00, 8h0e, 8h06, 8h06, 8h06, 8h06, 8h06, 8h06, 8h66, 8h66, 8h3c, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hec, 8hfe, 8hd6, 8hd6, 8hd6, 8hd6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8h0c, 8h1e, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8h60, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h30, 8h30, 8h36, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8h6c, 8h38, 8h38, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8hf8, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hcc, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h18, 8h18, 8h18, 8h70, 8h18, 8h18, 8h18, 8h18, 8h0e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h70, 8h18, 8h18, 8h18, 8h0e, 8h18, 8h18, 8h18, 8h18, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h0c, 8h06, 8h7c, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h38, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h60, 8h60, 8h66, 8h3c, 8h0c, 8h06, 8h3c, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h66, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h38, 8h6c, 8h38, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h00, 8hfe, 8h66, 8h60, 8h7c, 8h60, 8h60, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8h76, 8h36, 8h7e, 8hd8, 8hd8, 8h6e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3e, 8h6c, 8hcc, 8hcc, 8hfe, 8hcc, 8hcc, 8hcc, 8hcc, 8hce, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8h78, 8h00,
    8h00, 8hc6, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h18, 8h3c, 8h66, 8h60, 8h60, 8h60, 8h66, 8h3c, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8he6, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hf8, 8hcc, 8hcc, 8hf8, 8hc4, 8hcc, 8hde, 8hcc, 8hcc, 8hcc, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0e, 8h1b, 8h18, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8h70, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h76, 8hdc, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h30, 8h00, 8h30, 8h30, 8h60, 8hc0, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8h06, 8h06, 8h06, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h60, 8hdc, 8h86, 8h0c, 8h18, 8h3e, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hce, 8h9e, 8h3e, 8h06, 8h06, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h36, 8h6c, 8hd8, 8h6c, 8h36, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hd8, 8h6c, 8h36, 8h6c, 8hd8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8hd8, 8hd8, 8hd8, 8hdc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8hd8, 8hcc, 8hc6, 8hc6, 8hc6, 8hcc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8hc6, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfe, 8hc6, 8h60, 8h30, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7e, 8h18, 8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h6c, 8h6c, 8h6c, 8hee, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h30, 8h18, 8h0c, 8h3e, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hdb, 8hdb, 8hdb, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h03, 8h06, 8h7e, 8hdb, 8hdb, 8hf3, 8h7e, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h30, 8h60, 8h60, 8h7c, 8h60, 8h60, 8h60, 8h30, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h7e, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0f, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h6c, 8h3c, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hd8, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h70, 8hd8, 8h30, 8h60, 8hc8, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00


    };

    // 80 x 30 character buffer
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint21 charactermap[2400] = { 21b100000000000000000000, pad(21b100000000000000000000) };

    // Character position on the screen x 0-79, y 0-29 * 80 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    uint8 xcharacterpos := ( pix_active ?  pix_x + 2 : 0 ) >> 3;
    uint12 ycharacterpos := (( pix_vblank ? 0 : pix_y ) >> 4) * 80;

    // Derive the x and y coordinate within the current 8x16 character block x 0-7, y 0-15
    uint3 xincharacter := (pix_x) & 7;
    uint4 yincharacter := (pix_y) & 15;

    // Derive the actual pixel in the current character
    uint1 characterpixel := characterGenerator8x16.rdata[7 - xincharacter,1];

    // TPU character position
    uint7 tpu_active_x = 0;
    uint5 tpu_active_y = 0;

    // CS Counter
    uint12  tpu_cs_addr = uninitialized;
    uint12  tpu_count = uninitialized;
    uint12  tpu_max_count = uninitialized;

    // Set up reading of the charactermap
    charactermap.addr0 := xcharacterpos + ycharacterpos;

    // BRAM write access for the TPU
    charactermap.wenable1 := 1;

    // Setup the reading of the characterGenerator8x16 ROM
    characterGenerator8x16.addr :=  charactermapentry(charactermap.rdata0).character * 16 + yincharacter;

    // RENDER - Default to transparent
    character_map_display := pix_active && (( characterpixel ) || ( ~charactermapentry(charactermap.rdata0).alpha ));
    pix_red := characterpixel ? charactermap.rdata0[12,2] : charactermap.rdata0[18,2];
    pix_green := characterpixel ? charactermap.rdata0[10,2] : charactermap.rdata0[16,2];
    pix_blue := characterpixel ? charactermap.rdata0[8,2] : charactermap.rdata0[14,2];

    // Default to 0,0 and transparent
    charactermap.addr1 = 0; charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };

    while(1) {
        switch( tpu_active ) {
            case 0: {
                switch( tpu_write ) {
                    case 1: {
                        // Set cursor position
                        ( tpu_active_x, tpu_active_y ) = copycoordinates( tpu_x, tpu_y );
                    }
                    case 2: {
                        // Write character,foreground, background to current cursor position and move onto next character position
                        charactermap.addr1 = tpu_active_x + tpu_active_y * 80;
                        charactermap.wdata1 = { tpu_background, tpu_foreground, tpu_character };

                        tpu_active_y = ( tpu_active_x == 79 ) ? ( tpu_active_y == 29 ) ? 0 : tpu_active_y + 1 : tpu_active_y;
                        tpu_active_x = ( tpu_active_x == 79 ) ? 0 : tpu_active_x + 1;
                    }
                    case 3: {
                        // Start tpucs
                        tpu_active_x = 0;
                        tpu_active_y = 0;
                        tpu_active = 1;
                        tpu_cs_addr = 0;
                        tpu_max_count = 2400;
                    }
                    case 4: {
                        // Start tpu_clearline
                        tpu_active_x = 0;
                        tpu_active_y = tpu_y;
                        tpu_active = 1;
                        tpu_cs_addr = tpu_y * 80;
                        tpu_max_count = tpu_y * 80 + 80;
                    }
                }
            }

            // TPU WIPE - WHOLE OR PARTIAL SCREEN
            case 1: {
                while( tpu_cs_addr < tpu_max_count ) {
                    charactermap.addr1 = tpu_cs_addr;
                    tpu_cs_addr = tpu_cs_addr + 1;
                    charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };
                }
                tpu_active = 0;
            }
        }
    }
}

algorithm bitmap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   bitmap_display,

    // Hardware scrolling
    input   uint3   bitmap_write_offset,
    output  uint10  x_offset,
    output  uint10  y_offset,

    // Pixel reader
    input   int16   bitmap_x_read,
    input   int16   bitmap_y_read,
    output  uint7   bitmap_colour_read,

    simple_dualbram_port0 bitmap
) <autorun> {
    // Pixel x and y fetching ( adjusting for offset )
    uint10  x_plus_one := ( pix_x + x_offset + 1 ) > 639 ? ( pix_x + x_offset + 1 ) - 639 : ( pix_x + x_offset + 1 );
    uint10  y_line := pix_vblank ? y_offset : ( ( pix_y + y_offset ) > 479 ? ( pix_y + y_offset ) - 479 : ( pix_y + y_offset ) );
    uint10  x_pixel := pix_active ? x_plus_one : x_offset;

    // Pixel being read?
    bitmap_colour_read := ( pix_x == bitmap_x_read ) && ( pix_y == bitmap_y_read ) ? bitmap.rdata0 : bitmap_colour_read;

    // Setup the address in the bitmap for the pixel being rendered
    // Use pre-fetching of the next pixel ready for the next cycle
    bitmap.addr0 := x_pixel + ( y_line * 640 );

    // RENDER - Default to transparent
    bitmap_display := pix_active && ~bitmap.rdata0[6,1];
    pix_red := bitmap.rdata0[4,2];
    pix_green := bitmap.rdata0[2,2];
    pix_blue := bitmap.rdata0[0,2];

    while(1) {
        switch( bitmap_write_offset ) {
            case 1: {
                x_offset = ( x_offset == 639 ) ? 0 : x_offset + 1;
            }
            case 2: {
                y_offset = ( y_offset == 479 ) ? 0 : y_offset + 1;
            }
            case 3: {
                x_offset = ( x_offset == 0 ) ? 639 : x_offset - 1;
            }
            case 4: {
                y_offset = ( y_offset == 0 ) ? 479 : y_offset - 1;
            }
            case 5: {
                x_offset = 0;
                y_offset = 0;
            }
        }
   }
}

algorithm bitmapwriter (
    // GPU to SET and GET pixels
    input   int11   bitmap_x_write,
    input   int11   bitmap_y_write,
    input   uint7   bitmap_colour_write,
    input   uint1   bitmap_write,

    input   uint10  x_offset,
    input   uint10  y_offset,

    simple_dualbram_port1 bitmap
) <autorun> {
    // Pixel x and y for writing ( adjusting for offset )
    uint10  x_write_pixel := ( bitmap_x_write + x_offset ) > 639 ? ( bitmap_x_write + x_offset ) - 639 : ( bitmap_x_write + x_offset );
    uint10  y_write_pixel := ( bitmap_y_write + y_offset ) > 479 ? ( bitmap_y_write + y_offset ) - 479 : ( bitmap_y_write + y_offset );

    // Write in range?
    uint1 write_pixel := (bitmap_x_write >= 0 ) && (bitmap_x_write < 640) && (bitmap_y_write >= 0) && (bitmap_y_write <= 479) && bitmap_write;

    // Bitmap write access for the GPU - Only enable when x and y are in range
    bitmap.wenable1 := 1;

    while(1) {
        if( write_pixel == 1 ) {
            bitmap.addr1 = x_write_pixel + y_write_pixel * 640;
            bitmap.wdata1 = bitmap_colour_write;
        }
    }
}

algorithm gpu(
    // GPU to SET and GET pixels
    output! int11 bitmap_x_write,
    output! int11 bitmap_y_write,
    output! uint7 bitmap_colour_write,
    output! uint1 bitmap_write,

    // From j1eforth
    input   int11 gpu_x,
    input   int11 gpu_y,
    input   uint8 gpu_colour,
    input   int11 gpu_param0,
    input   int11 gpu_param1,
    input   int11 gpu_param2,
    input   int11 gpu_param3,
    input   uint4 gpu_write,

    // For setting blit1 tile bitmaps
    input   uint5   blit1_writer_tile,
    input   uint4   blit1_writer_line,
    input   uint16  blit1_writer_bitmap,

    // VECTOR BLOCK
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,
    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   gpu_active,
    output  uint1   vector_block_active
) <autorun> {
    // 32 x 16 x 16 1 bit tilemap for blit1tilemap
    simple_dualport_bram uint16 blit1tilemap[ 512 ] = uninitialized;

    // Character ROM 8x8 x 256 for character blitter
    simple_dualport_bram uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // GPU COLOUR
    uint7 gpu_active_colour = uninitialized;

    // GPU <-> VECTOR DRAWER Communication
    int11 v_gpu_x = uninitialised;
    int11 v_gpu_y = uninitialised;
    int11 v_gpu_param0 = uninitialised;
    int11 v_gpu_param1 = uninitialised;
    uint1 v_gpu_write = uninitialised;

    // VECTOR DRAWER UNIT
    vectors vector_drawer (
        vector_block_number <: vector_block_number,
        vector_block_xc <: vector_block_xc,
        vector_block_yc <: vector_block_yc,
        draw_vector <: draw_vector,
        vertices_writer_block <: vertices_writer_block,
        vertices_writer_vertex <: vertices_writer_vertex,
        vertices_writer_xdelta <: vertices_writer_xdelta,
        vertices_writer_ydelta <: vertices_writer_ydelta,
        vertices_writer_active <: vertices_writer_active,

        vector_block_active :> vector_block_active,

        gpu_x :> v_gpu_x,
        gpu_y :> v_gpu_y,
        gpu_param0 :> v_gpu_param0,
        gpu_param1 :> v_gpu_param1,
        gpu_write :> v_gpu_write,
        gpu_active <: gpu_active
    );

    // GPU SUBUNITS
    rectangle GPUrectangle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1
    );
    line GPUline(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1
    );
    circle GPUcircle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0
    );
    disc GPUdisc(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0
    );
    triangle GPUtriangle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1,
        param2 <: gpu_param2,
        param3 <: gpu_param3,
    );
    blit GPUblit(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1,
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8
    );

    // DRAW A LINE FROM VECTOR BLOCK OUTPUT
    line VECTORline(
        x <: v_gpu_x,
        y <: v_gpu_y,
        param0 <: v_gpu_param0,
        param1 <: v_gpu_param1
    );

    // blit1tilemap write access for the GPU to load tilemaps
    blit1tilemap.addr1 := blit1_writer_tile * 16 + blit1_writer_line;
    blit1tilemap.wdata1 := blit1_writer_bitmap;
    blit1tilemap.wenable1 := 1;

    // CONTROLS FOR BITMAP PIXEL WRITER
    bitmap_write := 0;
    bitmap_colour_write := gpu_active_colour;

    // CONTROLS FOR GPU SUBUNITS
    GPUrectangle.start := 0;
    GPUline.start := 0;
    GPUcircle.start := 0;
    GPUdisc.start := 0;
    GPUtriangle.start := 0;
    GPUblit.start := 0;
    VECTORline.start := 0;

    while(1) {
        if( v_gpu_write ) {
            // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1) from VECTOR BLOCK
            gpu_active_colour = vector_block_colour;
            gpu_active = 1;
            VECTORline.start = 1;
            while( VECTORline.busy ) {
                bitmap_x_write = VECTORline.bitmap_x_write;
                bitmap_y_write = VECTORline.bitmap_y_write;
                bitmap_write = VECTORline.bitmap_write;
            }
            gpu_active = 0;
        } else {
            gpu_active_colour = gpu_colour;
            switch( gpu_write ) {
                case 1: {
                    // SET PIXEL (X,Y)
                    // NO GPU ACTIVATION
                    bitmap_x_write = gpu_x;
                    bitmap_y_write = gpu_y;
                    bitmap_write = 1;
                }

                case 2: {
                    // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1)
                    gpu_active = 1;
                    GPUline.start = 1;
                    while( GPUline.busy ) {
                        bitmap_x_write = GPUline.bitmap_x_write;
                        bitmap_y_write = GPUline.bitmap_y_write;
                        bitmap_write = GPUline.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 3: {
                    // DRAW RECTANGLE FROM (X,Y) to (PARAM0,PARAM1)
                    gpu_active = 1;
                    GPUrectangle.start = 1;
                    while( GPUrectangle.busy ) {
                        bitmap_x_write = GPUrectangle.bitmap_x_write;
                        bitmap_y_write = GPUrectangle.bitmap_y_write;
                        bitmap_write = GPUrectangle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 4: {
                    // DRAW CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    gpu_active = 1;
                    GPUcircle.start = 1;
                    while( GPUcircle.busy ) {
                        bitmap_x_write = GPUcircle.bitmap_x_write;
                        bitmap_y_write = GPUcircle.bitmap_y_write;
                        bitmap_write = GPUcircle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 5: {
                    // DRAW FILLED CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    gpu_active = 1;
                    GPUdisc.start = 1;
                    while( GPUdisc.busy ) {
                        bitmap_x_write = GPUdisc.bitmap_x_write;
                        bitmap_y_write = GPUdisc.bitmap_y_write;
                        bitmap_write = GPUdisc.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 6: {
                    // DRAW FILLED TRIANGLE WITH VERTICES (X,Y) (PARAM0,PARAM1) (PARAM2,PARAM3)
                    gpu_active = 1;
                    GPUtriangle.start = 1;
                    while( GPUtriangle.busy ) {
                        bitmap_x_write = GPUtriangle.bitmap_x_write;
                        bitmap_y_write = GPUtriangle.bitmap_y_write;
                        bitmap_write = GPUtriangle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 7: {
                    // BLIT 16 x 16 TILE PARAM0 TO (X,Y)
                    gpu_active = 1;
                    GPUblit.tilecharacter = 1;
                    GPUblit.start = 1;
                    while( GPUblit.busy ) {
                        bitmap_x_write = GPUblit.bitmap_x_write;
                        bitmap_y_write = GPUblit.bitmap_y_write;
                        bitmap_write = GPUblit.bitmap_write;
                    }
                    gpu_active = 0;
                }


                case 8: {
                    // BLIT 8 x 8 CHARACTER PARAM0 TO (X,Y) as 8 x 8
                    gpu_active = 1;
                    GPUblit.tilecharacter = 0;
                    GPUblit.start = 1;
                    while( GPUblit.busy ) {
                        bitmap_x_write = GPUblit.bitmap_x_write;
                        bitmap_y_write = GPUblit.bitmap_y_write;
                        bitmap_write = GPUblit.bitmap_write;
                    }
                    gpu_active = 0;
                }

                default: { gpu_active = 0; }
            }
        }
    }
}

// RECTANGLE - OUTPUT PIXELS TO DRAW A RECTANGLE
algorithm rectangle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,

    output!  uint11  bitmap_x_write,
    output!  uint11  bitmap_y_write,
    output!  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_x1 = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_max_y = uninitialized;

    uint1   active = 0;
    busy := start ? 1 : active;

    bitmap_x_write := gpu_active_x;
    bitmap_y_write := gpu_active_y;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a rectangle from x,y to param0,param1 in colour
            // Ensures that works left to right, top to bottom, crop to screen edges
            ( gpu_active_x ) = min( x, param0 );
            ( gpu_active_y ) = min( y, param1 );
            ( gpu_max_x ) = max( x, param0 );
            ( gpu_max_y ) = max( y, param1 );
            ++:
            ( gpu_active_x ) = cropleft( gpu_active_x );
            ( gpu_x1 ) = cropleft( gpu_active_x );
            ( gpu_active_y ) = croptop( gpu_active_y );
            ( gpu_max_x ) = cropright( gpu_max_x );
            ( gpu_max_y ) = cropbottom( gpu_max_y );
            ++:
            while( gpu_active_y <= gpu_max_y ) {
                while( gpu_active_x <= gpu_max_x ) {
                    bitmap_write = 1;
                    gpu_active_x = gpu_active_x + 1;
                }
                gpu_active_x = gpu_x1;
                gpu_active_y = gpu_active_y + 1;
            }
            active = 0;
        }
    }
}

// LINE - OUTPUT PIXELS TO DRAW A LINE
algorithm line (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,

    output!  uint11  bitmap_x_write,
    output!  uint11  bitmap_y_write,
    output!  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_dx = uninitialized;
    int11   gpu_dy = uninitialized;
    int11   gpu_sy = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_max_y = uninitialized;
    int11   gpu_numerator = uninitialized;
    int11   gpu_numerator2 = uninitialized;
    int11   gpu_count = uninitialized;
    int11   gpu_max_count = uninitialized;

    uint1   active = 0;
    busy := start ? 1 : active;

    bitmap_x_write := gpu_active_x;
    bitmap_y_write := gpu_active_y;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a line from x,y to param0,param1 in colour
            // Ensure LEFT to RIGHT
            ( gpu_active_x ) = min( x, param0 );
            gpu_active_y = ( x < param0 ) ? y : param1;
            // Determine if moving UP or DOWN
            gpu_sy = ( x < param0 ) ? ( ( y < param1 ) ? 1 : -1 ) : ( ( y < param1 ) ? -1 : 1 );
            // Absolute DELTAs
            ( gpu_dx ) = absdelta( x, param0 );
            ( gpu_dy ) = absdelta( y, param1 );
            ++:
            gpu_count = 0;
            gpu_numerator = ( gpu_dx > gpu_dy ) ? ( gpu_dx >> 1 ) : -( gpu_dy >> 1 );
            ( gpu_max_count ) = max( gpu_dx, gpu_dy );
            ++:
            while( gpu_count <= gpu_max_count ) {
                bitmap_write = 1;
                gpu_numerator2 = gpu_numerator;
                ++:
                if( gpu_numerator2 > (-gpu_dx) ) {
                    gpu_numerator = gpu_numerator - gpu_dy;
                    gpu_active_x = gpu_active_x + 1;
                }
                ++:
                if( gpu_numerator2 < gpu_dy ) {
                    gpu_numerator = gpu_numerator + gpu_dx;
                    gpu_active_y = gpu_active_y + gpu_sy;
                }
                gpu_count = gpu_count + 1;
            }
            active = 0;
        }
    }
}

// CIRCLE - OUTPUT PIXELS TO DRAW AN OUTLINE CIRCLE
algorithm circle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_xc = uninitialized;
    int11   gpu_yc = uninitialized;
    int11   gpu_numerator = uninitialized;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a circle centre x,y or radius param0 in colour
            gpu_active_x = 0;
            ( gpu_active_y ) = abs( param0 );
            ( gpu_xc, gpu_yc ) = copycoordinates( x, y );
            ++:
            gpu_numerator = 3 - ( 2 * gpu_active_y );
            ++:
            while( gpu_active_y >= gpu_active_x ) {
                bitmap_x_write = gpu_xc + gpu_active_x;
                bitmap_y_write = gpu_yc + gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc - gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc - gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc + gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc + gpu_active_y;
                bitmap_y_write = gpu_yc + gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc - gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc - gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc + gpu_active_x;
                bitmap_write = 1;

                gpu_active_x = gpu_active_x + 1;
                if( gpu_numerator > 0 ) {
                    gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                    gpu_active_y = gpu_active_y - 1;
                } else {
                    gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                }
            }
            active = 0;
        }
    }
}

//  DISC - OUTPUT PIXELS TO DRAW A FILLED CIRCLE
algorithm disc (
    input   int11   x,
    input   int11   y,
    input   int11   param0,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_xc = uninitialized;
    int11   gpu_yc = uninitialized;
    int11   gpu_numerator = uninitialized;
    int11   gpu_count = uninitialised;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a filled circle centre x,y or radius param0 in colour
            // Minimum radius is 4, radius is always positive
            gpu_active_x = 0;
            ( gpu_active_y ) = abs( param0 );
            ( gpu_xc, gpu_yc ) = copycoordinates( x, y );
            ++:
            gpu_active_y = ( gpu_active_y < 4 ) ? 4 : gpu_active_y;
            ++:
            gpu_count = gpu_active_y;
            gpu_numerator = 3 - ( 2 * gpu_active_y );
            ++:
            while( gpu_active_y >= gpu_active_x ) {
                while( gpu_count != 0 ) {
                    bitmap_x_write = gpu_xc + gpu_active_x;
                    bitmap_y_write = gpu_yc + gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc - gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc - gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc + gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc + gpu_count;
                    bitmap_y_write = gpu_yc + gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc - gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc - gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc + gpu_active_x;
                    bitmap_write = 1;

                    gpu_count = gpu_count - 1;
                }
                gpu_active_x = gpu_active_x + 1;
                if( gpu_numerator > 0 ) {
                    gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                    gpu_active_y = gpu_active_y - 1;
                    gpu_count = gpu_active_y - 1;
                } else {
                    gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                    gpu_count = gpu_active_y;
                }
            }
            bitmap_x_write = gpu_xc;
            bitmap_y_write = gpu_yc;
            bitmap_write = 1;
            active = 0;
        }
    }
}

//  TRIANGLE - OUTPUT PIXELS TO DRAW A FILLED TRIANGLE
algorithm triangle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    input   int11   param2,
    input   int11   param3,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    // VERTEX COORDINATES
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_x1 = uninitialized;
    int11   gpu_y1 = uninitialized;
    int11   gpu_x2 = uninitialized;
    int11   gpu_y2 = uninitialized;

    // BOUNDING BOX
    int11   gpu_min_x = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_min_y = uninitialized;
    int11   gpu_max_y = uninitialized;

    // WORK COORDINATES
    int11   gpu_sx = uninitialized;
    int11   gpu_sy = uninitialized;

    // WORK DIRECTION ( == 0 left, == 1 right )
    uint1   gpu_dx = uninitialized;

    // Filled triangle calculations
    // Is the point sx,sy inside the triangle given by active_x,active_y x1,y1 x2,y2?
    uint1   w0 = uninitialized;
    uint1   w1 = uninitialized;
    uint1   w2 = uninitialized;
    uint1   inTriangle := w0 && w1 && w2;
    uint1   beenInTriangle = uninitialized;

    uint1   active = 0;
    busy := start ? 1 : active;

    // PIXEL TO OUTPUT
    bitmap_x_write := gpu_sx;
    bitmap_y_write := gpu_sy;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a filled triangle x,y param0, param1, param2, param3
            ( gpu_active_x, gpu_active_y ) = copycoordinates( x, y);
            ( gpu_x1, gpu_y1 ) = copycoordinates( param0, param1 );
            ( gpu_x2, gpu_y2 ) = copycoordinates( param2, param3 );
            ++:
            // Find minimum and maximum of x, x1, x2, y, y1 and y2 for the bounding box
            ( gpu_min_x ) = min3( gpu_active_x, gpu_x1, gpu_x2 );
            ( gpu_min_y ) = min3( gpu_active_y, gpu_y1, gpu_y2 );
            ( gpu_max_x ) = max3( gpu_active_x, gpu_x1, gpu_x2 );
            ( gpu_max_y ) = max3( gpu_active_y, gpu_y1, gpu_y2 );
            ++:
            // Clip to the screen edge
            ( gpu_min_x ) = cropleft( gpu_min_x );
            ( gpu_max_x ) = cropright( gpu_max_x );
            ( gpu_min_y ) = croptop( gpu_min_y );
            ( gpu_max_y ) = cropbottom( gpu_max_y );
            ++:
            // Find the point closest to the top of the screen ( put into gpu_active_x and gpu_active_y )
            if( gpu_y1 < gpu_active_y ) {
                ( gpu_active_x, gpu_active_y, gpu_x1, gpu_y1 ) = swapcoordinates( gpu_active_x, gpu_active_y, gpu_x1, gpu_y1 );
            }
            ++:
            if( gpu_y2 < gpu_active_y ) {
                ( gpu_active_x, gpu_active_y, gpu_x2, gpu_y2 ) = swapcoordinates( gpu_active_x, gpu_active_y, gpu_x2, gpu_y2 );
            }
            ++:
            // Point order is top of screen then down to the right
            if( gpu_x1 < gpu_x2 ) {
                ( gpu_x1, gpu_y1, gpu_x2, gpu_y2 ) = swapcoordinates( gpu_x1, gpu_y1, gpu_x2, gpu_y2 );
            }
            ++:
            // Start at the top left
            ( gpu_sx, gpu_sy ) = copycoordinates( gpu_min_x, gpu_min_y );
            gpu_dx = 1;
            beenInTriangle = 0;
            ++:
            while( gpu_sy <= gpu_max_y ) {
                // Edge calculations to determine if inside the triangle - converted to DSP blocks
                w0 = (( gpu_x2 - gpu_x1 ) * ( gpu_sy - gpu_y1 ) - ( gpu_y2 - gpu_y1 ) * ( gpu_sx - gpu_x1 )) >= 0;
                w1 = (( gpu_active_x - gpu_x2 ) * ( gpu_sy - gpu_y2 ) - ( gpu_active_y - gpu_y2 ) * ( gpu_sx - gpu_x2 )) >= 0;
                w2 = (( gpu_x1 - gpu_active_x ) * ( gpu_sy - gpu_active_y ) - ( gpu_y1 - gpu_active_y ) * ( gpu_sx - gpu_active_x )) >= 0;
                ++:
                bitmap_write = inTriangle;
                beenInTriangle = inTriangle ? 1 : beenInTriangle;
                ++:
                if( beenInTriangle && ~inTriangle ) {
                    // Exited the triangle, move to the next line
                    beenInTriangle = 0;
                    gpu_sy = gpu_sy + 1;
                    if( ( gpu_max_x - gpu_sx ) < ( gpu_sx - gpu_min_x ) ) {
                        // Closer to the right
                        gpu_sx = gpu_max_x;
                        gpu_dx = 0;
                    } else {
                        // Closer to the left
                        gpu_sx = gpu_min_x;
                        gpu_dx = 1;
                    }
                } else {
                    switch( gpu_dx ) {
                        case 0: {
                            if( gpu_sx >= gpu_min_x ) {
                                gpu_sx = gpu_sx - 1;
                            } else {
                                gpu_dx = 1;
                                beenInTriangle = 0;
                                gpu_sy = gpu_sy + 1;
                            }
                        }
                        case 1: {
                            if( gpu_sx <= gpu_max_x ) {
                                gpu_sx = gpu_sx + 1;
                            } else {
                                gpu_dx = 0;
                                beenInTriangle = 0;
                                gpu_sy = gpu_sy + 1;
                            }
                        }
                    }
                }
            }
            active = 0;
        }
    }
}

// BLIT - ( tilecharacter == 1 ) OUTPUT PIXELS TO BLIT A 16 x 16 TILE ( PARAM1 == 0 as 16 x 16, == 1 as 32 x 32, == 2 as 64 x 64, == 3 as 128 x 128 )
// BLIT - ( tilecharacter == 0 ) OUTPUT PIXELS TO BLIT AN 8 x 8 CHARACTER ( PARAM1 == 0 as 8 x 8, == 1 as 16 x 16, == 2 as 32 x 32, == 3 as 64 x 64 )
algorithm blit (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   uint2   param1,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    input   uint1   tilecharacter,
    output  uint1   busy,

    simple_dualbram_port0 blit1tilemap,
    simple_dualbram_port0 characterGenerator8x8
) <autorun> {
    // POSITION IN TILE/CHARACTER
    uint8   gpu_active_x = uninitialized;
    uint8   gpu_active_y = uninitialized;

    // POSITION ON THE SCREEN
    int11   gpu_x1 = uninitialized;
    int11   gpu_y1 = uninitialized;
    uint5   gpu_y2 = uninitialised;

    // MULTIPLIER FOR THE SIZE
    uint2   gpu_param1 = uninitialised;
    uint8   gpu_max_x = uninitialized;
    uint8   gpu_max_y = uninitialized;

    // TILE/CHARACTER TO BLIT
    uint8   gpu_tile = uninitialized;

    uint1   active = 0;
    busy := start ? 1 : active;

    // tile and character bitmap addresses
    blit1tilemap.addr0 := gpu_tile * 16 + gpu_active_y;
    characterGenerator8x8.addr0 := gpu_tile * 8 + gpu_active_y;

    bitmap_x_write := gpu_x1 + gpu_active_x;
    bitmap_y_write := gpu_y1 + ( gpu_active_y << gpu_param1 ) + gpu_y2;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            gpu_active_x = 0;
            gpu_active_y = 0;
            ( gpu_x1, gpu_y1 ) = copycoordinates( x, y );
            gpu_param1 = param1;
            gpu_max_x = ( tilecharacter ? 16 : 8 ) << ( param1 & 3);
            gpu_max_y = tilecharacter ? 16 : 8;
            gpu_tile = param0;
            ++:
            while( gpu_active_y < gpu_max_y ) {
                while( gpu_active_x < gpu_max_x ) {
                    while( gpu_y2 < ( 1 << gpu_param1 ) ) {
                        bitmap_write = tilecharacter ? blit1tilemap.rdata0[15 - ( gpu_active_x >> gpu_param1 ),1] : characterGenerator8x8.rdata0[7 - ( gpu_active_x >> gpu_param1 ),1];
                        gpu_y2 = gpu_y2 + 1;
                    }
                    gpu_active_x = gpu_active_x + 1;
                    gpu_y2 = 0;
                }
                gpu_active_x = 0;
                gpu_active_y = gpu_active_y + 1;
            }
            active = 0;
        }
    }
}

// Vector Block
// Stores blocks of upto 16 vertices which can be sent to the GPU for line drawing
// Each vertices represents a delta from the centre of the vector
// Deltas are stored as 6 bit 2's complement range -31 to 0 to 31
// Each vertices has an active flag, processing of a vector block stops when the active flag is 0
// Each vector block has a centre x and y coordinate and a colour { rrggbb } when drawn
algorithm vectors(
    input   uint5   vector_block_number,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,

    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   vector_block_active,

    // Communication with the GPU
    output  int11 gpu_x,
    output  int11 gpu_y,
    output  int11 gpu_param0,
    output  int11 gpu_param1,
    output  uint1 gpu_write,

    input  uint1 gpu_active
) <autorun> {
    // 32 vector blocks each of 16 vertices
    simple_dualport_bram uint13 vertex[512] = uninitialised;

    // Extract deltax and deltay for the present vertices
    int11 deltax := { {6{vectorentry(vertex.rdata0).dxsign}}, vectorentry(vertex.rdata0).dx };
    int11 deltay := { {6{vectorentry(vertex.rdata0).dysign}}, vectorentry(vertex.rdata0).dy };

    // Vertices being processed, plus first coordinate of each line
    uint5 block_number = uninitialised;
    uint5 vertices_number = uninitialised;
    int11 start_x = uninitialised;
    int11 start_y = uninitialised;

    // Set read and write address for the vertices
    vertex.addr0 := block_number * 16 + vertices_number;
    vertex.addr1 := vertices_writer_block * 16 + vertices_writer_vertex;
    vertex.wdata1 := { vertices_writer_active, __unsigned(vertices_writer_xdelta), __unsigned(vertices_writer_ydelta) };
    vertex.wenable1 := 1;

    gpu_write := 0;

    vector_block_active = 0;
    vertices_number = 0;

    while(1) {
        if( draw_vector ) {
            block_number = vector_block_number;
            vertices_number = 0;
            vector_block_active = 1;
            ++:
            ( start_x, start_y ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
            vertices_number = 1;
            ++:
            while( vectorentry(vertex.rdata0).active && ( vertices_number < 16 ) ) {
                // Dispatch line to GPU
                ( gpu_x, gpu_y ) = copycoordinates( start_x, start_y );
                ( gpu_param0, gpu_param1 ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
                while( gpu_active ) {}
                gpu_write = 1;
                // Move onto the next of the vertices
                ( start_x, start_y ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
                vertices_number = vertices_number + 1;
                ++:
            }
            vector_block_active = 0;
        }
    }
}


algorithm background(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,

    input   uint16  staticGenerator,

    input uint6 backgroundcolour,
    input uint6 backgroundcolour_alt,
    input uint4 backgroundcolour_mode,
) <autorun> {
    // Variables for SNOW (from @sylefeb)
    int10   dotpos = 0;
    int2    speed = 0;
    int2    inv_speed = 0;
    int12   rand_x = 0;
    int32   frame = 0;

    while(1) {
        // Increment frame number for the snow/star field
        frame = ( ( pix_x == 639 ) && ( pix_y == 470 ) ) ? frame + 1 : frame;

        // RENDER
        if( pix_active ) {
            switch( backgroundcolour_mode ) {
                case 0: {
                    // SOLID
                    pix_red = colour6(backgroundcolour).red;
                    pix_green = colour6(backgroundcolour).green;
                    pix_blue = colour6(backgroundcolour).blue;
                }
                case 1: {
                    // 50:50 HORIZONTAL SPLIT
                    pix_red = ( pix_y < 240 ) ? colour6(backgroundcolour).red : colour6(backgroundcolour_alt).red;
                    pix_green = ( pix_y < 240 ) ? colour6(backgroundcolour).green : colour6(backgroundcolour_alt).green;
                    pix_blue = ( pix_y < 240 ) ? colour6(backgroundcolour).blue : colour6(backgroundcolour_alt).blue;
                }
                case 2: {
                // 50:50 VERTICAL SPLIT
                    pix_red = ( pix_x < 320 ) ? colour6(backgroundcolour).red : colour6(backgroundcolour_alt).red;
                    pix_green = ( pix_x < 320 ) ? colour6(backgroundcolour).green : colour6(backgroundcolour_alt).green;
                    pix_blue = ( pix_x < 320 ) ? colour6(backgroundcolour).blue : colour6(backgroundcolour_alt).blue;
                }
                case 3: {
                // QUARTERS
                    if( pix_x < 320 ) {
                        pix_red = ( pix_y < 240 ) ? colour6(backgroundcolour).red : colour6(backgroundcolour_alt).red;
                        pix_green = ( pix_y < 240 ) ? colour6(backgroundcolour).green : colour6(backgroundcolour_alt).green;
                        pix_blue = ( pix_y < 240 ) ? colour6(backgroundcolour).blue : colour6(backgroundcolour_alt).blue;
                    } else {
                        pix_red = ( pix_y >= 240 ) ? colour6(backgroundcolour).red : colour6(backgroundcolour_alt).red;
                        pix_green = ( pix_y >= 240 ) ? colour6(backgroundcolour).green : colour6(backgroundcolour_alt).green;
                        pix_blue = ( pix_y >= 240 ) ? colour6(backgroundcolour).blue : colour6(backgroundcolour_alt).blue;
                    }
                }
                case 4: {
                    // 8 colour rainbow
                    switch( pix_y[6,3] ) {
                        case 3b000: { pix_red = 2; pix_green = 0; pix_blue = 0; }
                        case 3b001: { pix_red = 3; pix_green = 0; pix_blue = 0; }
                        case 3b010: { pix_red = 3; pix_green = 2; pix_blue = 0; }
                        case 3b011: { pix_red = 3; pix_green = 3; pix_blue = 0; }
                        case 3b100: { pix_red = 0; pix_green = 3; pix_blue = 0; }
                        case 3b101: { pix_red = 0; pix_green = 0; pix_blue = 3; }
                        case 3b110: { pix_red = 1; pix_green = 0; pix_blue = 2; }
                        case 3b111: { pix_red = 1; pix_green = 2; pix_blue = 3; }
                    }
                }
                case 5: {
                    // SNOW (from @sylefeb)
                    rand_x = ( pix_x == 0)  ? 1 : rand_x * 31421 + 6927;
                    speed  = rand_x[10,2];
                    dotpos = ( frame >> speed ) + rand_x;
                        pix_red   = (pix_y == dotpos) ? colour6(backgroundcolour).red : colour6(backgroundcolour_alt).red;
                        pix_green = (pix_y == dotpos) ? colour6(backgroundcolour).green : colour6(backgroundcolour_alt).green;
                        pix_blue  = (pix_y == dotpos) ? colour6(backgroundcolour).blue : colour6(backgroundcolour_alt).blue;
                }
                case 6: {
                    // STATIC
                    pix_red = staticGenerator;
                    pix_green = staticGenerator;
                    pix_blue = staticGenerator;
                }

                default: {
                    // CHECKERBOARDS
                        switch( { pix_x[backgroundcolour_mode-7,1], pix_y[backgroundcolour_mode-7,1] } ) {
                            case 2b00: {
                                pix_red = colour6(backgroundcolour).red;
                                pix_green = colour6(backgroundcolour).green;
                                pix_blue = colour6(backgroundcolour).blue;
                            }
                            case 2b01: {
                                pix_red = colour6(backgroundcolour_alt).red;
                                pix_green = colour6(backgroundcolour_alt).green;
                                pix_blue = colour6(backgroundcolour_alt).blue;
                            }
                            case 2b10: {
                                pix_red = colour6(backgroundcolour_alt).red;
                                pix_green = colour6(backgroundcolour_alt).green;
                                pix_blue = colour6(backgroundcolour_alt).blue;
                            }
                            case 2b11: {
                                pix_red = colour6(backgroundcolour).red;
                                pix_green = colour6(backgroundcolour).green;
                                pix_blue = colour6(backgroundcolour).blue;
                            }
                        }
                }
            }
        }
    }
}

algorithm sprite_layer(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   sprite_layer_display,

    // For setting sprite characteristics
    input   uint4   sprite_set_number,
    input   uint1   sprite_set_active,
    input   uint1   sprite_set_double,
    input   uint6   sprite_set_colour,
    input   int11   sprite_set_x,
    input   int11   sprite_set_y,
    input   uint3   sprite_set_tile,
    // Flag to set the above
    input   uint4   sprite_layer_write,

    // For reading sprite characteristics for sprite_set_number
    output uint1   sprite_read_active,
    output uint1   sprite_read_double,
    output uint6   sprite_read_colour,
    output int11   sprite_read_x,
    output int11   sprite_read_y,
    output uint3   sprite_read_tile,

    input   uint16  sprite_update,

    // FULL collision detection
    // (1) Bitmap, (2) Tile Map, (3) Other Sprite Layer
    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
        output uint16 collision_0,
        output uint16 collision_1,
        output uint16 collision_2,
        output uint16 collision_3,
        output uint16 collision_4,
        output uint16 collision_5,
        output uint16 collision_6,
        output uint16 collision_7,
        output uint16 collision_8,
        output uint16 collision_9,
        output uint16 collision_10,
        output uint16 collision_11,
        output uint16 collision_12,

    // For setting sprite tile bitmaps
    input   uint4   sprite_writer_sprite,
    input   uint7   sprite_writer_line,
    input   uint16  sprite_writer_bitmap,
    input   uint1   sprite_writer_active

) <autorun> {
    // Storage for the sprites
    // Stored as registers as needed instantly
    uint1   sprite_active[13] = uninitialised;
    uint1   sprite_double[13] = uninitialised;
    int11   sprite_x[13] = uninitialised;
    int11   sprite_y[13] = uninitialised;
    uint6   sprite_colour[13] = uninitialised;
    uint3   sprite_tile_number[13] = uninitialised;

    uint1   output_collisions = 0;

        // Sprite Tiles
        simple_dualport_bram uint16 tiles_0[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_0 := sprite_double[0] ? 32 : 16;
        uint1 xinrange_0 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[0]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[0] + spritesize_0 ) );
        uint1 yinrange_0 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[0]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[0] + spritesize_0 ) );
        uint1 pix_visible_0 := sprite_active[0] && xinrange_0 && yinrange_0 && ( tiles_0.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[0] ) >>> sprite_double[0] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_0 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_1[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_1 := sprite_double[1] ? 32 : 16;
        uint1 xinrange_1 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[1]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[1] + spritesize_1 ) );
        uint1 yinrange_1 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[1]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[1] + spritesize_1 ) );
        uint1 pix_visible_1 := sprite_active[1] && xinrange_1 && yinrange_1 && ( tiles_1.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[1] ) >>> sprite_double[1] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_1 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_2[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_2 := sprite_double[2] ? 32 : 16;
        uint1 xinrange_2 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[2]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[2] + spritesize_2 ) );
        uint1 yinrange_2 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[2]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[2] + spritesize_2 ) );
        uint1 pix_visible_2 := sprite_active[2] && xinrange_2 && yinrange_2 && ( tiles_2.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[2] ) >>> sprite_double[2] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_2 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_3[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_3 := sprite_double[3] ? 32 : 16;
        uint1 xinrange_3 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[3]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[3] + spritesize_3 ) );
        uint1 yinrange_3 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[3]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[3] + spritesize_3 ) );
        uint1 pix_visible_3 := sprite_active[3] && xinrange_3 && yinrange_3 && ( tiles_3.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[3] ) >>> sprite_double[3] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_3 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_4[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_4 := sprite_double[4] ? 32 : 16;
        uint1 xinrange_4 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[4]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[4] + spritesize_4 ) );
        uint1 yinrange_4 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[4]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[4] + spritesize_4 ) );
        uint1 pix_visible_4 := sprite_active[4] && xinrange_4 && yinrange_4 && ( tiles_4.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[4] ) >>> sprite_double[4] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_4 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_5[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_5 := sprite_double[5] ? 32 : 16;
        uint1 xinrange_5 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[5]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[5] + spritesize_5 ) );
        uint1 yinrange_5 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[5]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[5] + spritesize_5 ) );
        uint1 pix_visible_5 := sprite_active[5] && xinrange_5 && yinrange_5 && ( tiles_5.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[5] ) >>> sprite_double[5] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_5 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_6[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_6 := sprite_double[6] ? 32 : 16;
        uint1 xinrange_6 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[6]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[6] + spritesize_6 ) );
        uint1 yinrange_6 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[6]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[6] + spritesize_6 ) );
        uint1 pix_visible_6 := sprite_active[6] && xinrange_6 && yinrange_6 && ( tiles_6.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[6] ) >>> sprite_double[6] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_6 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_7[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_7 := sprite_double[7] ? 32 : 16;
        uint1 xinrange_7 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[7]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[7] + spritesize_7 ) );
        uint1 yinrange_7 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[7]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[7] + spritesize_7 ) );
        uint1 pix_visible_7 := sprite_active[7] && xinrange_7 && yinrange_7 && ( tiles_7.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[7] ) >>> sprite_double[7] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_7 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_8[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_8 := sprite_double[8] ? 32 : 16;
        uint1 xinrange_8 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[8]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[8] + spritesize_8 ) );
        uint1 yinrange_8 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[8]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[8] + spritesize_8 ) );
        uint1 pix_visible_8 := sprite_active[8] && xinrange_8 && yinrange_8 && ( tiles_8.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[8] ) >>> sprite_double[8] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_8 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_9[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_9 := sprite_double[9] ? 32 : 16;
        uint1 xinrange_9 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[9]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[9] + spritesize_9 ) );
        uint1 yinrange_9 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[9]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[9] + spritesize_9 ) );
        uint1 pix_visible_9 := sprite_active[9] && xinrange_9 && yinrange_9 && ( tiles_9.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[9] ) >>> sprite_double[9] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_9 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_10[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_10 := sprite_double[10] ? 32 : 16;
        uint1 xinrange_10 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[10]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[10] + spritesize_10 ) );
        uint1 yinrange_10 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[10]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[10] + spritesize_10 ) );
        uint1 pix_visible_10 := sprite_active[10] && xinrange_10 && yinrange_10 && ( tiles_10.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[10] ) >>> sprite_double[10] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_10 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_11[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_11 := sprite_double[11] ? 32 : 16;
        uint1 xinrange_11 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[11]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[11] + spritesize_11 ) );
        uint1 yinrange_11 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[11]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[11] + spritesize_11 ) );
        uint1 pix_visible_11 := sprite_active[11] && xinrange_11 && yinrange_11 && ( tiles_11.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[11] ) >>> sprite_double[11] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_11 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_12[128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_12 := sprite_double[12] ? 32 : 16;
        uint1 xinrange_12 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[12]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[12] + spritesize_12 ) );
        uint1 yinrange_12 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[12]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[12] + spritesize_12 ) );
        uint1 pix_visible_12 := sprite_active[12] && xinrange_12 && yinrange_12 && ( tiles_12.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[12] ) >>> sprite_double[12] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_12 = uninitialised;

    // Expand Sprite Update Deltas
    int11   deltax := { ( spriteupdate( sprite_update ).dxsign ? 7b1111111 : 7b0000000 ), spriteupdate( sprite_update ).dx };
    int11   deltay := { ( spriteupdate( sprite_update ).dysign ? 7b1111111 : 7b0000000 ), spriteupdate( sprite_update ).dy };

    // Sprite update helpers
    int11   sprite_offscreen_negative ::= sprite_double[ sprite_set_number ] ? -32 : -16;
    int11   sprite_to_negative ::= sprite_double[ sprite_set_number ] ? -31 : -15;
    uint1   sprite_offscreen_x ::= ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_x[ sprite_set_number ] ) > __signed(640) );
    uint1   sprite_offscreen_y ::= ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_y[ sprite_set_number ] ) > __signed(480) );

        // Set read and write address for the tiles
        tiles_0.addr0 := sprite_tile_number[0] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[0] ) >>> sprite_double[0] );
        tiles_0.wenable1 := 1;

        collision_0 := ( output_collisions ) ? detect_collision_0 : collision_0;
        // Set read and write address for the tiles
        tiles_1.addr0 := sprite_tile_number[1] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[1] ) >>> sprite_double[1] );
        tiles_1.wenable1 := 1;

        collision_1 := ( output_collisions ) ? detect_collision_1 : collision_1;
        // Set read and write address for the tiles
        tiles_2.addr0 := sprite_tile_number[2] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[2] ) >>> sprite_double[2] );
        tiles_2.wenable1 := 1;

        collision_2 := ( output_collisions ) ? detect_collision_2 : collision_2;
        // Set read and write address for the tiles
        tiles_3.addr0 := sprite_tile_number[3] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[3] ) >>> sprite_double[3] );
        tiles_3.wenable1 := 1;

        collision_3 := ( output_collisions ) ? detect_collision_3 : collision_3;
        // Set read and write address for the tiles
        tiles_4.addr0 := sprite_tile_number[4] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[4] ) >>> sprite_double[4] );
        tiles_4.wenable1 := 1;

        collision_4 := ( output_collisions ) ? detect_collision_4 : collision_4;
        // Set read and write address for the tiles
        tiles_5.addr0 := sprite_tile_number[5] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[5] ) >>> sprite_double[5] );
        tiles_5.wenable1 := 1;

        collision_5 := ( output_collisions ) ? detect_collision_5 : collision_5;
        // Set read and write address for the tiles
        tiles_6.addr0 := sprite_tile_number[6] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[6] ) >>> sprite_double[6] );
        tiles_6.wenable1 := 1;

        collision_6 := ( output_collisions ) ? detect_collision_6 : collision_6;
        // Set read and write address for the tiles
        tiles_7.addr0 := sprite_tile_number[7] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[7] ) >>> sprite_double[7] );
        tiles_7.wenable1 := 1;

        collision_7 := ( output_collisions ) ? detect_collision_7 : collision_7;
        // Set read and write address for the tiles
        tiles_8.addr0 := sprite_tile_number[8] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[8] ) >>> sprite_double[8] );
        tiles_8.wenable1 := 1;

        collision_8 := ( output_collisions ) ? detect_collision_8 : collision_8;
        // Set read and write address for the tiles
        tiles_9.addr0 := sprite_tile_number[9] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[9] ) >>> sprite_double[9] );
        tiles_9.wenable1 := 1;

        collision_9 := ( output_collisions ) ? detect_collision_9 : collision_9;
        // Set read and write address for the tiles
        tiles_10.addr0 := sprite_tile_number[10] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[10] ) >>> sprite_double[10] );
        tiles_10.wenable1 := 1;

        collision_10 := ( output_collisions ) ? detect_collision_10 : collision_10;
        // Set read and write address for the tiles
        tiles_11.addr0 := sprite_tile_number[11] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[11] ) >>> sprite_double[11] );
        tiles_11.wenable1 := 1;

        collision_11 := ( output_collisions ) ? detect_collision_11 : collision_11;
        // Set read and write address for the tiles
        tiles_12.addr0 := sprite_tile_number[12] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[12] ) >>> sprite_double[12] );
        tiles_12.wenable1 := 1;

        collision_12 := ( output_collisions ) ? detect_collision_12 : collision_12;

    // Default to transparent
    sprite_layer_display := 0;

    // Sprite details reader
    sprite_read_active := sprite_active[ sprite_set_number ];
    sprite_read_double := sprite_double[ sprite_set_number ];
    sprite_read_colour := sprite_colour[ sprite_set_number ];
    sprite_read_x := sprite_x[ sprite_set_number ];
    sprite_read_y := sprite_y[ sprite_set_number ];
    sprite_read_tile := sprite_tile_number[ sprite_set_number ];

    while(1) {
        // RENDER + COLLISION DETECTION
        if( pix_vblank ) {
            if( ~output_collisions ) {
                // RESET collision detection
                    detect_collision_0 = 0;
                    detect_collision_1 = 0;
                    detect_collision_2 = 0;
                    detect_collision_3 = 0;
                    detect_collision_4 = 0;
                    detect_collision_5 = 0;
                    detect_collision_6 = 0;
                    detect_collision_7 = 0;
                    detect_collision_8 = 0;
                    detect_collision_9 = 0;
                    detect_collision_10 = 0;
                    detect_collision_11 = 0;
                    detect_collision_12 = 0;
            } else {
                output_collisions = 0;
            }
        } else {
            if( pix_active ) {
                    if(  ( pix_visible_0 ) ) {
                        pix_red = sprite_colour[0][4,2];
                        pix_green = sprite_colour[0][2,2];
                        pix_blue = sprite_colour[0][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_0 = detect_collision_0 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_1 ) ) {
                        pix_red = sprite_colour[1][4,2];
                        pix_green = sprite_colour[1][2,2];
                        pix_blue = sprite_colour[1][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_1 = detect_collision_1 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_2 ) ) {
                        pix_red = sprite_colour[2][4,2];
                        pix_green = sprite_colour[2][2,2];
                        pix_blue = sprite_colour[2][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_2 = detect_collision_2 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_3 ) ) {
                        pix_red = sprite_colour[3][4,2];
                        pix_green = sprite_colour[3][2,2];
                        pix_blue = sprite_colour[3][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_3 = detect_collision_3 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_4 ) ) {
                        pix_red = sprite_colour[4][4,2];
                        pix_green = sprite_colour[4][2,2];
                        pix_blue = sprite_colour[4][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_4 = detect_collision_4 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_5 ) ) {
                        pix_red = sprite_colour[5][4,2];
                        pix_green = sprite_colour[5][2,2];
                        pix_blue = sprite_colour[5][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_5 = detect_collision_5 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_6 ) ) {
                        pix_red = sprite_colour[6][4,2];
                        pix_green = sprite_colour[6][2,2];
                        pix_blue = sprite_colour[6][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_6 = detect_collision_6 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_7 ) ) {
                        pix_red = sprite_colour[7][4,2];
                        pix_green = sprite_colour[7][2,2];
                        pix_blue = sprite_colour[7][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_7 = detect_collision_7 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_8 ) ) {
                        pix_red = sprite_colour[8][4,2];
                        pix_green = sprite_colour[8][2,2];
                        pix_blue = sprite_colour[8][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_8 = detect_collision_8 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_9 ) ) {
                        pix_red = sprite_colour[9][4,2];
                        pix_green = sprite_colour[9][2,2];
                        pix_blue = sprite_colour[9][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_9 = detect_collision_9 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_10 ) ) {
                        pix_red = sprite_colour[10][4,2];
                        pix_green = sprite_colour[10][2,2];
                        pix_blue = sprite_colour[10][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_10 = detect_collision_10 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_11 ) ) {
                        pix_red = sprite_colour[11][4,2];
                        pix_green = sprite_colour[11][2,2];
                        pix_blue = sprite_colour[11][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_11 = detect_collision_11 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_12 ) ) {
                        pix_red = sprite_colour[12][4,2];
                        pix_green = sprite_colour[12][2,2];
                        pix_blue = sprite_colour[12][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_12 = detect_collision_12 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }

                // Output collision detection
                output_collisions = ( pix_x == 639 ) && ( pix_y == 479 );
            }
        }

        // WRITE BITMAP TO SPRITE TILE
        if( sprite_writer_active ) {
            switch( sprite_writer_sprite ) {
                    case 0: {
                        tiles_0.addr1 = sprite_writer_line;
                        tiles_0.wdata1 = sprite_writer_bitmap;
                    }
                    case 1: {
                        tiles_1.addr1 = sprite_writer_line;
                        tiles_1.wdata1 = sprite_writer_bitmap;
                    }
                    case 2: {
                        tiles_2.addr1 = sprite_writer_line;
                        tiles_2.wdata1 = sprite_writer_bitmap;
                    }
                    case 3: {
                        tiles_3.addr1 = sprite_writer_line;
                        tiles_3.wdata1 = sprite_writer_bitmap;
                    }
                    case 4: {
                        tiles_4.addr1 = sprite_writer_line;
                        tiles_4.wdata1 = sprite_writer_bitmap;
                    }
                    case 5: {
                        tiles_5.addr1 = sprite_writer_line;
                        tiles_5.wdata1 = sprite_writer_bitmap;
                    }
                    case 6: {
                        tiles_6.addr1 = sprite_writer_line;
                        tiles_6.wdata1 = sprite_writer_bitmap;
                    }
                    case 7: {
                        tiles_7.addr1 = sprite_writer_line;
                        tiles_7.wdata1 = sprite_writer_bitmap;
                    }
                    case 8: {
                        tiles_8.addr1 = sprite_writer_line;
                        tiles_8.wdata1 = sprite_writer_bitmap;
                    }
                    case 9: {
                        tiles_9.addr1 = sprite_writer_line;
                        tiles_9.wdata1 = sprite_writer_bitmap;
                    }
                    case 10: {
                        tiles_10.addr1 = sprite_writer_line;
                        tiles_10.wdata1 = sprite_writer_bitmap;
                    }
                    case 11: {
                        tiles_11.addr1 = sprite_writer_line;
                        tiles_11.wdata1 = sprite_writer_bitmap;
                    }
                    case 12: {
                        tiles_12.addr1 = sprite_writer_line;
                        tiles_12.wdata1 = sprite_writer_bitmap;
                    }
            }
        }

        // SET ATTRIBUTES + PERFORM UPDATE
        switch( sprite_layer_write ) {
            case 1: { sprite_active[ sprite_set_number ] = sprite_set_active; }
            case 2: { sprite_tile_number[ sprite_set_number ] = sprite_set_tile; }
            case 3: { sprite_colour[ sprite_set_number ] = sprite_set_colour; }
            case 4: { sprite_x[ sprite_set_number ] = sprite_set_x; }
            case 5: { sprite_y[ sprite_set_number ] = sprite_set_y; }
            case 6: { sprite_double[ sprite_set_number ] = sprite_set_double; }
            case 10: {
                // Perform sprite update
                if( spriteupdate( sprite_update ).tile_act ) {
                    sprite_tile_number[ sprite_set_number ] = sprite_tile_number[ sprite_set_number ] + 1;
                }

                if( spriteupdate( sprite_update ).x_act || spriteupdate( sprite_update ).y_act) {
                    sprite_active[ sprite_set_number ] = ( sprite_offscreen_x || sprite_offscreen_y ) ? 0 : sprite_active[ sprite_set_number ];
                }

                sprite_x[ sprite_set_number ] = sprite_offscreen_x ? ( ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ?__signed(640) : sprite_to_negative ) :
                                                sprite_x[ sprite_set_number ] + deltax;

                sprite_y[ sprite_set_number ] = sprite_offscreen_y ? ( ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ? __signed(480) : sprite_to_negative ) :
                                                sprite_y[ sprite_set_number ] + deltay;
            }
        }
    }
}

algorithm tilemap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   tilemap_display,

    // Set TM at x, y, character with foreground and background
    input uint6 tm_x,
    input uint6 tm_y,
    input uint5 tm_character,
    input uint6 tm_foreground,
    input uint7 tm_background,
    input uint1 tm_write,

    // For setting tile bitmaps
    input   uint5   tile_writer_tile,
    input   uint4   tile_writer_line,
    input   uint16  tile_writer_bitmap,

    // For scrolling/wrapping
    input   uint4   tm_scrollwrap,
    output  uint4   tm_lastaction,
    output  uint3   tm_active
) <autorun> {
    // Tile Map 32 x 16 x 16
    simple_dualport_bram uint16 tiles16x16[ 512 ] = { 0, pad(0) };

    // 42 x 32 tile map, allows for pixel scrolling with border { 7 bits background, 6 bits foreground, 5 bits tile number }
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint18 tiles[1344] = { 18b100000000000000000, pad(18b100000000000000000) };
    simple_dualport_bram uint18 tiles_copy[1344] = { 18b100000000000000000, pad(18b100000000000000000) };

    // Scroll position - -15 to 0 to 15
    // -15 or 15 will trigger appropriate scroll when next moved in that direction
    int5    tm_offset_x = 0;
    int5    tm_offset_y = 0;

    // Scroller/Wrapper storage
    uint1   tm_scroll = uninitialized;
    uint6   x_cursor = uninitialized;
    uint6   y_cursor = uninitialized;
    uint11  y_cursor_addr = uninitialized;
    uint18  new_tile = uninitialized;
    uint18  scroll_tile = uninitialized;

    // CS address
    uint11  tmcsaddr = uninitialized;

    // Character position on the screen x 0-41, y 0-31 * 42 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    // Adjust for the offsets, effective 0 point margin is ( 1,1 ) to ( 40,30 ) with a 1 tile border
    uint11  xtmpos :=  ( pix_active ? pix_x + ( 11d18 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) : ( 11d16 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) ) >> 4;
    uint11  ytmpos := (( pix_vblank ? ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) : pix_y + ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) ) >> 4) * 42;

    // Derive the x and y coordinate within the current 16x16 tilemap block x 0-7, y 0-15
    // Needs adjusting for the offsets
    uint4   xintm := { 1b0, (pix_x) & 15 } + tm_offset_x;
    uint4   yintm := { 1b0, (pix_y) & 15 } + tm_offset_y;

    // Derive the actual pixel in the current character
    uint1   tmpixel := tiles16x16.rdata0[15 - xintm,1];

    // Set up reading of the tilemap
    tiles.addr0 := xtmpos + ytmpos;
    tiles.wenable1 := 1;
    tiles_copy.wenable1 := 1;

    // Setup the reading and writing of the tiles16x16
    tiles16x16.addr0 :=  tilemapentry(tiles.rdata0).tilenumber * 16 + yintm;
    tiles16x16.addr1 := tile_writer_tile * 16 + tile_writer_line;
    tiles16x16.wdata1 := tile_writer_bitmap;
    tiles16x16.wenable1 := 1;

    // RENDER - Default to transparent
    tilemap_display := pix_active && ( ( tmpixel ) || ( ~tilemapentry(tiles.rdata0).alpha ) );
    pix_red := tmpixel ? tiles.rdata0[9,2] : tiles.rdata0[15,2];
    pix_green := tmpixel ? tiles.rdata0[7,2] : tiles.rdata0[13,2];
    pix_blue := tmpixel ?  tiles.rdata0[5,2] : tiles.rdata0[11,2];

    // Default to 0,0 and transparent
    tiles.addr1 = 0; tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
    tiles_copy.addr1 = 0; tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };

    while(1) {
        // Write character to the tilemap
        if( tm_write == 1 ) {
            tiles.addr1 = tm_x + tm_y * 42;
            tiles.wdata1 = { tm_background, tm_foreground, tm_character };
            tiles_copy.addr1 = tm_x + tm_y * 42;
            tiles_copy.wdata1 = { tm_background, tm_foreground, tm_character };
        }

        switch( tm_active ) {
            case 0: {
                // Perform Scrolling/Wrapping
                switch( tm_scrollwrap ) {
                    // LEFT
                    case 1: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 2: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 3;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 3: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 2;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 4: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 4;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }
                    // LEFT
                    case 5: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 6: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 3;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 7: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 2;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 8: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_active = 4;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // CLEAR
                    case 9: {
                        tm_active = 5;
                        tm_lastaction = 9;
                    }
                }
            }

            // SCROLL/WRAP LEFT
            case 1: {
                y_cursor = 0;
                y_cursor_addr = 0;
                ++:
                while( y_cursor < 32 ) {
                    x_cursor = 0;
                    tiles_copy.addr0 = y_cursor_addr;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( x_cursor < 42 ) {
                        tiles_copy.addr0 = ( x_cursor + 1 ) + y_cursor_addr;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        x_cursor = x_cursor + 1;
                    }
                    ++:
                    tiles.addr1 = ( 41 ) + y_cursor_addr;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = ( 41 ) + y_cursor_addr;
                    tiles_copy.wdata1 = new_tile;
                    y_cursor = y_cursor + 1;
                    y_cursor_addr = y_cursor_addr + 42;
                }
                ++:
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP RIGHT
            case 2: {
                y_cursor = 0;
                y_cursor_addr = 0;
                ++:
                while( y_cursor < 32 ) {
                    x_cursor = 41;
                    tiles_copy.addr0 = 41 + y_cursor_addr;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( x_cursor > 0 ) {
                        tiles_copy.addr0 = ( x_cursor - 1 ) + y_cursor_addr;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        x_cursor = x_cursor - 1;
                    }
                    ++:
                    tiles.addr1 = y_cursor_addr;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = y_cursor_addr;
                    tiles_copy.wdata1 = new_tile;
                    y_cursor = y_cursor + 1;
                    y_cursor_addr = y_cursor_addr + 42;
                }
                ++:
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP UP
            case 3: {
                x_cursor = 0;
                ++:
                while( x_cursor < 42 ) {
                    y_cursor = 0;
                    y_cursor_addr = 0;
                    tiles_copy.addr0 = x_cursor;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( y_cursor < 31 ) {
                        tiles_copy.addr0 = x_cursor + y_cursor_addr + 42;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        y_cursor = y_cursor + 1;
                        y_cursor_addr = y_cursor_addr + 42;
                    }
                    tiles.addr1 = x_cursor + 1302;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = x_cursor + 1302;
                    tiles_copy.wdata1 = new_tile;
                    x_cursor = x_cursor + 1;
                }
                ++:
                tm_offset_y = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP DOWN
            case 4: {
                x_cursor = 0;
                ++:
                while( x_cursor < 42 ) {
                    y_cursor = 0;
                    y_cursor_addr = 1302;
                    tiles_copy.addr0 = x_cursor;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( y_cursor > 0 ) {
                        tiles_copy.addr0 = x_cursor + y_cursor_addr - 42;
                        ++:
                        scroll_tile = tiles_copy.rdata0;
                        ++:
                        tiles.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles.wdata1 = scroll_tile;
                        tiles_copy.addr1 = ( x_cursor ) + y_cursor_addr;
                        tiles_copy.wdata1 = scroll_tile;
                        y_cursor = y_cursor - 1;
                        y_cursor_addr = y_cursor_addr - 42;
                    }
                    tiles.addr1 = x_cursor;
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = x_cursor;
                    tiles_copy.wdata1 = new_tile;
                    x_cursor = x_cursor + 1;
                }
                ++:
                tm_offset_y = 0;
                tm_active = 0;
            }

            // CLEAR
            case 5: {
                tmcsaddr = 0;
                tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                ++:
                while( tmcsaddr < 1344 ) {
                    tiles.addr1 = tmcsaddr;
                    tiles_copy.addr1 = tmcsaddr;
                    tmcsaddr = tmcsaddr + 1;
                }
                ++:

                tm_offset_x = 0;
                tm_offset_y = 0;
                tm_active = 0;
            }
        }
    }
}

// Runs at 50MHz
algorithm apu(
    // Waveform selected 0 = square, 1 = sawtooth, 2 = triangle, 3 = sine wave, 4 = noise
    input   uint4   waveform,
    // Note selected 0 = silence, 1 - x = Deep C through to Double High D (gives 64 distint notes)
    input   uint7   note,

    // Duration in ms, 1000 = 1 second,
    input   uint16  duration,
    output! uint1   audio_active,

    // Activate the APU (select the channel, 1, 2 or 3(?) )
    input   uint1   apu_write,

    output! uint4   audio_output,

    input uint16    staticGenerator
) <autorun> {
    // 32 step points per waveform
    brom uint4 waveformtable[512] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,
        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6
        ,pad(1)
    };

    // Calculated as 50MHz / note frequency / 32 to give 32 step points per note
    brom uint16 frequencytable[128] = {
        0,
        47778, 45097, 42566, 40177, 37922, 35793, 33784, 31888, 30098, 28409, 26815, 25310,     // 1 = C 2 or Deep C
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 13 = C 3
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 25 = C 4 or Middle C
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 37 = C 5 or Tenor C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 49 = C 6 or Soprano C
        1493, 1409, 1330, pad(1024)                                                             // 61 = C 7 or Double High C
    };

    // LATCH SELECTED WAVEFORM NOTE AND DURATION ON APU_WRITE
    uint4   selected_waveform = uninitialised;
    uint7   selected_note = uninitialised;
    uint16  selected_duration = uninitialised;

    // POSITION IN THE WAVETABLE AND TIMERS FOR FREQUENCY AND DURATION
    uint5   point = uninitialised;
    uint16  counter50mhz = uninitialised;
    uint16  counter1khz = uninitialised;

    waveformtable.addr := selected_waveform * 32 + point;
    frequencytable.addr := selected_note;

    audio_active := ( selected_duration > 0 );

    while(1) {
        if( apu_write ) {
            selected_waveform = waveform;
            selected_note = note;
            selected_duration = duration;
            point = 0;
            counter50mhz = 0;
            counter1khz = 50000;
        } else {
            if( selected_duration != 0 ) {
                if( counter50mhz == 0 ) {
                    audio_output = ( selected_waveform == 4 ) ? staticGenerator : waveformtable.rdata;
                }
                counter50mhz = ( counter50mhz != 0 ) ? counter50mhz - 1 : frequencytable.rdata;
                point = ( counter50mhz != 0 ) ? point : point + 1;
                counter1khz = ( counter1khz != 0 ) ? counter1khz - 1 : 50000;
                selected_duration = ( counter1khz != 0 ) ? selected_duration : selected_duration - 1;
            }
        }
    }
}

algorithm memmap_io (
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // SDCARD
    output! uint1   sd_clk,
    output! uint1   sd_mosi,
    output! uint1   sd_csn,
    input   uint1   sd_miso,

    // HDMI
    output! uint8   video_r,
    output! uint8   video_g,
    output! uint8   video_b,
    input   uint1   vblank,
    input   uint1   pix_active,
    input   uint10  pix_x,
    input   uint10  pix_y,

    // CLOCKS
    input   uint1   video_clock,
    input   uint1   video_reset,

    // Memory access
    input   uint16  memoryAddress,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,

    input   uint16  writeData,
    output! uint32  readData,
) <autorun> {
    // 1hz timers (p1hz used for systemClock, timer1hz for user purposes)
    uint16 systemClock = uninitialized;
    pulse1hz p1hz(
        counter1hz :> systemClock,
    );
    pulse1hz timer1hz( );

    // 1khz timers (sleepTimer used for sleep command, timer1khz for user purposes)
    pulse1khz sleepTimer( );
    pulse1khz timer1khz( );

    // RNG random number generator
    uint16  staticGenerator = uninitialized;
    random rng(
        g_noise_out :> staticGenerator,
    );

    // UART tx and rx
    // UART written in Silice by https://github.com/sylefeb/Silice
    uart_out uo;
    uart_sender usend(
        io      <:> uo,
        uart_tx :>  uart_tx
    );
    uart_in ui;
    uart_receiver urecv(
        io      <:> ui,
        uart_rx <:  uart_rx
    );

    // CREATE DISPLAY LAYERS
    // BACKGROUND
    uint2   background_r = uninitialized;
    uint2   background_g = uninitialized;
    uint2   background_b = uninitialized;
    background background_generator <@video_clock,!video_reset>  (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> background_r,
        pix_green  :> background_g,
        pix_blue   :> background_b,
        staticGenerator <: staticGenerator
    );

    // TILEMAP
    uint2   tilemap_r = uninitialized;
    uint2   tilemap_g = uninitialized;
    uint2   tilemap_b = uninitialized;
    uint1   tilemap_display = uninitialized;

    tilemap tile_map <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> tilemap_r,
        pix_green  :> tilemap_g,
        pix_blue   :> tilemap_b,
        tilemap_display :> tilemap_display,
    );

    // Bitmap Window
    uint2   bitmap_r = uninitialized;
    uint2   bitmap_g = uninitialized;
    uint2   bitmap_b = uninitialized;
    uint10  x_offset = uninitialized;
    uint10  y_offset = uninitialized;
    // From GPU to set a pixel
    uint1   bitmap_display = uninitialized;
    int11   bitmap_x_write = uninitialized;
    int11   bitmap_y_write = uninitialized;
    uint7   bitmap_colour_write = uninitialized;
    uint1   bitmap_write = uninitialized;

    // 640 x 480 x 7 bit { Arrggbb } colour bitmap
    simple_dualport_bram uint7 bitmap <@video_clock,@video_clock,input!> [ 307200 ] = uninitialized;
    bitmap bitmap_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> bitmap_r,
        pix_green  :> bitmap_g,
        pix_blue   :> bitmap_b,
        bitmap_display :> bitmap_display,
        x_offset :> x_offset,
        y_offset :> y_offset,
        bitmap <:> bitmap
    );
    bitmapwriter pixel_writer <@video_clock> (
        bitmap_x_write <: bitmap_x_write,
        bitmap_y_write <: bitmap_y_write,
        bitmap_colour_write <: bitmap_colour_write,
        bitmap_write <: bitmap_write,
        x_offset <: x_offset,
        y_offset <: y_offset,
        bitmap <:> bitmap
    );

    // Lower Sprite Layer - Between BACKGROUND and BITMAP
    // Upper Sprite Layer - Between BITMAP and CHARACTER MAP
    uint2   lower_sprites_r = uninitialized;
    uint2   lower_sprites_g = uninitialized;
    uint2   lower_sprites_b = uninitialized;
    uint1   lower_sprites_display = uninitialized;
    uint2   upper_sprites_r = uninitialized;
    uint2   upper_sprites_g = uninitialized;
    uint2   upper_sprites_b = uninitialized;
    uint1   upper_sprites_display = uninitialized;

    sprite_layer lower_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> lower_sprites_r,
        pix_green  :> lower_sprites_g,
        pix_blue   :> lower_sprites_b,
        sprite_layer_display :> lower_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: upper_sprites_display
    );

    sprite_layer upper_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> upper_sprites_r,
        pix_green  :> upper_sprites_g,
        pix_blue   :> upper_sprites_b,
        sprite_layer_display :> upper_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: lower_sprites_display
    );

    // Character Map Window
    uint2   character_map_r = uninitialized;
    uint2   character_map_g = uninitialized;
    uint2   character_map_b = uninitialized;
    uint1   character_map_display = uninitialized;

    character_map character_map_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> character_map_r,
        pix_green  :> character_map_g,
        pix_blue   :> character_map_b,
        character_map_display :> character_map_display
    );

    // Terminal window at the bottom of the screen
    uint2   terminal_r = uninitialized;
    uint2   terminal_g = uninitialized;
    uint2   terminal_b = uninitialized;
    uint1   terminal_display = uninitialized;

    terminal terminal_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> terminal_r,
        pix_green  :> terminal_g,
        pix_blue   :> terminal_b,
        terminal_display :> terminal_display,
        timer1hz   <: systemClock
    );

    // Combine the display layers for display
    multiplex_display display <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> video_r,
        pix_green  :> video_g,
        pix_blue   :> video_b,

        background_r <: background_r,
        background_g <: background_g,
        background_b <: background_b,

        tilemap_r <: tilemap_r,
        tilemap_g <: tilemap_g,
        tilemap_b <: tilemap_b,
        tilemap_display <: tilemap_display,

        lower_sprites_r <: lower_sprites_r,
        lower_sprites_g <: lower_sprites_g,
        lower_sprites_b <: lower_sprites_b,
        lower_sprites_display <: lower_sprites_display,

        bitmap_r <: bitmap_r,
        bitmap_g <: bitmap_g,
        bitmap_b <: bitmap_b,
        bitmap_display <: bitmap_display,

        upper_sprites_r <: upper_sprites_r,
        upper_sprites_g <: upper_sprites_g,
        upper_sprites_b <: upper_sprites_b,
        upper_sprites_display <: upper_sprites_display,

        character_map_r <: character_map_r,
        character_map_g <: character_map_g,
        character_map_b <: character_map_b,
        character_map_display <: character_map_display,

        terminal_r <: terminal_r,
        terminal_g <: terminal_g,
        terminal_b <: terminal_b,
        terminal_display <: terminal_display
    );

    // Left and Right audio channels
    apu apu_processor_L(
        staticGenerator <: staticGenerator,
        audio_output :> audio_l
    );
    apu apu_processor_R(
        staticGenerator <: staticGenerator,
        audio_output :> audio_r
    );

    gpu gpu_processor <@video_clock> (
        bitmap_x_write :> bitmap_x_write,
        bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write,
        bitmap_write :> bitmap_write,
    );

    // SDCARD - Code for the SDCARD from @sylefeb
    simple_dualport_bram uint8 sdbuffer [512] = uninitialized;

    sdcardio sdcio;
    sdcard sd (
        // pins
        sd_clk      :> sd_clk,
        sd_mosi     :> sd_mosi,
        sd_csn      :> sd_csn,
        sd_miso     <: sd_miso,
        // io
        io          <:> sdcio,
        // bram port
        store       <:> sdbuffer
    );

    // UART input FIFO (4096 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartInBuffer [4096] = uninitialized;
    uint13  uartInBufferNext = 0;
    uint13  uartInBufferTop = 0;

    // UART output FIFO (16 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartOutBuffer [256] = uninitialized;
    uint8   uartOutBufferNext = 0;
    uint8   uartOutBufferTop = 0;
    uint8   newuartOutBufferTop = 0;

    // LATCH MEMORYREAD MEMORYWRITE
    uint1   LATCHmemoryRead = uninitialized;
    uint1   LATCHmemoryWrite = uninitialized;

    // register buttons
    uint7 reg_btns = 0;
    reg_btns ::= btns;

    // UART Buffers ( code from @sylefeb )
    uartInBuffer.wenable1 := 1;  // always write on port 1
    uartInBuffer.addr0 := uartInBufferNext; // FIFO reads on next
    uartInBuffer.addr1 := uartInBufferTop;  // FIFO writes on top
    uartOutBuffer.wenable1 := 1; // always write on port 1
    uartOutBuffer.addr0 := uartOutBufferNext; // FIFO reads on next
    uartOutBuffer.addr1 := uartOutBufferTop;  // FIFO writes on top
    uartInBuffer.wdata1 := ui.data_out;
    uartInBufferTop := ( ui.data_out_ready ) ? uartInBufferTop + 1 : uartInBufferTop;
    uo.data_in := uartOutBuffer.rdata0;
    uo.data_in_ready := ( uartOutBufferNext != uartOutBufferTop ) && ( !uo.busy );
    uartOutBufferNext := ( (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy ) ) ? uartOutBufferNext + 1 : uartOutBufferNext;

    // Setup the UART
    //uo.data_in_ready := 0; // maintain low

    // SDCARD Commands
    sdcio.read_sector := 0;

    // RESET TIMER and AUDIO Co-Processor Controls
    p1hz.resetCounter := 0;
    sleepTimer.resetCounter := 0;
    timer1hz.resetCounter := 0;
    timer1khz.resetCounter := 0;
    rng.resetRandom := 0;
    apu_processor_L.apu_write := 0;
    apu_processor_R.apu_write := 0;

    // Setup the terminal
    terminal_window.showterminal = 1;
    terminal_window.showcursor = 1;

    while(1) {
        // Update UART output buffer top if character has been put into buffer
        uartOutBufferTop = newuartOutBufferTop;

        // READ IO Memory
        if( memoryRead && ~LATCHmemoryRead ) {
            switch( memoryAddress ) {
                // UART, LEDS, BUTTONS and CLOCK
                case 16h8000: { readData = { 8b0, uartInBuffer.rdata0 }; uartInBufferNext = uartInBufferNext + 1; }
                case 16h8004: { readData = { 14b0, ( uartOutBufferTop + 1 == uartOutBufferNext ), ( uartInBufferNext != uartInBufferTop )}; }
                case 16h8008: { readData = { 9b0, reg_btns[0,7] }; }
                case 16h800c: { readData = leds; }
                case 16h8010: { readData = systemClock; }

                // BACKGROUND

                // TILE MAP
                case 16h8230: { readData = tile_map.tm_lastaction; }
                case 16h8234: { readData = tile_map.tm_active; }

                // LOWER SPRITE LAYER
                case 16h8304: { readData = lower_sprites.sprite_read_active; }
                case 16h8308: { readData = lower_sprites.sprite_read_tile; }
                case 16h830c: { readData = lower_sprites.sprite_read_colour; }
                case 16h8310: { readData = lower_sprites.sprite_read_x[10,1] ? 16hf800 : 16h0000 | lower_sprites.sprite_read_x; }
                case 16h8314: { readData = lower_sprites.sprite_read_y[10,1] ? 16hf800 : 16h0000 | lower_sprites.sprite_read_y; }
                case 16h8318: { readData = lower_sprites.sprite_read_double; }

                case 16h8330: { readData = lower_sprites.collision_0; }
                case 16h8332: { readData = lower_sprites.collision_1; }
                case 16h8334: { readData = lower_sprites.collision_2; }
                case 16h8336: { readData = lower_sprites.collision_3; }
                case 16h8338: { readData = lower_sprites.collision_4; }
                case 16h833a: { readData = lower_sprites.collision_5; }
                case 16h833c: { readData = lower_sprites.collision_6; }
                case 16h833e: { readData = lower_sprites.collision_7; }
                case 16h8340: { readData = lower_sprites.collision_8; }
                case 16h8342: { readData = lower_sprites.collision_9; }
                case 16h8344: { readData = lower_sprites.collision_10; }
                case 16h8346: { readData = lower_sprites.collision_11; }
                case 16h8348: { readData = lower_sprites.collision_12; }

                // GPU and BITMAP
                case 16h841c: { readData = gpu_processor.gpu_active; }
                case 16h8448: { readData = gpu_processor.vector_block_active; }
                case 16h8470: { readData = bitmap_window.bitmap_colour_read; }

                // UPPER SPRITE LAYER
                case 16h8504: { readData = upper_sprites.sprite_read_active; }
                case 16h8508: { readData = upper_sprites.sprite_read_tile; }
                case 16h850c: { readData = upper_sprites.sprite_read_colour; }
                case 16h8510: { readData = upper_sprites.sprite_read_x[10,1] ? 16hf800 : 16h0000 | upper_sprites.sprite_read_x; }
                case 16h8514: { readData = upper_sprites.sprite_read_y[10,1] ? 16hf800 : 16h0000 | upper_sprites.sprite_read_y; }
                case 16h8518: { readData = upper_sprites.sprite_read_double; }

                case 16h8530: { readData = upper_sprites.collision_0; }
                case 16h8532: { readData = upper_sprites.collision_1; }
                case 16h8534: { readData = upper_sprites.collision_2; }
                case 16h8536: { readData = upper_sprites.collision_3; }
                case 16h8538: { readData = upper_sprites.collision_4; }
                case 16h853a: { readData = upper_sprites.collision_5; }
                case 16h853c: { readData = upper_sprites.collision_6; }
                case 16h853e: { readData = upper_sprites.collision_7; }
                case 16h8540: { readData = upper_sprites.collision_8; }
                case 16h8542: { readData = upper_sprites.collision_9; }
                case 16h8544: { readData = upper_sprites.collision_10; }
                case 16h8546: { readData = upper_sprites.collision_11; }
                case 16h8548: { readData = upper_sprites.collision_12; }

                // CHARACTER MAP
                case 16h8614: { readData = character_map_window.tpu_active; }

                // TERMINAL
                case 16h8700: { readData = terminal_window.terminal_active; }

                // AUDIO
                case 16h8808: { readData = apu_processor_L.audio_active; }
                case 16h8818: { readData = apu_processor_R.audio_active; }

                // TIMERS and RNG
                case 16h8900: { readData = rng.g_noise_out; }
                case 16h8904: { readData = rng.u_noise_out; }
                case 16h8910: { readData = timer1hz.counter1hz; }
                case 16h8920: { readData = timer1khz.counter1khz; }
                case 16h8930: { readData = sleepTimer.counter1khz; }

                // SDCARD
                case 16h8f00: { readData = sdcio.ready; }
                case 16h8f10: { readData = sdbuffer.rdata0; }

                // VBLANK
                case 16h8ff0: { readData = vblank; }
            }
        }

        // WRITE IO Memory
        if( memoryWrite && ~LATCHmemoryWrite ) {
            switch( memoryAddress ) {
                // UART, LEDS
                case 16h8000: { uartOutBuffer.wdata1 = writeData[0,8]; newuartOutBufferTop = uartOutBufferTop + 1; }
                case 16h800c: { leds = writeData; }

                // BACKGROUND
                case 16h8100: { background_generator.backgroundcolour = writeData; }
                case 16h8104: { background_generator.backgroundcolour_alt = writeData; }
                case 16h8108: { background_generator.backgroundcolour_mode = writeData; }

                // TILE MAP
                case 16h8200: { tile_map.tm_x = writeData; }
                case 16h8204: { tile_map.tm_y = writeData; }
                case 16h8208: { tile_map.tm_character = writeData; }
                case 16h820c: { tile_map.tm_background = writeData; }
                case 16h8210: { tile_map.tm_foreground = writeData; }
                case 16h8214: { tile_map.tm_write = 1; }

                case 16h8220: { tile_map.tile_writer_tile = writeData; }
                case 16h8224: { tile_map.tile_writer_line = writeData; }
                case 16h8228: { tile_map.tile_writer_bitmap = writeData; }

                case 16h8230: { tile_map.tm_scrollwrap = writeData; }

                // LOWER SPRITE LAYER
                case 16h8300: { lower_sprites.sprite_set_number = writeData; }
                case 16h8304: { lower_sprites.sprite_set_active = writeData; lower_sprites.sprite_layer_write = 1; }
                case 16h8308: { lower_sprites.sprite_set_tile = writeData; lower_sprites.sprite_layer_write = 2; }
                case 16h830c: { lower_sprites.sprite_set_colour = writeData; lower_sprites.sprite_layer_write = 3; }
                case 16h8310: { lower_sprites.sprite_set_x = writeData; lower_sprites.sprite_layer_write = 4; }
                case 16h8314: { lower_sprites.sprite_set_y = writeData; lower_sprites.sprite_layer_write = 5; }
                case 16h8318: { lower_sprites.sprite_set_double = writeData; lower_sprites.sprite_layer_write = 6; }
                case 16h831c: { lower_sprites.sprite_update = writeData; lower_sprites.sprite_layer_write = 10; }

                case 16h8320: { lower_sprites.sprite_writer_sprite = writeData; }
                case 16h8324: { lower_sprites.sprite_writer_line = writeData; }
                case 16h8328: { lower_sprites.sprite_writer_bitmap = writeData; lower_sprites.sprite_writer_active = 1; }

                // GPU and BITMAP
                case 16h8400: { gpu_processor.gpu_x = writeData; }
                case 16h8404: { gpu_processor.gpu_y = writeData; }
                case 16h8408: { gpu_processor.gpu_colour = writeData; }
                case 16h840c: { gpu_processor.gpu_param0 = writeData; }
                case 16h8410: { gpu_processor.gpu_param1 = writeData; }
                case 16h8414: { gpu_processor.gpu_param2 = writeData; }
                case 16h8418: { gpu_processor.gpu_param3 = writeData; }
                case 16h841c: { gpu_processor.gpu_write = writeData; }

                case 16h8420: { gpu_processor.vector_block_number = writeData; }
                case 16h8424: { gpu_processor.vector_block_colour = writeData; }
                case 16h8428: { gpu_processor.vector_block_xc = writeData; }
                case 16h842c: { gpu_processor.vector_block_yc = writeData; }
                case 16h8430: { gpu_processor.draw_vector = 1; }

                case 16h8434: { gpu_processor.vertices_writer_block = writeData; }
                case 16h8438: { gpu_processor.vertices_writer_vertex = writeData; }
                case 16h843c: { gpu_processor.vertices_writer_xdelta = writeData; }
                case 16h8440: { gpu_processor.vertices_writer_ydelta = writeData; }
                case 16h8444: { gpu_processor.vertices_writer_active = writeData; }

                case 16h8450: { gpu_processor.blit1_writer_tile = writeData; }
                case 16h8454: { gpu_processor.blit1_writer_line = writeData; }
                case 16h8458: { gpu_processor.blit1_writer_bitmap = writeData; }

                case 16h8460: { bitmap_window.bitmap_write_offset = writeData; }

                case 16h8470: { bitmap_window.bitmap_x_read = writeData; }
                case 16h8474: { bitmap_window.bitmap_y_read = writeData; }

                // UPPER SPRITE LAYER
                case 16h8500: { upper_sprites.sprite_set_number = writeData; }
                case 16h8504: { upper_sprites.sprite_set_active = writeData; upper_sprites.sprite_layer_write = 1; }
                case 16h8508: { upper_sprites.sprite_set_tile = writeData; upper_sprites.sprite_layer_write = 2; }
                case 16h850c: { upper_sprites.sprite_set_colour = writeData; upper_sprites.sprite_layer_write = 3; }
                case 16h8510: { upper_sprites.sprite_set_x = writeData; upper_sprites.sprite_layer_write = 4; }
                case 16h8514: { upper_sprites.sprite_set_y = writeData; upper_sprites.sprite_layer_write = 5; }
                case 16h8518: { upper_sprites.sprite_set_double = writeData; upper_sprites.sprite_layer_write = 6; }
                case 16h851c: { upper_sprites.sprite_update = writeData; upper_sprites.sprite_layer_write = 10; }

                case 16h8520: { upper_sprites.sprite_writer_sprite = writeData; }
                case 16h8524: { upper_sprites.sprite_writer_line = writeData; }
                case 16h8528: { upper_sprites.sprite_writer_bitmap = writeData; upper_sprites.sprite_writer_active = 1; }

                // CHARACTER MAP
                case 16h8600: { character_map_window.tpu_x = writeData; }
                case 16h8604: { character_map_window.tpu_y = writeData; }
                case 16h8608: { character_map_window.tpu_character = writeData; }
                case 16h860c: { character_map_window.tpu_background = writeData; }
                case 16h8610: { character_map_window.tpu_foreground = writeData; }
                case 16h8614: { character_map_window.tpu_write = writeData; }

                // TERMINAL
                case 16h8700: { terminal_window.terminal_character = writeData; terminal_window.terminal_write = 1; }
                case 16h8704: { terminal_window.showterminal = writeData; }

                // AUDIO
                case 16h8800: { apu_processor_L.waveform = writeData; }
                case 16h8804: { apu_processor_L.note = writeData; }
                case 16h8808: { apu_processor_L.duration = writeData; }
                case 16h880c: { apu_processor_L.apu_write = writeData; }
                case 16h8810: { apu_processor_R.waveform = writeData; }
                case 16h8814: { apu_processor_R.note = writeData; }
                case 16h8818: { apu_processor_R.duration = writeData; }
                case 16h881c: { apu_processor_R.apu_write = writeData; }

                // TIMERS and RNG
                case 16h8900: { rng.resetRandom = 1; }
                case 16h8910: { timer1hz.resetCounter = 1; }
                case 16h8920: { timer1khz.resetCount = writeData; timer1khz.resetCounter = 1; }
                case 16h8930: { sleepTimer.resetCount = writeData; sleepTimer.resetCounter = 1; }

                // SDCARD
                case 16h8f00: { sdcio.read_sector = 1; }
                case 16h8f04: { sdcio.addr_sector[16,16] = writeData; }
                case 16h8f08: { sdcio.addr_sector[0,16] = writeData; }
                case 16h8f10: { sdbuffer.addr0 = writeData; }
            }
        }

        // RESET Co-Processor Controls
        // IO memory map runs at 50MHz, display co-processors at 25MHz
        // Delay to reset co-processors therefore required
        if( ~memoryWrite && ~LATCHmemoryWrite ) {
            tile_map.tm_write = 0;
            tile_map.tm_scrollwrap = 0;
            lower_sprites.sprite_layer_write = 0;
            lower_sprites.sprite_writer_active = 0;
            bitmap_window.bitmap_write_offset = 0;
            gpu_processor.gpu_write = 0;
            gpu_processor.draw_vector = 0;
            upper_sprites.sprite_layer_write = 0;
            upper_sprites.sprite_writer_active = 0;
            character_map_window.tpu_write = 0;
            terminal_window.terminal_write = 0;
        }

        LATCHmemoryRead = memoryRead;
        LATCHmemoryWrite = memoryWrite;
    } // while(1)
}


// CPU
// RISC-ICE-V
// inspired by https://github.com/sylefeb/Silice/blob/master/projects/ice-v/ice-v.ice
//
// A simple Risc-V RV32IMC processor

algorithm PAWSCPU (
    output  uint3   function3,
    output  uint32  address,
    output  uint16  writedata,
    output  uint1   writememory,
    input   uint16  readdata,
    output  uint1   readmemory,
    output  uint1   Icacheflag,

    input   uint1   memorybusy,

    input   uint1   clock_copro
) <autorun> {
    // RISC-V REGISTERS
    simple_dualport_bram int32 registers_1 <input!> [64] = { 0, pad(0) };
    simple_dualport_bram int32 registers_2 <input!> [64] = { 0, pad(0) };

    // RISC-V PROGRAM COUNTER AND STATUS
    uint32  pc = 0;
    uint32  pcPLUS2 = uninitialized;
    uint32  nextPC = uninitialized;
    uint1   compressed = uninitialized;
    uint1   floatingpoint = uninitialized;
    uint1   takeBranch = uninitialized;
    uint1   incPC = uninitialized;

    // RISC-V REGISTER WRITER
    int32   result = uninitialized;
    uint1   writeRegister = uninitialized;
    registersWRITE registersW(
        rd <: rd,
        floatingpoint <: floatingpoint,
        result <: result,
        registers_1 <:> registers_1,
        registers_2 <:> registers_2
    );

    // RISC-V REGISTER READER
    int32   sourceReg1 = uninitialized;
    int32   sourceReg2 = uninitialized;
    uint16  sourceReg2LOW = uninitialized;
    uint16  sourceReg2HIGH = uninitialized;
    registersREAD registersR(
        rs1 <: rs1,
        rs2 <: rs2,
        floatingpoint <: floatingpoint,
        sourceReg1 :> sourceReg1,
        sourceReg2 :> sourceReg2,
        sourceReg2LOW :> sourceReg2LOW,
        sourceReg2HIGH :> sourceReg2HIGH,
        registers_1 <:> registers_1,
        registers_2 <:> registers_2
    );

    // COMPRESSED INSTRUCTION EXPANDER
    uint32  instruction = uninitialized;
    uint32  instruction32 = uninitialized;
    uint1   IScompressed = uninitialized;
    compressedexpansion compressedunit(
        compressed :> IScompressed,
        instruction16 <: readdata,
        instruction32 :> instruction32,
    );

    // RISC-V 32 BIT INSTRUCTION DECODER
    int32   immediateValue = uninitialized;
    uint7   opCode = uninitialized;
    uint7   function7 = uninitialized;
    uint5   rs1 = uninitialized;
    uint5   rs2 = uninitialized;
    uint5   rd = uninitialized;
    decoder DECODE(
        instruction <: instruction,
        opCode :> opCode,
        function3 :> function3,
        function7 :> function7,
        rs1 :> rs1,
        rs2 :> rs2,
        rd :> rd,
        immediateValue :> immediateValue
    );

    // RISC-V ADDRESS GENERATOR
    uint32  branchAddress = uninitialized;
    uint32  jumpAddress = uninitialized;
    uint32  loadAddress = uninitialized;
    uint32  loadAddressPLUS2 = uninitialized;
    uint32  storeAddress = uninitialized;
    uint32  storeAddressPLUS2 = uninitialized;
    uint32  AUIPCLUI = uninitialized;
    addressgenerator AGU(
        instruction <: instruction,
        pc <:: pc,
        compressed <: compressed,
        sourceReg1 <: sourceReg1,
        pcPLUS2 :> pcPLUS2,
        nextPC :> nextPC,
        branchAddress :> branchAddress,
        jumpAddress :> jumpAddress,
        AUIPCLUI :> AUIPCLUI,
        storeAddress :> storeAddress,
        storeAddressPLUS2 :> storeAddressPLUS2,
        loadAddress :> loadAddress,
        loadAddressPLUS2 :> loadAddressPLUS2
    );

    // RISC-V BASE ALU + M EXTENSION
    aluI ALUI <@clock_copro> (
        instruction <: instruction,
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
    );
    aluM ALUM <@clock_copro> (
        function3 <: function3,
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
    );

    // BRANCH COMPARISON UNIT
    uint1   BRANCHtakeBranch = uninitialized;
    branchcomparison branchcomparisonunit(
        opCode <: opCode,
        function3 <: function3,
        sourceReg1 <: sourceReg1,
        sourceReg2 <: sourceReg2,
        takeBranch :> BRANCHtakeBranch
    );

    // COMBINE TWO 16 BIT HALF WORDS TO ONE 32 BIT WORD
    uint16  LOW = uninitialized;
    uint16  HIGH = uninitialized;
    uint32  HIGHLOW = uninitialized;
    halfhalfword combiner161632unit(
        LOW <: LOW,
        HIGH <: HIGH,
        HIGHLOW :> HIGHLOW
    );

    uint8   SE8nosign = uninitialized;
    int32   SE8sign = uninitialized;
    signextender8 signextender8unit(
        function3 <: function3,
        nosign <: SE8nosign,
        withsign :> SE8sign
    );
    uint16  SE16nosign = uninitialized;
    int32   SE16sign = uninitialized;
    signextender16 signextender16unit(
        function3 <: function3,
        nosign <: SE16nosign,
        withsign :> SE16sign
    );

    // CSR REGISTERS
    CSRblock CSR(
        instruction <: instruction
    );

    // 8/16 bit READ WITH OPTIONAL SIGN EXTENSION
    SE8nosign := readdata[address[0,1] ? 8 : 0, 8];
    SE16nosign := readdata;

    // MEMORY ACCESS FLAGS
    readmemory := 0;
    writememory := 0;

    // REGISTER Read/Write Flags
    registersW.writeRegister := 0;

    // ALU Start Flag
    ALUM.start := 0;

    // CSR instructions retired increment flag
    CSR.incCSRinstret := 0;

    while(1) {
        // RISC-V
        writeRegister = 0;
        takeBranch = 0;
        incPC = 1;
        floatingpoint = 0;

        // FETCH + EXPAND COMPRESSED INSTRUCTIONS
        address = pc;
        Icacheflag = 1;
        readmemory = 1;
        while( memorybusy ) {}
        compressed = IScompressed;
        switch( IScompressed ) {
            case 1b0: {
                // 32 bit instruction
                LOW = instruction32;
                address = pcPLUS2;
                readmemory = 1;
                while( memorybusy ) {}
                HIGH = readdata;
                instruction = HIGHLOW;
            }
            case 1b1: {
                // 16 bit compressed instruction
                instruction = instruction32;
            }
        }

        // DECODE + REGISTER FETCH
        // HAPPENS AUTOMATICALLY in DECODE AND REGISTER UNITS
        ++:
        ++:

        // EXECUTE
        switch( opCode[2,5] ) {
            case 5b01101: {
                // LUI
                writeRegister = 1;
                result = AUIPCLUI;
            }
            case 5b00101: {
                // AUIPC
                writeRegister = 1;
                result = AUIPCLUI;
            }
            case 5b11011: {
                // JAL
                writeRegister = 1;
                incPC = 0;
                result = nextPC;
            }
            case 5b11001: {
                // JALR
                writeRegister = 1;
                incPC = 0;
                result = nextPC;
            }
            case 5b11000: {
                // BRANCH
                takeBranch = BRANCHtakeBranch;
            }
            case 5b00000: {
                // LOAD
                writeRegister = 1;
                address = loadAddress;
                Icacheflag = 0;
                readmemory = 1;
                while( memorybusy ) {}
                switch( function3 & 3 ) {
                    case 2b10: {
                        // 32 bit READ as 2 x 16 bit
                        LOW = readdata;
                        address = loadAddressPLUS2;
                        readmemory = 1;
                        while( memorybusy ) {}
                        HIGH = readdata;
                        result = HIGHLOW;
                    }
                    default: {
                        // 8/16 bit with optional sign extension
                        result = ( ( function3 & 3 ) == 0 ) ? SE8sign : SE16sign;
                    }
                }
            }
            case 5b01000: {
                // STORE
                // WRITE 8, 16 and LOWER 16 of 32 bits
                address = storeAddress;
                Icacheflag = 0;
                writedata = sourceReg2LOW;
                writememory = 1;
                while( memorybusy ) {}
                if(  ( function3 & 3 ) == 2b10 ) {
                    // WRITE UPPER 16 of 32 bits
                    address = storeAddressPLUS2;
                    writedata = sourceReg2HIGH;
                    writememory = 1;
                    while( memorybusy ) {}
                }
            }
            case 5b00100: {
                // ALUI
                writeRegister = 1;
                result = ALUI.result;
            }
            case 5b01100: {
                // ALUR ( BASE + M EXTENSION )
                writeRegister = 1;
                if( function7[0,1] ) {
                    ALUM.start = 1;
                    while( ALUM.busy ) {}
                }
                result = function7[0,1] ? ALUM.result : ALUI.result;
            }
            case 5b11100: {
                // CSR
                writeRegister = 1;
                result = CSR.result;
            }
        }

        // WRITE TO REGISTERS
        registersW.writeRegister = writeRegister;

        // UPDATE PC
        pc = ( incPC ) ? ( takeBranch ? branchAddress : nextPC ) : ( opCode[3,1] ? jumpAddress : loadAddress );

        // Update CSRinstret
        CSR.incCSRinstret = 1;
    } // RISC-V
}

// RISC-V REGISTER WRITE
algorithm registersWRITE (
    input   uint5   rd,
    input   uint1   writeRegister,
    input   uint1   floatingpoint,
    input   int32   result,

    simple_dualbram_port1   registers_1,
    simple_dualbram_port1   registers_2
) <autorun> {
    registers_1.wenable1 := 1;
    registers_2.wenable1 := 1;

    while(1) {
        // WRITE TO REGISTERS
        // NEVER write to registers[0]
        if( writeRegister && ( rd != 0 ) ) {
            registers_1.addr1 = rd + ( floatingpoint ? 32 : 0 );
            registers_1.wdata1 = result;
            registers_2.addr1 = rd + ( floatingpoint ? 32 : 0 );
            registers_2.wdata1 = result;
        }
    }
}

// RISC-V REGISTER READ
algorithm registersREAD (
    input   uint5   rs1,
    input   uint5   rs2,
    input   uint1   floatingpoint,

    output! int32   sourceReg1,
    output! int32   sourceReg2,
    output! uint16  sourceReg2LOW,
    output! uint16  sourceReg2HIGH,

    simple_dualbram_port0   registers_1,
    simple_dualbram_port0   registers_2
) <autorun> {
    registers_1.addr0 := rs1 + ( floatingpoint ? 32 : 0 );
    registers_2.addr0 := rs2 + ( floatingpoint ? 32 : 0 );

    sourceReg1 := registers_1.rdata0;
    sourceReg2 := registers_2.rdata0;
    sourceReg2LOW := registers_2.rdata0[0,16];
    sourceReg2HIGH := registers_2.rdata0[16,16];

    while(1) {
    }
}

// RISC-V INSTRUCTION DECODER
algorithm decoder (
    input   uint32  instruction,

    output  uint7   opCode,
    output  uint3   function3,
    output  uint7   function7,

    output  uint5   rs1,
    output  uint5   rs2,
    output  uint5   rd,

    output  int32   immediateValue
) <autorun> {
    opCode := Utype(instruction).opCode;
    function3 := Rtype(instruction).function3;
    function7 := Rtype(instruction).function7;

    rs1 := Rtype(instruction).sourceReg1;
    rs2 := Rtype(instruction).sourceReg2;
    rd := Rtype(instruction).destReg;

    immediateValue := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Itype(instruction).immediate };

    while(1) {
    }
}

// RISC-V ADDRESS BASE/OFFSET GENERATOR
algorithm addressgenerator (
    input   uint32  instruction,
    input   uint32  pc,
    input   uint1   compressed,
    input!  int32   sourceReg1,

    output  uint32  pcPLUS2,
    output  uint32  nextPC,
    output  uint32  branchAddress,
    output  uint32  jumpAddress,
    output  uint32  AUIPCLUI,
    output! uint32  storeAddress,
    output! uint32  storeAddressPLUS2,
    output! uint32  loadAddress,
    output! uint32  loadAddressPLUS2
) <autorun> {
    uint7   opCode := Utype(instruction).opCode;
    int32   immediateValue := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Itype(instruction).immediate };

    pcPLUS2 := pc + 2;
    nextPC := pc + ( compressed ? 2 : 4 );

    branchAddress := { Btype(instruction).immediate_bits_12 ? 20b11111111111111111111 : 20b00000000000000000000, Btype(instruction).immediate_bits_11, Btype(instruction).immediate_bits_10_5, Btype(instruction).immediate_bits_4_1, 1b0 } + pc;

    jumpAddress := { Jtype(instruction).immediate_bits_20 ? 12b111111111111 : 12b000000000000, Jtype(instruction).immediate_bits_19_12, Jtype(instruction).immediate_bits_11, Jtype(instruction).immediate_bits_10_1, 1b0 } + pc;

    AUIPCLUI := { Utype(instruction).immediate_bits_31_12, 12b0 } + ( opCode[5,1] ? 0 : pc );

    storeAddress := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Stype(instruction).immediate_bits_11_5, Stype(instruction).immediate_bits_4_0 } + sourceReg1;
    storeAddressPLUS2 := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Stype(instruction).immediate_bits_11_5, Stype(instruction).immediate_bits_4_0 } + sourceReg1 + 2;

    loadAddress := immediateValue + sourceReg1;
    loadAddressPLUS2 := immediateValue + sourceReg1 + 2;

    while(1) {
    }
}

// BRANCH COMPARISIONS
algorithm branchcomparison (
    input   uint7   opCode,
    input   uint3   function3,
    input   int32   sourceReg1,
    input   int32   sourceReg2,
    output! uint1   takeBranch
) <autorun> {
    while(1) {
        // ONLY TRIGGER IF A BRANCH INSTRUCTION
        if( opCode == 7b1100011 ) {
            switch( function3 ) {
                case 3b000: { takeBranch = ( sourceReg1 == sourceReg2 ) ? 1 : 0; }
                case 3b001: { takeBranch = ( sourceReg1 != sourceReg2 ) ? 1 : 0; }
                case 3b100: { takeBranch = ( __signed(sourceReg1) < __signed(sourceReg2) ) ? 1 : 0; }
                case 3b101: { takeBranch = ( __signed(sourceReg1) >= __signed(sourceReg2) )  ? 1 : 0; }
                case 3b110: { takeBranch = ( __unsigned(sourceReg1) < __unsigned(sourceReg2) ) ? 1 : 0; }
                case 3b111: { takeBranch = ( __unsigned(sourceReg1) >= __unsigned(sourceReg2) ) ? 1 : 0; }
                default: { takeBranch = 0; }
            }
        }
    }
}

// RISC-V ALU BASE
algorithm aluI (
    input   uint32  instruction,
    input   int32   sourceReg1,
    input   int32   sourceReg2,

    input   uint1   start,
    output  uint1   busy,

    output  int32   result,
) <autorun> {
    uint7   opCode := Utype(instruction).opCode;
    uint3   function3 := Rtype(instruction).function3;
    uint7   function7 := Rtype(instruction).function7;
    int32   immediateValue := { instruction[31,1] ? 20b11111111111111111111 : 20b00000000000000000000, Itype(instruction).immediate };

    int32   shiftRIGHTA := __signed(sourceReg1) >>> ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );
    int32   shiftRIGHTL := __unsigned(sourceReg1) >> ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount );

    uint1   SLT := __signed( sourceReg1 ) < __signed(sourceReg2) ? 1 : 0;
    uint1   SLTI := __signed( sourceReg1 ) < __signed(immediateValue) ? 1 : 0;
    uint1   SLTU := ( Rtype(instruction).sourceReg1 == 0 ) ? ( ( sourceReg2 != 0 ) ? 1 : 0 ) : ( ( __unsigned( sourceReg1 ) < __unsigned( sourceReg2 ) ) ? 1 : 0 );
    uint1   SLTUI := ( immediateValue == 1 ) ? ( ( sourceReg1 == 0 ) ? 1 : 0 ) : ( ( __unsigned( sourceReg1 ) < __unsigned( immediateValue ) ) ? 1 : 0 );

    while(1) {
        // BASE ALU - ONLY TRIGGER IF ALU OPERATION
        //if( ( opCode == 7b0010011 ) || ( opCode == 7b0110011 ) ) {
            switch( function3 ) {
                case 3b000: { result = sourceReg1 + ( opCode[5,1] ? ( function7[5,1] ? -( sourceReg2 ) : sourceReg2 ) : immediateValue ); }
                case 3b001: { result = __unsigned(sourceReg1) << ( opCode[5,1] ? sourceReg2[0,5] : ItypeSHIFT( instruction ).shiftCount ); }
                case 3b010: { result = ( opCode[5,1] ? SLT : SLTI ) ? 32b1 : 32b0; }
                case 3b011: { result = ( opCode[5,1] ? SLTU : SLTUI ) ? 32b1 : 32b0; }
                case 3b100: { result = sourceReg1 ^ ( opCode[5,1] ? sourceReg2 : immediateValue ); }
                case 3b101: { result = function7[5,1] ? shiftRIGHTA : shiftRIGHTL; }
                case 3b110: { result = sourceReg1 | ( opCode[5,1] ? sourceReg2 : immediateValue ); }
                case 3b111: { result = sourceReg1 & ( opCode[5,1] ? sourceReg2 : immediateValue ); }
            }
        //}
    }
}

// RISC-V ALU M EXTENSION
algorithm aluM (
    input   uint3   function3,
    input   int32   sourceReg1,
    input   int32   sourceReg2,

    input   uint1   start,
    output  uint1   busy,

    output  int32  result
) <autorun> {
    // MULTIPLICATION and DIVISION units
    divideremainder dividerunit (
        function3 <: function3,
        dividend <: sourceReg1,
        divisor <: sourceReg2
    );
    multiplicationDSP multiplicationuint (
        function3 <: function3,
        factor_1 <: sourceReg1,
        factor_2 <: sourceReg2
    );

    uint1   active = 0;
    busy := start ? 1 : active;

    // MULTIPLICATION and DIVISION Start Flags
    dividerunit.start := 0;
    multiplicationuint.start := 0;

    while(1) {
        if( start ) {
            switch( function3[2,1] ) {
                case 1b0: {
                    // MULTIPLICATION
                    active = 1;
                    multiplicationuint.start = 1;
                    while( multiplicationuint.active ) {}
                    result = multiplicationuint.result;
                    active = 0;
                }
                case 1b1: {
                    // DIVISION / REMAINDER
                    active = 1;
                    dividerunit.start = 1;
                    while( dividerunit.active ) {}
                    result = dividerunit.result;
                    active = 0;
                }
            }
        }
    }
}

// EXPAND RISC-V 16 BIT COMPRESSED INSTRUCTIONS TO THEIR 32 BIT EQUIVALENT
algorithm compressedexpansion (
    input!  uint16  instruction16,
    output! uint32  instruction32,
    output! uint1   compressed
) <autorun> {
    while(1) {
        switch( instruction16[0,2] ) {
            case 2b00: {
                compressed = 1;

                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // ADDI4SPN -> addi rd', x2, nzuimm[9:2]
                        // { 000, nzuimm[5:4|9:6|2|3] rd' 00 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32 = { 2b0, CIu94(instruction16).ib_9_6, CIu94(instruction16).ib_5_4, CIu94(instruction16).ib_3, CIu94(instruction16).ib_2, 2b00, 5h2, 3b000, {2b01,CIu94(instruction16).rd_alt}, 7b0010011 };
                    }
                    case 3b001: {
                        // FLD
                    }
                    case 3b010: {
                        // LW -> lw rd', offset[6:2](rs1')
                        // { 010 uimm[5:3] rs1' uimm[2][6] rd' 00 } -> { imm[11:0] rs1 010 rd 0000011 }
                        instruction32 = { 5b0, CL(instruction16).ib_6, CL(instruction16).ib_5_3, CL(instruction16).ib_2, 2b00, {2b01,CL(instruction16).rs1_alt}, 3b010, {2b01,CL(instruction16).rd_alt}, 7b0000011};
                    }
                    case 3b011: {
                        // FLW
                    }
                    case 3b100: {
                        // reserved
                    }
                    case 3b101: {
                        // FSD
                    }
                    case 3b110: {
                        // SW -> sw rs2', offset[6:2](rs1')
                        // { 110 uimm[5:3] rs1' uimm[2][6] rs2' 00 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                        instruction32 = { 5b0, CS(instruction16).ib_6, CS(instruction16).ib_5, {2b01,CS(instruction16).rs2_alt}, {2b01,CS(instruction16).rs1_alt}, 3b010, CS(instruction16).ib_4_3, CS(instruction16).ib_2, 2b0, 7b0100011 };
                    }
                    case 3b111: {
                        // FSW
                    }
                }
            }

            case 2b01: {
                compressed = 1;

                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // ADDI -> addi rd, rd, nzimm[5:0]
                        // { 000 nzimm[5] rs1/rd!=0 nzimm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32 = { CI50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CI50(instruction16).ib_4_0, CI50(instruction16).rd, 3b000, CI50(instruction16).rd, 7b0010011 };
                    }
                    case 3b001: {
                        // JAL -> jal x1, offset[11:1]
                        // { 001, imm[11|4|9:8|10|6|7|3:1|5] 01 } -> { imm[20|10:1|11|19:12] rd 1101111 }
                        instruction32 = { CJ(instruction16).ib_11, CJ(instruction16).ib_10, CJ(instruction16).ib_9_8, CJ(instruction16).ib_7, CJ(instruction16).ib_6, CJ(instruction16).ib_5, CJ(instruction16).ib_4, CJ(instruction16).ib_3_1, CJ(instruction16).ib_11 ? 9b111111111 : 9b000000000, 5h1, 7b1101111 };
                    }
                    case 3b010: {
                        // LI -> addi rd, x0, imm[5:0]
                        // { 010 imm[5] rd!=0 imm[4:0] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                        instruction32 = { CI50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CI50(instruction16).ib_4_0, 5h0, 3b000, CI(instruction16).rd, 7b0010011 };
                    }
                    case 3b011: {
                        // LUI / ADDI16SP
                        if( ( CI(instruction16).rd != 0 ) && ( CI(instruction16).rd != 2 ) ) {
                            // LUI -> lui rd, nzuimm[17:12]
                            // { 011 nzimm[17] rd!={0,2} nzimm[16:12] 01 } -> { imm[31:12] rd 0110111 }
                            instruction32 = { CIlui(instruction16).ib_17 ? 15b111111111111111 : 15b000000000000000, CIlui(instruction16).ib_16_12, CIlui(instruction16).rd, 7b0110111 };
                        } else {
                            // ADDI16SP -> addi x2, x2, nzimm[9:4]
                            // { 011 nzimm[9] 00010 nzimm[4|6|8:7|5] 01 } -> { imm[11:0] rs1 000 rd 0010011 }
                            instruction32 = { CI94(instruction16).ib_9 ? 3b111 : 3b000, CI94(instruction16).ib_8_7, CI94(instruction16).ib_6, CI94(instruction16).ib_5, CI94(instruction16).ib_4, 4b0000, 5h2, 3b000, 5h2, 7b0010011 };
                        }
                    }
                    case 3b100: {
                        // MISC-ALU
                        switch( CBalu(instruction16).function2 ) {
                            case 2b00: {
                                // SRLI -> srli rd', rd', shamt[5:0]
                                // { 100 nzuimm[5] 00 rs1'/rd' nzuimm[4:0] 01 } -> { 0000000 shamt rs1 101 rd 0010011 }
                                instruction32 = { 7b0000000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b101, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b01: {
                                // SRAI -> srai rd', rd', shamt[5:0]
                                // { 100 nzuimm[5] 01 rs1'/rd' nzuimm[4:0] 01 } -> { 0100000 shamt rs1 101 rd 0010011 }
                                instruction32 = { 7b0100000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b101, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b10: {
                                // ANDI -> andi rd', rd', imm[5:0]
                                // { 100 imm[5], 10 rs1'/rd' imm[4:0] 01 } -> { imm[11:0] rs1 111 rd 0010011 }
                                instruction32 = { CBalu50(instruction16).ib_5 ? 7b1111111 : 7b0000000, CBalu50(instruction16).ib_4_0, { 2b01, CBalu50(instruction16).rd_alt }, 3b111, { 2b01, CBalu50(instruction16).rd_alt }, 7b0010011 };
                            }
                            case 2b11: {
                                // SUB XOR OR AND
                                switch( CBalu(instruction16).logical2 ) {
                                    case 2b00: {
                                        //SUB -> sub rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 00 rs2' 01 } -> { 0100000 rs2 rs1 000 rd 0110011 }
                                        instruction32 = { 7b0100000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b000, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b01: {
                                        // XOR -> xor rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 01 rs2' 01 } -> { 0000000 rs2 rs1 100 rd 0110011 }
                                        instruction32 = { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b100, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b10: {
                                        // OR -> or rd', rd', rd2'
                                        // { 100 0 11 rs1'/rd' 10 rs2' 01 } -> { 0000000 rs2 rs1 110 rd 0110011 }
                                        instruction32 = { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b110, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                    case 2b11: {
                                        // AND -> and rd', rd', rs2'
                                        // { 100 0 11 rs1'/rd' 11 rs2' 01 } -> { 0000000 rs2 rs1 111 rd 0110011 }
                                        instruction32 = { 7b0000000, { 2b01, CBalu(instruction16).rs2_alt }, { 2b01, CBalu(instruction16).rd_alt }, 3b111, { 2b01, CBalu(instruction16).rd_alt }, 7b0110011 };
                                    }
                                }
                            }
                        }
                    }
                    case 3b101: {
                        // J -> jal, x0, offset[11:1]
                        // { 101, imm[11|4|9:8|10|6|7|3:1|5] 01 } -> { imm[20|10:1|11|19:12] rd 1101111 }
                        instruction32 = { CJ(instruction16).ib_11, CJ(instruction16).ib_10, CJ(instruction16).ib_9_8, CJ(instruction16).ib_7, CJ(instruction16).ib_6, CJ(instruction16).ib_5, CJ(instruction16).ib_4, CJ(instruction16).ib_3_1, CJ(instruction16).ib_11 ? 9b111111111 : 9b000000000, 5h0, 7b1101111 };
                    }
                    case 3b110: {
                        // BEQZ -> beq rs1', x0, offset[8:1]
                        // { 110, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 000 imm[4:1|11] 1100011 }
                        instruction32 = { CB(instruction16).offset_8 ? 4b1111 : 4b0000, CB(instruction16).offset_7_6, CB(instruction16).offset_5, 5h0, {2b01,CB(instruction16).rs1_alt}, 3b000, CB(instruction16).offset_4_3, CB(instruction16).offset_2_1, CB(instruction16).offset_8, 7b1100011 };
                    }
                    case 3b111: {
                        // BNEZ -> bne rs1', x0, offset[8:1]
                        // { 111, imm[8|4:3] rs1' imm[7:6|2:1|5] 01 } -> { imm[12|10:5] rs2 rs1 001 imm[4:1|11] 1100011 }
                        instruction32 = { CB(instruction16).offset_8 ? 4b1111 : 4b0000, CB(instruction16).offset_7_6, CB(instruction16).offset_5, 5h0, {2b01,CB(instruction16).rs1_alt}, 3b001, CB(instruction16).offset_4_3, CB(instruction16).offset_2_1, CB(instruction16).offset_8, 7b1100011 };
                    }
                }
            }

            case 2b10: {
                compressed = 1;

                switch( instruction16[13,3] ) {
                    case 3b000: {
                        // SLLI -> slli rd, rd, shamt[5:0]
                        // { 000, nzuimm[5], rs1/rd!=0 nzuimm[4:0] 10 } -> { 0000000 shamt rs1 001 rd 0010011 }
                        instruction32 = { 7b0000000, CI50(instruction16).ib_4_0, CI50(instruction16).rd, 3b001, CI50(instruction16).rd, 7b0010011 };
                    }
                    case 3b001: {
                        // FLDSP
                    }
                    case 3b010: {
                        // LWSP -> lw rd, offset[7:2](x2)
                        // { 011 uimm[5] rd uimm[4:2|7:6] 10 } -> { imm[11:0] rs1 010 rd 0000011 }
                        instruction32 = { 4b0, CI(instruction16).ib_7_6, CI(instruction16).ib_5, CI(instruction16).ib_4_2, 2b0, 5h2 ,3b010, CI(instruction16).rd, 7b0000011 };
                    }
                    case 3b011: {
                        // FLWSP
                    }
                    case 3b100: {
                        // J[AL]R / MV / ADD
                        switch( instruction16[12,1] ) {
                            case 1b0: {
                                // JR / MV
                                if( CR(instruction16).rs2 == 0 ) {
                                    // JR -> jalr x0, rs1, 0
                                    // { 100 0 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                                    instruction32 = { 12b0, CR(instruction16).rs1, 3b000, 5h0, 7b1100111 };
                                } else {
                                    // MV -> add rd, x0, rs2
                                    // { 100 0 rd!=0 rs2!=0 10 } -> { 0000000 rs2 rs1 000 rd 0110011 }
                                    instruction32 = { 7b0000000, CR(instruction16).rs2, 5h0, 3b000, CR(instruction16).rs1, 7b0110011 };
                                }
                            }
                            case 1b1: {
                                // JALR / ADD
                                if( CR(instruction16).rs2 == 0 ) {
                                    // JALR -> jalr x1, rs1, 0
                                    // { 100 1 rs1 00000 10 } -> { imm[11:0] rs1 000 rd 1100111 }
                                    instruction32 = { 12b0, CR(instruction16).rs1, 3b000, 5h1, 7b1100111 };
                                } else {
                                    // ADD -> add rd, rd, rs2
                                    // { 100 1 rs1/rd!=0 rs2!=0 10 } -> { 0000000 rs2 rs1 000 rd 0110011 }
                                    instruction32 = { 7b0000000, CR(instruction16).rs2, CR(instruction16).rs1, 3b000, CR(instruction16).rs1, 7b0110011 };
                                }
                            }
                        }
                    }
                    case 3b101: {
                        // FSDSP
                    }
                    case 3b110: {
                        // SWSP -> sw rs2, offset[7:2](x2)
                        // { 110 uimm[5][4:2][7:6] rs2 10 } -> { imm[11:5] rs2 rs1 010 imm[4:0] 0100011 }
                        instruction32 = { 4b0, CSS(instruction16).ib_7_6, CSS(instruction16).ib_5, CSS(instruction16).rs2, 5h2, 3b010, CSS(instruction16).ib_4_2, 2b00, 7b0100011 };
                    }
                    case 3b111: {
                        // FSWSP
                    }
                }
            }

            case 2b11: {
                compressed = 0;
                instruction32 = { 16h0000, instruction16 };
            }
        }
    }
}

algorithm CSRblock (
    input   uint32  instruction,
    input   uint1   incCSRinstret,
    output  uint32  result
) <autorun> {
    // RDCYCLE[H] and RDTIME[H] are equivalent on PAWSCPU
    uint64  CSRcycletime = 0;
    uint64  CSRinstret = 0;

    CSRcycletime := CSRcycletime + 1;
    CSRinstret := CSRinstret + ( incCSRinstret ? 1 : 0 );

    while(1) {
        if( ( CSR(instruction).rs1 == 0 ) && ( CSR(instruction).function3 == 3b010 ) ) {
            switch( CSR(instruction).csr ) {
                case 12hc00: {
                    result = CSRcycletime[0,32];
                }
                case 12hc80: {
                    result = CSRcycletime[32,32];
                }
                case 12hc01: {
                    result = CSRcycletime[0,32];
                }
                case 12hc81: {
                    result = CSRcycletime[32,32];
                }
                case 12hc02: {
                    result = CSRinstret[0,32];
                }
                case 12hc82: {
                    result = CSRinstret[32,32];
                }
                default: {
                    result = 0;
                }
            }
        } else {
            result = 0;
        }
    }
}

// MATHEMATICAL UNITS

// UNSIGNED / SIGNED 32 by 32 bit division giving 32 bit remainder and quotient
algorithm divideremainder (
    input   uint3   function3,

    input   uint32  dividend,
    input   uint32  divisor,

    input   uint1   start,
    output  uint1   active,

    output  uint32  result,
) <autorun> {
    uint32  quotient = uninitialized;
    uint32  remainder = uninitialized;
    uint32  dividend_copy := ~function3[0,1] ? ( dividend[31,1] ? -dividend : dividend ) : dividend;
    uint32  divisor_copy := ~function3[0,1] ? ( divisor[31,1] ? -divisor : divisor ) :divisor;
    uint1   resultsign := ~function3[0,1] ? dividend[31,1] != divisor[31,1] : 0;
    uint6   bit = uninitialized;
    uint6   count = uninitialized;

    uint1   busy = 0;
    active := start ? 1 : busy;

    result := function3[1,1] ? remainder : ( resultsign ? -quotient : quotient );

    while(1) {
        if( start ) {
            busy = 1;
            bit = 31;
            if( divisor == 0 ) {
                // DIVISON by ZERO
                quotient = 32hffffffff;
                remainder = dividend;
                busy = 0;
            } else {
                quotient = 0;
                remainder = 0;
                ++:
                while( bit != 63 ) {
                    if( __unsigned({ remainder[0,31], dividend_copy[bit,1] }) >= __unsigned(divisor_copy) ) {
                        remainder = __unsigned({ remainder[0,31], dividend_copy[bit,1] }) - __unsigned(divisor_copy);
                        quotient[bit,1] = 1;
                    } else {
                        remainder = { remainder[0,31], dividend_copy[bit,1] };
                    }
                    bit = bit - 1;
                }
                ++:
                busy = 0;
            }
        }
    }
}

// UNSIGNED / SIGNED 32 by 32 bit multiplication giving 64 bit product using DSP blocks
algorithm multiplicationDSP (
    input   uint3   function3,

    input   uint32  factor_1,
    input   uint32  factor_2,

    input   uint1   start,
    output  uint1   active,

    output  uint32  result
) <autorun> {
    uint32  factor_1_copy := ( dosigned == 0 ) ? factor_1 : ( ( factor_1[31,1] ) ? -factor_1 : factor_1 );
    uint32  factor_2_copy := ( dosigned != 1 ) ? factor_2 : ( ( factor_2[31,1] ) ? -factor_2 : factor_2 );
    uint64  product = uninitialized;

    // CALCULATION AB * CD
    uint18  A := { 2b0, factor_1_copy[16,16] };
    uint18  B := { 2b0, factor_1_copy[0,16] };
    uint18  C := { 2b0, factor_2_copy[16,16] };
    uint18  D := { 2b0, factor_2_copy[0,16] };

    // FULLY SIGNED / PARTIALLY SIGNED / UNSIGNED and RESULT SIGNED FLAGS
    uint2   dosigned := function3[1,1] ? ( function3[0,1] ? 0 : 2 ) : 1;
    uint1   resultsign := ( dosigned == 0 ) ? 0 : ( ( dosigned == 1 ) ? ( factor_1[31,1] != factor_2[31,1] ) : factor_1[31,1] );

    uint1   busy = 0;
    active := start ? 1 : busy;

    result := ( function3 == 0 ) ? product[0,32] : product[32,32];

    while(1) {
        if( start ) {
            busy = 1;
            ++:
            product = D*B + { D*A, 16b0 } + { C*B, 16b0 } + { C*A, 32b0 };
            ++:
            product = resultsign ? -product : product;
            ++:
            busy = 0;
        }
    }
}

// PERFORM OPTIONAL SIGN EXTENSION FOR 8 BIT AND 16 BIT READS
algorithm signextender8 (
    input   uint3   function3,
    input!  uint8  nosign,
    output! uint32  withsign
) <autorun> {
    withsign := { ( ( nosign[7,1] & ~function3[2,1] ) ? 24hffffff : 24h000000 ), nosign[0,8] };
    while(1) {
    }
}

algorithm signextender16 (
    input   uint3   function3,
    input!  uint16  nosign,
    output! uint32  withsign
) <autorun> {
    withsign := { ( nosign[15,1] & ~function3[2,1] ) ? 16hffff : 16h0000, nosign };
    while(1) {
    }
}

// COMBINE TWO 16 BIT HALF WORDS TO 32 BIT WORD
algorithm halfhalfword (
    input   uint16  HIGH,
    input   uint16  LOW,
    output! int32   HIGHLOW,
    output! int32   ZEROLOW
) <autorun> {
    HIGHLOW := { HIGH, LOW };
    ZEROLOW := { 16b0, LOW };

    while(1) {
    }
}


// CLOCKS
import('../common/ulx3s_clk_risc_ice_v.v')
import('../common/ulx3s_clk_risc_ice_v_2.v')

algorithm main(
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // HDMI OUTPUT
    output  uint4   gpdi_dp,
    output  uint4   gpdi_dn,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // SDCARD
    output! uint1   sd_clk,
    output! uint1   sd_mosi,
    output! uint1   sd_csn,
    input   uint1   sd_miso,

    // SDRAM
    output! uint1  sdram_cle,
    output! uint2  sdram_dqm,
    output! uint1  sdram_cs,
    output! uint1  sdram_we,
    output! uint1  sdram_cas,
    output! uint1  sdram_ras,
    output! uint2  sdram_ba,
    output! uint13 sdram_a,
    output! uint1  sdram_clk,  // sdram chip clock != internal sdram_clock
    inout   uint16 sdram_dq
) <@clock_memory> {
    // CLOCK/RESET GENERATION

    // CPU DOMAIN CLOCKS
    uint1   pll_lock_CPU = uninitialized;
    uint1   cpu_clock = uninitialized;
    uint1   clock_copro = uninitialized;
    uint1   clock_memory = uninitialized;
    // Generate 50MHz clocks for CPU units
    // 50MHz clock for the BRAM and CACHE controller
    ulx3s_clk_risc_ice_v_CPU clk_gen_CPU (
        clkin    <: clock,
        clkCPU :> cpu_clock,
        clkCOPRO :> clock_copro,
        clkMEMORY  :> clock_memory,
        locked   :> pll_lock_CPU
    );

    // SDRAM + I/O DOMAIN CLOCKS
    uint1   clock_IO = uninitialized;
    uint1   sdram_clock = uninitialized;
    uint1   sdram_reset = uninitialized;
    uint1   video_reset = uninitialized;
    uint1   video_clock = uninitialized;
    uint1   pll_lock_AUX = uninitialized;
    ulx3s_clk_risc_ice_v_AUX clk_gen_AUX (
        clkin   <: clock,
        clkIO :> clock_IO,
        clkVIDEO :> video_clock,
        clkSDRAM :> sdram_clock,
        clkSDRAMcontrol :> sdram_clk,
        locked :> pll_lock_AUX
    );

    // Video Reset
    clean_reset video_rstcond<@video_clock,!reset> (
        out :> video_reset
    );

    // SDRAM Reset
    clean_reset sdram_rstcond<@sdram_clock,!reset> (
        out :> sdram_reset
    );

    // Status of the screen, if in range, if in vblank, actual pixel x and y
    uint1   vblank = uninitialized;
    uint1   pix_active = uninitialized;
    uint10  pix_x  = uninitialized;
    uint10  pix_y  = uninitialized;

    // VGA or HDMI driver
    uint8   video_r = uninitialized;
    uint8   video_g = uninitialized;
    uint8   video_b = uninitialized;

    hdmi video<@clock,!reset> (
        vblank  :> vblank,
        active  :> pix_active,
        x       :> pix_x,
        y       :> pix_y,
        gpdi_dp :> gpdi_dp,
        gpdi_dn :> gpdi_dn,
        red     <: video_r,
        green   <: video_g,
        blue    <: video_b
    );

    // RAM - BRAM and SDRAM
    // SDRAM chip controller
    // interface
    sdram_r16w16_io sio_fullrate;
    sdram_r16w16_io sio_halfrate;
    sdram_half_speed_access sdaccess <@sdram_clock,!sdram_reset> (
            sd      <:> sio_fullrate,
            sdh     <:> sio_halfrate,
    );
    // algorithm
    sdram_controller_autoprecharge_r16_w16 sdram32MB <@sdram_clock,!sdram_reset> (
        sd        <:> sio_fullrate,
        sdram_cle :>  sdram_cle,
        sdram_dqm :>  sdram_dqm,
        sdram_cs  :>  sdram_cs,
        sdram_we  :>  sdram_we,
        sdram_cas :>  sdram_cas,
        sdram_ras :>  sdram_ras,
        sdram_ba  :>  sdram_ba,
        sdram_a   :>  sdram_a,
        sdram_dq  <:> sdram_dq
    );

    // SDRAM and BRAM (for BIOS)
    // FUNCTION3 controls byte read/writes
    sdramcontroller sdram <@clock_memory> (
        function3 <: function3,
        sio <:> sio_halfrate,
        Icache <: Icacheflag,
        address <: address,
        writedata <: writedata,
    );
    bramcontroller ram <@clock_memory> (
        function3 <: function3,
        address <: address,
        writedata <: writedata,
    );

    // MEMORY MAPPED I/O
    memmap_io IO_Map <@clock_IO> (
        leds :> leds,
        btns <: btns,
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,
        audio_l :> audio_l,
        audio_r :> audio_r,
        sd_clk :> sd_clk,
        sd_mosi :> sd_mosi,
        sd_csn :> sd_csn,
        sd_miso <: sd_miso,
        video_r :> video_r,
        video_g :> video_g,
        video_b :> video_b,
        vblank <: vblank,
        pix_active <: pix_active,
        pix_x <: pix_x,
        pix_y <: pix_y,

        video_clock <: video_clock,
        video_reset <: video_reset,

        memoryAddress <: address,
        writeData <: writedata
    );

    uint3   function3 = uninitialized;
    uint32  address = uninitialized;
    uint16  writedata = uninitialized;
    uint1   Icacheflag = uninitialized;
    PAWSCPU CPU <@cpu_clock> (
        function3 :> function3,

        address :> address,
        writedata :> writedata,
        Icacheflag :> Icacheflag,

        clock_copro <: clock_copro
    );

    CPU.memorybusy := sdram.busy;

    // I/O and RAM read/write flags
    sdram.writeflag := CPU.writememory && address[28,1];
    sdram.readflag := CPU.readmemory && address[28,1];
    ram.writeflag := CPU.writememory && ~address[28,1] && ~address[15,1];
    ram.readflag := CPU.readmemory && ~address[28,1] && ~address[15,1];
    IO_Map.memoryWrite := CPU.writememory && ~address[28,1] && address[15,1];
    IO_Map.memoryRead := CPU.readmemory && ~address[28,1] && address[15,1];

    CPU.readdata := address[28,1] ? sdram.readdata : ( address[15,1] ? IO_Map.readData : ram.readdata );

    while(1) {
    }
}

// RAM - BRAM controller
// MEMORY IS 16 BIT, 8 bit WRITES ARE READ MODIFY WRITE
// 8 and 16 bit READS ARE SIGN EXTENDED
algorithm bramcontroller (
    input   uint32  address,
    input   uint3   function3,

    input   uint1   writeflag,
    input   uint16  writedata,

    input   uint1   readflag,
    output  uint16  readdata,
) <autorun> {
    // RISC-V RAM and BIOS
    bram uint16 ram <input!> [12288] = {
    16h6137, 16h0000, 16h0097, 16h0000,
    16h80e7, 16h2760, 16h0317, 16h0000,
    16h0067, 16h0083, 16h0000, 16h0000,
    16h8082, 16h1141, 16hc606, 16h0713,
    16h0640, 16h0693, 16h0640, 16h4601,
    16h4581, 16h0513, 16h0380, 16h0097,
    16h0000, 16h80e7, 16h7c00, 16h0813,
    16h0640, 16h0793, 16h0320, 16h0713,
    16h0640, 16h0693, 16h0640, 16h0613,
    16h0210, 16h0593, 16h0640, 16h0513,
    16h03f0, 16h1097, 16h0000, 16h80e7,
    16h9cc0, 16h0813, 16h0640, 16h0793,
    16h0420, 16h0713, 16h0640, 16h0693,
    16h0640, 16h0613, 16h0320, 16h0593,
    16h0640, 16h4509, 16h1097, 16h0000,
    16h80e7, 16h9aa0, 16h0713, 16h0320,
    16h0693, 16h0210, 16h4601, 16h4581,
    16h4509, 16h0097, 16h0000, 16h80e7,
    16h7640, 16h4705, 16h46e9, 16h4665,
    16h45e5, 16h0513, 16h03f0, 16h1097,
    16h0000, 16h80e7, 16h8340, 16h4731,
    16h46e5, 16h4601, 16h4581, 16h0513,
    16h03f0, 16h0097, 16h0000, 16h80e7,
    16h73c0, 16h4705, 16h46b1, 16h4665,
    16h45e5, 16h4509, 16h1097, 16h0000,
    16h80e7, 16h80e0, 16h0813, 16h0640,
    16h4781, 16h0713, 16h0640, 16h0693,
    16h0430, 16h0613, 16h0210, 16h4581,
    16h0513, 16h03f0, 16h1097, 16h0000,
    16h80e7, 16h93a0, 16h0813, 16h0640,
    16h4781, 16h0713, 16h0640, 16h0693,
    16h0320, 16h0613, 16h0320, 16h4581,
    16h4509, 16h1097, 16h0000, 16h80e7,
    16h91c0, 16h0713, 16h0250, 16h46e5,
    16h4631, 16h4581, 16h4509, 16h0097,
    16h0000, 16h80e7, 16h6d80, 16h0713,
    16h0640, 16h46a1, 16h0613, 16h0250,
    16h4581, 16h4509, 16h0097, 16h0000,
    16h80e7, 16h6c20, 16h40b2, 16h0141,
    16h8082, 16h1101, 16hce06, 16hcc22,
    16hca26, 16hc84a, 16hc64e, 16h892a,
    16h842e, 16h1537, 16h0000, 16h0513,
    16he185, 16h0097, 16h0000, 16h80e7,
    16h45e0, 16h5793, 16h0044, 16hc7b5,
    16h0493, 16h0109, 16h0792, 16h09b3,
    16h00f9, 16h854a, 16h0097, 16h0000,
    16h80e7, 16h4f20, 16h0513, 16h03a0,
    16h0097, 16h0000, 16h80e7, 16h3e20,
    16h0513, 16h0200, 16h0097, 16h0000,
    16h80e7, 16h3d60, 16h844a, 16h4503,
    16h0004, 16h0097, 16h0000, 16h80e7,
    16h4740, 16h0513, 16h0200, 16h0097,
    16h0000, 16h80e7, 16h3bc0, 16h0405,
    16h13e3, 16hfe94, 16h0941, 16h4529,
    16h0097, 16h0000, 16h80e7, 16h3aa0,
    16h0513, 16h1f40, 16h0097, 16h0000,
    16h80e7, 16h5100, 16h04c1, 16h92e3,
    16hfb29, 16h40f2, 16h4462, 16h44d2,
    16h4942, 16h49b2, 16h6105, 16h8082,
    16h1101, 16hce06, 16hcc22, 16hca26,
    16hc84a, 16hc64e, 16h892a, 16h842e,
    16h1537, 16h0000, 16h0513, 16he2c5,
    16h0097, 16h0000, 16h80e7, 16h3c00,
    16h5793, 16h0044, 16hcba5, 16h0493,
    16h0209, 16h0796, 16h09b3, 16h00f9,
    16h854a, 16h0097, 16h0000, 16h80e7,
    16h4540, 16h0513, 16h03a0, 16h0097,
    16h0000, 16h80e7, 16h3440, 16h0513,
    16h0200, 16h0097, 16h0000, 16h80e7,
    16h3380, 16h844a, 16h5503, 16h0004,
    16h0097, 16h0000, 16h80e7, 16h3fe0,
    16h0513, 16h0200, 16h0097, 16h0000,
    16h80e7, 16h31e0, 16h0409, 16h13e3,
    16hfe94, 16h0913, 16h0209, 16h4529,
    16h0097, 16h0000, 16h80e7, 16h30a0,
    16h0513, 16h1f40, 16h0097, 16h0000,
    16h80e7, 16h4700, 16h8493, 16h0204,
    16h90e3, 16hfb29, 16h40f2, 16h4462,
    16h44d2, 16h4942, 16h49b2, 16h6105,
    16h8082, 16h1141, 16hc606, 16hc422,
    16hc226, 16hc04a, 16h0097, 16h0000,
    16h80e7, 16h5c60, 16h1097, 16h0000,
    16h80e7, 16h8060, 16h4601, 16h4581,
    16h4505, 16h0097, 16h0000, 16h80e7,
    16h4f60, 16h0097, 16h0000, 16h80e7,
    16hd780, 16h0693, 16h03f0, 16h0613,
    16h0400, 16h4595, 16h4541, 16h1097,
    16h0000, 16h80e7, 16h8240, 16h1537,
    16h0000, 16h0513, 16he405, 16h1097,
    16h0000, 16h80e7, 16h8940, 16h6505,
    16h0513, 16hfa05, 16h0097, 16h0000,
    16h80e7, 16h3f80, 16h07b7, 16h1000,
    16h0737, 16h1000, 16h0713, 16h0ff7,
    16h8023, 16h00f7, 16h0785, 16h9de3,
    16hfee7, 16h0737, 16h1000, 16h0713,
    16h1007, 16h4781, 16h0693, 16h1000,
    16h1023, 16h00f7, 16h0785, 16h07c2,
    16h83c1, 16h0709, 16h9ae3, 16hfed7,
    16h1537, 16h0000, 16h0513, 16he685,
    16h0097, 16h0000, 16h80e7, 16h2980,
    16h0593, 16h1000, 16h0537, 16h1000,
    16h0097, 16h0000, 16h80e7, 16he120,
    16h1537, 16h0000, 16h0513, 16he8c5,
    16h0097, 16h0000, 16h80e7, 16h2780,
    16h0593, 16h1000, 16h0437, 16h1000,
    16h0513, 16h1004, 16h0097, 16h0000,
    16h80e7, 16he8c0, 16h0713, 16h1004,
    16h4781, 16h6685, 16h1023, 16h00f7,
    16h0785, 16h07c2, 16h83c1, 16h0709,
    16h9ae3, 16hfed7, 16h1537, 16h0000,
    16h0513, 16heb45, 16h0097, 16h0000,
    16h80e7, 16h23c0, 16h1537, 16h0000,
    16h0513, 16hecc5, 16h0097, 16h0000,
    16h80e7, 16h22c0, 16h0593, 16h1000,
    16h0537, 16h1000, 16h0097, 16h0000,
    16h80e7, 16hda60, 16h1537, 16h0000,
    16h0513, 16hefc5, 16h0097, 16h0000,
    16h80e7, 16h20c0, 16h0593, 16h1000,
    16h0537, 16h1000, 16h0513, 16h1005,
    16h0097, 16h0000, 16h80e7, 16he200,
    16h0097, 16h0000, 16h80e7, 16h1000,
    16h84aa, 16h0097, 16h0000, 16h80e7,
    16h0fc0, 16h842a, 16h1537, 16h0000,
    16h0513, 16hf305, 16h0097, 16h0000,
    16h80e7, 16h2040, 16h8526, 16h0097,
    16h0000, 16h80e7, 16h2780, 16h1537,
    16h0000, 16h0513, 16hf405, 16h0097,
    16h0000, 16h80e7, 16h1ea0, 16h8522,
    16h0097, 16h0000, 16h80e7, 16h25e0,
    16ha029, 16h0097, 16h0000, 16h80e7,
    16h2a20, 16h0097, 16h0000, 16h80e7,
    16h28a0, 16hf965, 16h1537, 16h0000,
    16h0513, 16hf505, 16h0097, 16h0000,
    16h80e7, 16h18c0, 16h1937, 16h0000,
    16h14b7, 16h0000, 16h0097, 16h0000,
    16h80e7, 16h2780, 16h842a, 16h0513,
    16hf6c9, 16h0097, 16h0000, 16h80e7,
    16h19e0, 16h8522, 16h0097, 16h0000,
    16h80e7, 16h10e0, 16h8513, 16hf7c4,
    16h0097, 16h0000, 16h80e7, 16h1580,
    16h8522, 16h0097, 16h0000, 16h80e7,
    16h3200, 16hb7e9, 16h962e, 16h8963,
    16h00c5, 16h0585, 16hc783, 16h0005,
    16h0023, 16h00f5, 16h1be3, 16hfeb6,
    16h8082, 16h872a, 16h4783, 16h0005,
    16hcb89, 16h4501, 16h0505, 16h07b3,
    16h00a7, 16hc783, 16h0007, 16hfbfd,
    16h8082, 16h4501, 16h8082, 16h4783,
    16h0005, 16hcb91, 16hc703, 16h0005,
    16h1763, 16h00f7, 16h0505, 16h0585,
    16h4783, 16h0005, 16hfbe5, 16hc503,
    16h0005, 16h8533, 16h40a7, 16h8082,
    16h2573, 16hc000, 16h8082, 16h2573,
    16hc020, 16h8082, 16h2573, 16hc010,
    16h8082, 16hc515, 16h4781, 16h4629,
    16h4309, 16h48a5, 16h76b3, 16h02c5,
    16h882a, 16h5533, 16h02c5, 16h0733,
    16h40f3, 16h972e, 16h8693, 16h0306,
    16h0023, 16h00d7, 16h0785, 16hf793,
    16h0ff7, 16he1e3, 16hff08, 16h8082,
    16hc515, 16h4781, 16h4629, 16h4311,
    16h48a5, 16h76b3, 16h02c5, 16h882a,
    16h5533, 16h02c5, 16h0733, 16h40f3,
    16h972e, 16h8693, 16h0306, 16h0023,
    16h00d7, 16h0785, 16hf793, 16h0ff7,
    16he1e3, 16hff08, 16h8082, 16hc50d,
    16h4781, 16h4829, 16h4625, 16h76b3,
    16h0305, 16h88aa, 16h5533, 16h0305,
    16h0733, 16h40f6, 16h972e, 16h8693,
    16h0306, 16h0023, 16h00d7, 16h0785,
    16hf793, 16h0ff7, 16h61e3, 16hff16,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16he147, 16h4783, 16h0007, 16h8b89,
    16hffed, 16h17b7, 16h0000, 16ha783,
    16he107, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha703, 16hde47, 16h4783,
    16h0007, 16hf793, 16h0ff7, 16hffe5,
    16h17b7, 16h0000, 16ha783, 16hdec7,
    16h8023, 16h00a7, 16h47a9, 16h0363,
    16h00f5, 16h8082, 16h1141, 16hc606,
    16h4535, 16h0097, 16h0000, 16h80e7,
    16hfb80, 16h40b2, 16h0141, 16h8082,
    16h1141, 16hc606, 16hc422, 16h842a,
    16h4503, 16h0005, 16hc909, 16h0097,
    16h0000, 16h80e7, 16hf9c0, 16h0405,
    16h4503, 16h0004, 16hf96d, 16h4529,
    16h0097, 16h0000, 16h80e7, 16hf8a0,
    16h40b2, 16h4422, 16h0141, 16h8082,
    16h1141, 16hc606, 16hc422, 16h842a,
    16h4503, 16h0005, 16hc909, 16h0097,
    16h0000, 16h80e7, 16hf6c0, 16h0405,
    16h4503, 16h0004, 16hf96d, 16h40b2,
    16h4422, 16h0141, 16h8082, 16h1101,
    16hce06, 16h27b7, 16h0030, 16h8793,
    16h0207, 16hc63e, 16h006c, 16h0097,
    16h0000, 16h80e7, 16hebc0, 16h0068,
    16h0097, 16h0000, 16h80e7, 16hfc00,
    16h40f2, 16h6105, 16h8082, 16h1101,
    16hce06, 16h27b7, 16h2020, 16h8793,
    16h0207, 16hc43e, 16h0793, 16h0300,
    16h1623, 16h00f1, 16h002c, 16h0097,
    16h0000, 16h80e7, 16heba0, 16h0028,
    16h0097, 16h0000, 16h80e7, 16hf900,
    16h40f2, 16h6105, 16h8082, 16h1101,
    16hce06, 16h17b7, 16h0000, 16h8793,
    16hf807, 16h4394, 16h43d8, 16hc236,
    16hc43a, 16hd703, 16h0087, 16h1623,
    16h00e1, 16hc783, 16h00a7, 16h0723,
    16h00f1, 16h004c, 16h0097, 16h0000,
    16h80e7, 16heaa0, 16h0048, 16h0097,
    16h0000, 16h80e7, 16hf520, 16h40f2,
    16h6105, 16h8082, 16h17b7, 16h0000,
    16ha783, 16he147, 16hc503, 16h0007,
    16h8905, 16h8082, 16h1141, 16hc606,
    16h0097, 16h0000, 16h80e7, 16hfec0,
    16hdd65, 16h17b7, 16h0000, 16ha783,
    16he107, 16hc503, 16h0007, 16h40b2,
    16h0141, 16h8082, 16h17b7, 16h0000,
    16ha703, 16hc947, 16h1023, 16h00a7,
    16ha703, 16hc947, 16h5783, 16h0007,
    16h07c2, 16h83c1, 16hffe5, 16h8082,
    16h17b7, 16h0000, 16ha703, 16he047,
    16h4783, 16h0007, 16hf793, 16h0ff7,
    16hdfe5, 16h8082, 16h1141, 16hc606,
    16hc422, 16hc226, 16h84aa, 16h842e,
    16h0097, 16h0000, 16h80e7, 16hfe00,
    16h17b7, 16h0000, 16ha783, 16hdf87,
    16hd713, 16h0104, 16h9023, 16h00e7,
    16h17b7, 16h0000, 16ha783, 16hdfc7,
    16h04c2, 16h80c1, 16h9023, 16h0097,
    16h17b7, 16h0000, 16ha783, 16he007,
    16h4705, 16h8023, 16h00e7, 16h0097,
    16h0000, 16h80e7, 16hfaa0, 16h4781,
    16h1537, 16h0000, 16h15b7, 16h0000,
    16h0613, 16h2000, 16h9693, 16h0107,
    16h82c1, 16h2703, 16hdf45, 16h1023,
    16h00d7, 16ha703, 16hdf05, 16h4683,
    16h0007, 16h0733, 16h00f4, 16h0023,
    16h00d7, 16h0785, 16h90e3, 16hfec7,
    16h40b2, 16h4422, 16h4492, 16h0141,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16he087, 16h8023, 16h00a7, 16h8082,
    16h17b7, 16h0000, 16ha783, 16hde07,
    16h8023, 16h00a7, 16h17b7, 16h0000,
    16ha783, 16hddc7, 16h8023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16hdd87,
    16h8023, 16h00c7, 16h8082, 16h17b7,
    16h0000, 16ha703, 16hd887, 16h4783,
    16h0007, 16hf793, 16h0ff7, 16hffe5,
    16h8082, 16h1141, 16hc606, 16hc422,
    16h842a, 16h0097, 16h0000, 16h80e7,
    16hfe40, 16h17b7, 16h0000, 16ha783,
    16hd4c7, 16h8023, 16h0087, 16h40b2,
    16h4422, 16h0141, 16h8082, 16h1141,
    16hc606, 16h17b7, 16h0000, 16ha783,
    16hda07, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha783, 16hda87, 16h9023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16hda47, 16h9023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16hd9c7, 16h9023,
    16h00d7, 16h17b7, 16h0000, 16ha783,
    16hd987, 16h9023, 16h00e7, 16h0097,
    16h0000, 16h80e7, 16hf880, 16h17b7,
    16h0000, 16ha783, 16hd8c7, 16h470d,
    16h8023, 16h00e7, 16h40b2, 16h0141,
    16h8082, 16h1141, 16hc606, 16h4515,
    16h0097, 16h0000, 16h80e7, 16hf7a0,
    16h0713, 16h1df0, 16h0693, 16h27f0,
    16h4601, 16h4581, 16h0513, 16h0400,
    16h0097, 16h0000, 16h80e7, 16hf860,
    16h40b2, 16h0141, 16h8082, 16h1141,
    16hc606, 16h17b7, 16h0000, 16ha783,
    16hda07, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha783, 16hda87, 16h9023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16hda47, 16h9023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16hd9c7, 16h9023,
    16h00d7, 16h17b7, 16h0000, 16ha783,
    16hd987, 16h9023, 16h00e7, 16h0097,
    16h0000, 16h80e7, 16hf000, 16h17b7,
    16h0000, 16ha783, 16hd8c7, 16h4709,
    16h8023, 16h00e7, 16h40b2, 16h0141,
    16h8082, 16h1141, 16hc606, 16hc422,
    16h843a, 16h17b7, 16h0000, 16ha783,
    16hda07, 16h8023, 16h00a7, 16h17b7,
    16h0000, 16ha783, 16hda87, 16h9023,
    16h00b7, 16h17b7, 16h0000, 16ha783,
    16hda47, 16h9023, 16h00c7, 16h17b7,
    16h0000, 16ha783, 16hd9c7, 16h9023,
    16h00d7, 16h0097, 16h0000, 16h80e7,
    16heac0, 16h3733, 16h0080, 16h0711,
    16h17b7, 16h0000, 16ha783, 16hd8c7,
    16h8023, 16h00e7, 16h40b2, 16h4422,
    16h0141, 16h8082, 16h1141, 16hc606,
    16h17b7, 16h0000, 16ha783, 16hda07,
    16h8023, 16h00a7, 16h17b7, 16h0000,
    16ha783, 16hda87, 16h9023, 16h00b7,
    16h17b7, 16h0000, 16ha783, 16hda47,
    16h9023, 16h00c7, 16h17b7, 16h0000,
    16ha783, 16hd9c7, 16h9023, 16h00d7,
    16h17b7, 16h0000, 16ha783, 16hd987,
    16h9023, 16h00e7, 16h0097, 16h0000,
    16h80e7, 16he4a0, 16h17b7, 16h0000,
    16ha783, 16hd8c7, 16h471d, 16h8023,
    16h00e7, 16h40b2, 16h0141, 16h8082,
    16h1141, 16hc606, 16h17b7, 16h0000,
    16ha783, 16hda07, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16hda87,
    16h9023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16hda47, 16h9023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16hd9c7,
    16h9023, 16h00d7, 16h17b7, 16h0000,
    16ha783, 16hd987, 16h9023, 16h00e7,
    16h0097, 16h0000, 16h80e7, 16hdee0,
    16h17b7, 16h0000, 16ha783, 16hd8c7,
    16h4721, 16h8023, 16h00e7, 16h40b2,
    16h0141, 16h8082, 16h17b7, 16h0000,
    16ha783, 16hd847, 16h8023, 16h00a7,
    16h4781, 16h1837, 16h0000, 16h1537,
    16h0000, 16h4641, 16h2703, 16hd808,
    16hf693, 16h0ff7, 16h0023, 16h00d7,
    16h2703, 16hd7c5, 16hd683, 16h0005,
    16h1023, 16h00d7, 16h0785, 16h0589,
    16h92e3, 16hfec7, 16h8082, 16h1141,
    16hc606, 16h18b7, 16h0000, 16ha883,
    16hda08, 16h8023, 16h00a8, 16h1537,
    16h0000, 16h2503, 16hda85, 16h1023,
    16h00b5, 16h15b7, 16h0000, 16ha583,
    16hda45, 16h9023, 16h00c5, 16h1637,
    16h0000, 16h2603, 16hd9c6, 16h1023,
    16h00d6, 16h16b7, 16h0000, 16ha683,
    16hd986, 16h9023, 16h00e6, 16h1737,
    16h0000, 16h2703, 16hd947, 16h1023,
    16h00f7, 16h17b7, 16h0000, 16ha783,
    16hd907, 16h9023, 16h0107, 16h0097,
    16h0000, 16h80e7, 16hd400, 16h17b7,
    16h0000, 16ha783, 16hd8c7, 16h4719,
    16h8023, 16h00e7, 16h40b2, 16h0141,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16hcc87, 16h4783, 16h0007, 16hf793,
    16h0ff7, 16hffe5, 16h478d, 16h0023,
    16h00f7, 16h8082, 16h17b7, 16h0000,
    16ha703, 16hcc87, 16h4783, 16h0007,
    16hf793, 16h0ff7, 16hffe5, 16h17b7,
    16h0000, 16ha783, 16hcd87, 16h8023,
    16h00a7, 16h17b7, 16h0000, 16ha783,
    16hcc87, 16h4711, 16h8023, 16h00e7,
    16h8082, 16h17b7, 16h0000, 16ha703,
    16hcc87, 16h4783, 16h0007, 16hf793,
    16h0ff7, 16hffe5, 16h17b7, 16h0000,
    16ha783, 16hcdc7, 16h8023, 16h00a7,
    16h17b7, 16h0000, 16ha783, 16hcd87,
    16h8023, 16h00b7, 16h17b7, 16h0000,
    16ha783, 16hcd07, 16h8023, 16h00c7,
    16h17b7, 16h0000, 16ha783, 16hccc7,
    16h8023, 16h00d7, 16h17b7, 16h0000,
    16ha783, 16hcc87, 16h4705, 16h8023,
    16h00e7, 16h8082, 16h17b7, 16h0000,
    16ha703, 16hcc87, 16h4783, 16h0007,
    16hf793, 16h0ff7, 16hffe5, 16h17b7,
    16h0000, 16ha783, 16hcd47, 16h8023,
    16h00a7, 16h17b7, 16h0000, 16ha783,
    16hcc87, 16h4709, 16h8023, 16h00e7,
    16h8082, 16h4683, 16h0005, 16hca8d,
    16h1637, 16h0000, 16h1837, 16h0000,
    16h4589, 16h2703, 16hcc86, 16h4783,
    16h0007, 16hf793, 16h0ff7, 16hffe5,
    16h2783, 16hcd48, 16h8023, 16h00d7,
    16h2783, 16hcc86, 16h8023, 16h00b7,
    16h0505, 16h4683, 16h0005, 16hfef1,
    16h8082, 16h1101, 16hce06, 16hcc22,
    16hca26, 16hc84a, 16hc64e, 16h84aa,
    16h892e, 16h89b2, 16h8436, 16h0097,
    16h0000, 16h80e7, 16hf060, 16h8522,
    16h0097, 16h0000, 16h80e7, 16h8d20,
    16h8505, 16h0793, 16h0280, 16h8533,
    16h40a7, 16h86ce, 16h864a, 16h85a6,
    16h7513, 16h0ff5, 16h0097, 16h0000,
    16h80e7, 16hf0e0, 16h8522, 16h0097,
    16h0000, 16h80e7, 16hf840, 16h40f2,
    16h4462, 16h44d2, 16h4942, 16h49b2,
    16h6105, 16h8082, 16h1101, 16hce06,
    16h27b7, 16h0030, 16h8793, 16h0207,
    16hc63e, 16h006c, 16h0097, 16h0000,
    16h80e7, 16h8d60, 16h0068, 16h0097,
    16h0000, 16h80e7, 16hf540, 16h40f2,
    16h6105, 16h8082, 16h1101, 16hce06,
    16h27b7, 16h2020, 16h8793, 16h0207,
    16hc43e, 16h0793, 16h0300, 16h1623,
    16h00f1, 16h002c, 16h0097, 16h0000,
    16h80e7, 16h8d40, 16h0028, 16h0097,
    16h0000, 16h80e7, 16hf240, 16h40f2,
    16h6105, 16h8082, 16h1101, 16hce06,
    16h17b7, 16h0000, 16h8793, 16hf807,
    16h4394, 16h43d8, 16hc236, 16hc43a,
    16hd703, 16h0087, 16h1623, 16h00e1,
    16hc783, 16h00a7, 16h0723, 16h00f1,
    16h004c, 16h0097, 16h0000, 16h80e7,
    16h8c40, 16h0048, 16h0097, 16h0000,
    16h80e7, 16hee60, 16h40f2, 16h6105,
    16h8082, 16h17b7, 16h0000, 16ha783,
    16hde87, 16h8023, 16h00a7, 16h8082,
    16h8ff0, 16h0000, 16h8930, 16h0000,
    16h8920, 16h0000, 16h8910, 16h0000,
    16h8904, 16h0000, 16h8900, 16h0000,
    16h881c, 16h0000, 16h8818, 16h0000,
    16h8814, 16h0000, 16h8810, 16h0000,
    16h880c, 16h0000, 16h8808, 16h0000,
    16h8804, 16h0000, 16h8800, 16h0000,
    16h8614, 16h0000, 16h8610, 16h0000,
    16h860c, 16h0000, 16h8608, 16h0000,
    16h8604, 16h0000, 16h8600, 16h0000,
    16h8530, 16h0000, 16h8528, 16h0000,
    16h8524, 16h0000, 16h8520, 16h0000,
    16h851c, 16h0000, 16h8518, 16h0000,
    16h8514, 16h0000, 16h8510, 16h0000,
    16h850c, 16h0000, 16h8508, 16h0000,
    16h8504, 16h0000, 16h8500, 16h0000,
    16h8330, 16h0000, 16h8328, 16h0000,
    16h8324, 16h0000, 16h8320, 16h0000,
    16h831c, 16h0000, 16h8318, 16h0000,
    16h8314, 16h0000, 16h8310, 16h0000,
    16h830c, 16h0000, 16h8308, 16h0000,
    16h8304, 16h0000, 16h8300, 16h0000,
    16h8474, 16h0000, 16h8470, 16h0000,
    16h8470, 16h0000, 16h8460, 16h0000,
    16h8440, 16h0000, 16h843c, 16h0000,
    16h8444, 16h0000, 16h8438, 16h0000,
    16h8434, 16h0000, 16h8448, 16h0000,
    16h8430, 16h0000, 16h842c, 16h0000,
    16h8428, 16h0000, 16h8424, 16h0000,
    16h8420, 16h0000, 16h8458, 16h0000,
    16h8454, 16h0000, 16h8450, 16h0000,
    16h841c, 16h0000, 16h841c, 16h0000,
    16h8418, 16h0000, 16h8414, 16h0000,
    16h8410, 16h0000, 16h840c, 16h0000,
    16h8408, 16h0000, 16h8404, 16h0000,
    16h8400, 16h0000, 16h8234, 16h0000,
    16h8230, 16h0000, 16h8228, 16h0000,
    16h8224, 16h0000, 16h8220, 16h0000,
    16h8214, 16h0000, 16h8210, 16h0000,
    16h820c, 16h0000, 16h8208, 16h0000,
    16h8204, 16h0000, 16h8200, 16h0000,
    16h8108, 16h0000, 16h8104, 16h0000,
    16h8100, 16h0000, 16h8700, 16h0000,
    16h8704, 16h0000, 16h8700, 16h0000,
    16h8f10, 16h0000, 16h8f10, 16h0000,
    16h8f04, 16h0000, 16h8f08, 16h0000,
    16h8f00, 16h0000, 16h8f00, 16h0000,
    16h800c, 16h0000, 16h8008, 16h0000,
    16h8000, 16h0000, 16h8004, 16h0000,
    16h654d, 16h6f6d, 16h7972, 16h4420,
    16h6d75, 16h2070, 16h2038, 16h6962,
    16h0074, 16h0000, 16h654d, 16h6f6d,
    16h7972, 16h4420, 16h6d75, 16h2070,
    16h3631, 16h6220, 16h7469, 16h0000,
    16h6557, 16h636c, 16h6d6f, 16h2065,
    16h6f74, 16h5020, 16h5741, 16h2053,
    16h2061, 16h4952, 16h4353, 16h562d,
    16h5220, 16h3356, 16h4932, 16h434d,
    16h4320, 16h5550, 16h0000, 16h0000,
    16h4d0a, 16h4d45, 16h524f, 16h2059,
    16h5544, 16h504d, 16h4620, 16h4f52,
    16h204d, 16h7830, 16h3031, 16h3030,
    16h3030, 16h3030, 16h4320, 16h4341,
    16h4548, 16h0000, 16h0a0a, 16h454d,
    16h4f4d, 16h5952, 16h4420, 16h4d55,
    16h2050, 16h3631, 16h4620, 16h4f52,
    16h204d, 16h7830, 16h3031, 16h3030,
    16h3130, 16h3030, 16h4320, 16h4341,
    16h4548, 16h0000, 16h520a, 16h5045,
    16h4145, 16h2054, 16h454d, 16h4f4d,
    16h5952, 16h4420, 16h4d55, 16h5350,
    16h000a, 16h0000, 16h4d0a, 16h4d45,
    16h524f, 16h2059, 16h5544, 16h504d,
    16h4620, 16h4f52, 16h204d, 16h7830,
    16h3031, 16h3030, 16h3030, 16h3030,
    16h5320, 16h5244, 16h4d41, 16h7620,
    16h6169, 16h4320, 16h4341, 16h4548,
    16h0000, 16h0000, 16h0a0a, 16h454d,
    16h4f4d, 16h5952, 16h4420, 16h4d55,
    16h2050, 16h3631, 16h4620, 16h4f52,
    16h204d, 16h7830, 16h3031, 16h3030,
    16h3130, 16h3030, 16h5320, 16h5244,
    16h4d41, 16h7620, 16h6169, 16h4320,
    16h4341, 16h4548, 16h0000, 16h0000,
    16h430a, 16h4f4c, 16h4b43, 16h4320,
    16h4359, 16h454c, 16h3a53, 16h0020,
    16h4920, 16h534e, 16h5254, 16h4355,
    16h4954, 16h4e4f, 16h3a53, 16h0020,
    16h0a0a, 16h6554, 16h6d72, 16h6e69,
    16h6c61, 16h4520, 16h6863, 16h206f,
    16h7453, 16h7261, 16h6974, 16h676e,
    16h0000, 16h0000, 16h6f59, 16h2075,
    16h7270, 16h7365, 16h6573, 16h2064,
    16h203a, 16h0000, 16h3c20, 16h002d,
    16h2020, 16h2020, 16h2020, 16h2020,
    16h3020, 16h0000

        , pad(uninitialized)
    };

    // FLAGS FOR BRAM ACCESS
    ram.wenable := 0;
    ram.addr := address[1,15];

    // RETURN RESULTS FROM BRAM OR CACHE
    // 16 bit READ NO SIGN EXTENSION - INSTRUCTION / PART 32 BIT ACCESS
    readdata := ram.rdata;

    while(1) {
        if( writeflag ) {
            if( ( function3 & 3 ) == 0 ) {
                // BYTE WRITE - ENSURE ADDRESS IS READY
                ++:
            }
            ram.wdata = ( ( function3 & 3 ) == 0 ) ? ( address[0,1] ? { writedata[0,8], ram.rdata[0,8] } : { ram.rdata[8,8], writedata[0,8] } ) : writedata;
            ram.wenable = 1;
        }
    }
}

// RAM - SDRAM CONTROLLER
// MEMORY IS 16 BIT, 8 bit WRITES ARE READ MODIFY WRITE
// 8 and 16 bit READS ARE SIGN EXTENDED
algorithm sdramcontroller (
    sdram_user      sio,

    input   uint32  address,
    input   uint3   function3,

    input   uint1   writeflag,
    input   uint16  writedata,

    input   uint1   readflag,
    input   uint1   Icache,
    output  uint16  readdata,

    output  uint1   busy
) <autorun> {
    // INSTRUCTION & DATA CACHES for SDRAM (32mb)
    // CACHE LINE IS LOWER 11 bits ( 0 - 2047 ) of address, dropping the BYTE address bit
    // CACHE TAG IS REMAINING 14 bits of the 26 bit address + 1 bit for valid flag
    bram uint16 Dcachedata <input!> [2048] = uninitialized;
    bram uint15 Dcachetag <input!> [2048] = uninitialized;
    bram uint16 Icachedata <input!> [2048] = uninitialized;
    bram uint15 Icachetag <input!> [2048] = uninitialized;

    // CACHE TAG match flags
    uint1   Icachetagmatch := ( Icachetag.rdata == { 1b1, address[12,14] } );
    uint1   Dcachetagmatch := ( Dcachetag.rdata == { 1b1, address[12,14] } );

    // MEMORY ACCESS FLAGS
    uint1   active = 0;
    busy := ( readflag || writeflag ) ? 1 : active;
    sio.addr := { address[1,25], 1b0 };
    sio.in_valid := 0;

    // FLAGS FOR CACHE ACCESS
    Dcachedata.wenable := 0; Dcachedata.addr := address[1,11];
    Dcachetag.wenable := 0; Dcachetag.addr := address[1,11]; Dcachetag.wdata := { 1b1, address[12,14] };
    Icachedata.wenable := 0; Icachedata.addr := address[1,11];
    Icachetag.wenable := 0; Icachetag.addr := address[1,11]; Icachetag.wdata := { 1b1, address[12,14] };

    // 16 bit READ NO SIGN EXTENSION - INSTRUCTION / PART 32 BIT ACCESS
    readdata := ( Icache && Icachetagmatch ) ? Icachedata.rdata : ( ( ~Icache && Dcachetagmatch ) ? Dcachedata.rdata : sio.data_out );

    while(1) {
        if( readflag ) {
            // SDRAM - 1 cycle for CACHE TAG ACCESS
            active = 1;
            ++:
            if( ( Icache && Icachetagmatch ) || ( ~Icache && Dcachetagmatch ) ) {
                // CACHE HIT
            } else {
                // CACHE MISS
                // READ FROM SDRAM
                sio.rw = 0;
                sio.in_valid = 1;
                while( !sio.done ) {}

                // WRITE RESULT TO ICACHE or DCACHE
                Dcachedata.wdata = sio.data_out;
                Dcachedata.wenable = ~Icache;
                Dcachetag.wenable = ~Icache;
                Icachedata.wdata = sio.data_out;
                Icachedata.wenable = Icache;
                Icachetag.wenable = Icache;
            }

            active = 0;
        }

        if( writeflag ) {
            // SDRAM writethrough to CACHE
            active = 1;

            if( ( function3 & 3 ) == 0 ) {
                // 8 BIT WRITES
                // SDRAM - 1 cycle for CACHE TAG ACCESS
                ++:
                if( ~Dcachetagmatch ) {
                    // CACHE MISS, READ FROM SDRAM, MODIFY AND WRITE TO CACHE AND SDRAM
                    sio.rw = 0;
                    sio.in_valid = 1;
                    while( !sio.done ) {}
                }
            }

            // SETUP WRITE TO CACHE AND SDRAM
            Dcachedata.wdata = ( ( function3 & 3 ) == 0 ) ? ( address[0,1] ? { writedata[0,8], Dcachetagmatch ? Dcachedata.rdata[0,8] : sio.data_out[0,8] } :
                                                                            { Dcachetagmatch ? Dcachedata.rdata[8,8] : sio.data_out[8,8], writedata[0,8] } ) : writedata;
            Icachedata.wdata = ( ( function3 & 3 ) == 0 ) ? ( address[0,1] ? { writedata[0,8], Dcachetagmatch ? Dcachedata.rdata[0,8] : sio.data_out[0,8] } :
                                                                            { Dcachetagmatch ? Dcachedata.rdata[8,8] : sio.data_out[8,8], writedata[0,8] } ) : writedata;
            sio.data_in = ( ( function3 & 3 ) == 0 ) ? ( address[0,1] ? { writedata[0,8], Dcachetagmatch ? Dcachedata.rdata[0,8] : sio.data_out[0,8] } :
                                                                            { Dcachetagmatch ? Dcachedata.rdata[8,8] : sio.data_out[8,8], writedata[0,8] } ) : writedata;

            // COMPLETE WRITE TO CACHE
            Dcachedata.wenable = 1;
            Dcachetag.wenable = 1;
            Icachedata.wenable = Icachetagmatch;

            // COMPLETE WRITE TO SDRAM
            sio.rw = 1;
            sio.in_valid = 1;
            while( !sio.done ) {}

            active = 0;
        }
    }
}


