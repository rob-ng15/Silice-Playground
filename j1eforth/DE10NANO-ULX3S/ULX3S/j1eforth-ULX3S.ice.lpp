// ----------------------- memory_ports.ice -----------
// @sylefeb - Silice standard library
// Memory port interfaces
// 2020-09-03

// single port BRAM

interface bram_port {
  output! addr,
  output! wenable,
  input   rdata,
  output! wdata,
}

// single port BROM

interface brom_port {
  output! addr,
  input   rdata,
}

// dual port BRAM

interface dualbram_port0 {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
}

interface dualbram_port1 {
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// simple dual port BRAM

interface simple_dualbram_port0 {
  output! addr0,
  input   rdata0,
}

interface simple_dualbram_port1 {
  output! addr1,
  output! wenable1,
  output! wdata1,
}

interface bram_ports {
  output! addr0,
  output! wenable0,
  input   rdata0,
  output! wdata0,
  output! addr1,
  output! wenable1,
  input   rdata1,
  output! wdata1,
}

// ----------------------- end of memory_ports.ice ----

// we are running the design at 50 MHz instead of the default 25 MHz

// VGA/HDMI + UART Driver Includes
// SL 2020-09-05
// Silice HDMI driver
//
// 640x480, 250MHz TMDS from 25MHz pixel clock
//
// Currently limited to the ULX3S, but should be relatively easy to port,
// pending pll and differential serial output primitives
//
// See also
// - https://www.digikey.com/eewiki/pages/viewpage.action?pageId=36569119
// - https://www.fpga4fun.com/HDMI.html
// - https://github.com/lawrie/ulx3s_examples/blob/master/hdmi/tmds_encoder.v
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//
//  A copy of the license full text is included in
//  the distribution, please refer to it for details.

import('hdmi_clock.v')
import('differential_pair.v')
import('hdmi_differential_pairs.v')

// ----------------------------------------------------

algorithm tmds_encoder(
  input   uint8  data,
  input   uint2  ctrl,
  input   uint1  data_or_ctrl,
  output  uint10 tmds
) <autorun> {

  uint9 q_m             = 0;
  int5  dc_bias         = 0;

  // tracks 'number on ones' in input
  uint4 num_ones        := data[0,1] + data[1,1] + data[2,1] + data[3,1]
                         + data[4,1] + data[5,1] + data[6,1] + data[7,1];
  // tracks 'numbers of ones minus number of zeros' in internal byte
  int5  diff_ones_zeros := q_m[0,1] + q_m[1,1] + q_m[2,1] + q_m[3,1]
                         + q_m[4,1] + q_m[5,1] + q_m[6,1] + q_m[7,1] - 6d4;

  // XOR chain on input
  int1  xored1          := data[1,1] ^ data[0,1];
  int1  xored2          := data[2,1] ^ xored1;
  int1  xored3          := data[3,1] ^ xored2;
  int1  xored4          := data[4,1] ^ xored3;
  int1  xored5          := data[5,1] ^ xored4;
  int1  xored6          := data[6,1] ^ xored5;
  int1  xored7          := data[7,1] ^ xored6;

  // XNOR chain on input
  int1  xnored1         := ~(data[1,1] ^ data[0,1]);
  int1  xnored2         := ~(data[2,1] ^ xnored1);
  int1  xnored3         := ~(data[3,1] ^ xnored2);
  int1  xnored4         := ~(data[4,1] ^ xnored3);
  int1  xnored5         := ~(data[5,1] ^ xnored4);
  int1  xnored6         := ~(data[6,1] ^ xnored5);
  int1  xnored7         := ~(data[7,1] ^ xnored6);

  always {
    // choice of encoding scheme (xor / xnor)
    if ((num_ones > 4) || (num_ones == 4 && data[0,1] == 0)) {
      q_m = { 1b0 , {xnored7,xnored6,xnored5,xnored4,xnored3,xnored2,xnored1} , data[0,1] };
    } else {
      q_m = { 1b1 , {xored7,xored6,xored5,xored4,xored3,xored2,xored1} , data[0,1] };
    }
    if (data_or_ctrl) {
      // output data
      if (dc_bias == 0 || diff_ones_zeros == 0) {
        tmds      = {~q_m[8,1] , q_m[8,1], (q_m[8,1] ? q_m[0,8] : ~q_m[0,8])};
        if (q_m[8,1] == 0) {
          dc_bias = dc_bias - diff_ones_zeros;
        } else {
          dc_bias = dc_bias + diff_ones_zeros;
        }
      } else {
        if (  (dc_bias > 0 && diff_ones_zeros > 0)
           || (dc_bias < 0 && diff_ones_zeros < 0) ) {
          tmds    = {1b1, q_m[8,1], ~q_m[0,8] };
          dc_bias = dc_bias + q_m[8,1] - diff_ones_zeros;
        } else {
          tmds    = {1b0,q_m};
          dc_bias = dc_bias - (~q_m[8,1]) + diff_ones_zeros;
        }
      }
    } else {
      // output control
      switch (ctrl) {
        case 2b00: { tmds = 10b1101010100; }
        case 2b01: { tmds = 10b0010101011; }
        case 2b10: { tmds = 10b0101010100; }
        case 2b11: { tmds = 10b1010101011; }
      }
      dc_bias = 0;
    }
  }

}

// ----------------------------------------------------

algorithm hdmi_ddr_shifter(
  input   uint10 data_r,
  input   uint10 data_g,
  input   uint10 data_b,
  output  uint8  outbits,
) <autorun> {
  uint3  mod5    = 0;
  uint10 shift_r = 0;
  uint10 shift_g = 0;
  uint10 shift_b = 0;
  uint2  clkbits = 0;
  always {
    shift_r = (mod5 == 0) ?  data_r : shift_r[2,8];
    shift_g = (mod5 == 0) ?  data_g : shift_g[2,8];
    shift_b = (mod5 == 0) ?  data_b : shift_b[2,8];
    clkbits = (mod5[0,2] < 2) ? 2b11 : ( (mod5 > 2) ? 2b00 : 2b01 );
    outbits = { clkbits , shift_b[0,2] , shift_g[0,2] , shift_r[0,2] };
    mod5    = (mod5 == 4) ? 0 : (mod5 + 1);
  }
}

// ----------------------------------------------------

// Expects to run at 25 MHz (hdmi pixel clock)
algorithm hdmi(
  output  uint10 x,
  output  uint10 y,
  output  uint1  active,
  output  uint1  vblank,
  output! uint4  gpdi_dp,
  output! uint4  gpdi_dn,
  input   uint8  red,
  input   uint8  green,
  input   uint8  blue,
) <autorun> {

  uint10 cntx  = 0;
  uint10 cnty  = 0;

  uint1  hsync = 0;
  uint1  vsync = 0;

  // pll for tmds
  uint1  half_hdmi_clk = uninitialized;
  hdmi_clock pll(
    clk      <: clock,              //  25 MHz
    half_hdmi_clk :> half_hdmi_clk, // 125 MHz (half 250MHz HDMI, double data rate output)
  );

  uint2  null_ctrl  = 0;
  uint2  sync_ctrl  = 0;
  uint10 tmds_red   = 0;
  uint10 tmds_green = 0;
  uint10 tmds_blue  = 0;

  uint8  latch_red   = 0;
  uint8  latch_green = 0;
  uint8  latch_blue  = 0;
  uint2  prev_sync_ctrl = 0;
  uint1  prev_active    = 0;

  // encoders
  // => we use <:: to bind values from cycle start (ignoring changes during current cycle)
  tmds_encoder tmdsR(
    data        <:: latch_red,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_red
  );
  tmds_encoder tmdsG(
    data        <:: latch_green,
    ctrl        <:: null_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_green
  );
  tmds_encoder tmdsB(
    data        <:: latch_blue,
    ctrl        <:: prev_sync_ctrl,
    data_or_ctrl<:: prev_active,
    tmds         :> tmds_blue
  );

  // shifter
  uint8 crgb_pos = 0;
  hdmi_ddr_shifter shift<@half_hdmi_clk>(
    data_r  <: tmds_red,
    data_g  <: tmds_green,
    data_b  <: tmds_blue,
    outbits :> crgb_pos,
  );

  uint8 crgb_neg := ~ crgb_pos;

  hdmi_differential_pairs hdmi_out(
    clock   <: half_hdmi_clk,
    pos     <: crgb_pos,
    neg     <: crgb_neg,
    out_pos :> gpdi_dp,
    out_neg :> gpdi_dn );

  always {

    // record previous state of sync_ctrl and active,
    // we receive the r,b,g value for the x,y set below with a one cycle latency
    // these are then latched for the following cycle
    // thus we have to delay corresponding sync and active two cycles
    prev_sync_ctrl = sync_ctrl;
    prev_active    = active;

    // synchronization bits
    hsync          = (cntx > 655) && (cntx < 752);
    vsync          = (cnty > 489) && (cnty < 492);
    sync_ctrl      = {vsync,hsync};
    // output active area
    active         = (cntx < 640) && (cnty < 480);
    // output vblank
    vblank         = (cnty >= 480);
    // output x,y
    x              = (cntx < 640) ? cntx : 0;
    y              = (cnty >= 480) ? 0 : cnty;
    // => we will get color result on next cycle

    // update coordinates
    cnty        = (cntx == 799) ? (cnty == 524 ? 0 : (cnty + 1)) : cnty;
    cntx        = (cntx == 799) ? 0 : (cntx + 1);

    // latch r,b,g received at this cycle, for previous coord
    // will be fed into HDMI encoders next cycle
    latch_red   = red;
    latch_green = green;
    latch_blue  = blue;

  }
}

// ----------------------------------------------------

// @sylefeb, 2020-10-08, simple UART in Silice
//
//      GNU AFFERO GENERAL PUBLIC LICENSE
//        Version 3, 19 November 2007
//      
//  A copy of the license full text is included in 
//  the distribution, please refer to it for details.

// UART config



// sender

// -> interface

group uart_out
{
  uint8 data_in = 0,
  uint1 data_in_ready = 0,
  uint1 busy = 0,
}

interface io_uart_out
{
  input  data_in,
  input  data_in_ready,
  output busy,
}

// -> algorithm

algorithm uart_sender(
  io_uart_out  io,
  output uint1 uart_tx
) <autorun> {
  
  uint10 interval      = 434;
  uint10 counter       = 0;

  uint11 transmit      = 0;

  always {    

    if (transmit > 1) {
      // keep transmitting
      if (counter == 0) {
        // keep going
        uart_tx  = transmit[0,1];
        transmit = {1b0,transmit[1,10]}; // goes to zero when done
      }
      counter = (counter == interval) ? 0 : (counter + 1);
    } else {
      // done
      uart_tx = 1;
      io.busy = 0;
      if (io.data_in_ready) {
        // start transmitting
        io.busy  = 1;
        transmit = {1b1,1b0,io.data_in,1b0};
      }
    }
  }

  uart_tx = 1;

}

// receiver

// -> interface

group uart_in
{
  uint8 data_out = 0,
  uint1 data_out_ready = 0,
}

interface io_uart_in
{
  output data_out,
  output data_out_ready,
}

// -> algorithm

algorithm uart_receiver(
  io_uart_in  io,
  input uint1 uart_rx
) <autorun> {
  
  uint10 interval      = 434;
  uint10 half_interval = 217;
  uint10 counter       = 0;

  uint4  receiving     = 0;
  uint10 received      = 0;

  uint1  latched_rx    = 0;

  always {     

    io.data_out_ready = 0; // maintain low

    if (receiving == 0) {
      if (latched_rx == 0) {
        // start receiving
        receiving = 10; // expecting 10 bits: start - data x8 - stop
        received  =  0;
        counter   = half_interval; // wait half-period
      }
    } else {
      if (counter == 0) { // right in the middle
        received  = {latched_rx,received[1,9]}; // read uart rx
        receiving = receiving - 1;
        counter   = interval;
        if (receiving == 0) {
          // done
          io.data_out       = received[1,8];
          io.data_out_ready = 1;
        }
      } else {
        counter   = counter - 1;
      }
    }

    latched_rx = uart_rx;

  }

}


// Multiplexed Display Includes
algorithm multiplex_display(
    input   uint10 pix_x,
    input   uint10 pix_y,
    input   uint1  pix_active,
    input   uint1  pix_vblank,
    output! uint8 pix_red,
    output! uint8 pix_green,
    output! uint8 pix_blue,

    // BACKGROUND
    input uint2 background_r,
    input uint2 background_g,
    input uint2 background_b,

    // TILEMAP
    input uint2 tilemap_r,
    input uint2 tilemap_g,
    input uint2 tilemap_b,
    input uint1 tilemap_display,

    // LOWER SPRITES
    input uint2 lower_sprites_r,
    input uint2 lower_sprites_g,
    input uint2 lower_sprites_b,
    input uint1 lower_sprites_display,

    // BITMAP
    input uint2 bitmap_r,
    input uint2 bitmap_g,
    input uint2 bitmap_b,
    input uint1 bitmap_display,

    // UPPER SPRITES
    input uint2 upper_sprites_r,
    input uint2 upper_sprites_g,
    input uint2 upper_sprites_b,
    input uint1 upper_sprites_display,

    // CHARACTER MAP
    input uint2 character_map_r,
    input uint2 character_map_g,
    input uint2 character_map_b,
    input uint1 character_map_display,

    // TERMINAL
    input uint2 terminal_r,
    input uint2 terminal_g,
    input uint2 terminal_b,
    input uint1 terminal_display
) <autorun> {
    uint8   red8 = uninitialised;
    uint8   green8 = uninitialised;
    uint8   blue8 = uninitialised;

    expandcolour RED(
        terminal_display <: terminal_display,
        terminal <: terminal_r,
        character_map_display <: character_map_display,
        character_map <: character_map_r,
        upper_sprites_display <: upper_sprites_display,
        upper_sprites <: upper_sprites_r,
        bitmap_display <: bitmap_display,
        bitmap <: bitmap_r,
        lower_sprites_display <: lower_sprites_display,
        lower_sprites <: lower_sprites_r,
        tilemap_display <: tilemap_display,
        tilemap <: tilemap_r,
        background <: background_r,

        pix :> red8
    );
    expandcolour GREEN(
        terminal_display <: terminal_display,
        terminal <: terminal_g,
        character_map_display <: character_map_display,
        character_map <: character_map_g,
        upper_sprites_display <: upper_sprites_display,
        upper_sprites <: upper_sprites_g,
        bitmap_display <: bitmap_display,
        bitmap <: bitmap_g,
        lower_sprites_display <: lower_sprites_display,
        lower_sprites <: lower_sprites_g,
        tilemap_display <: tilemap_display,
        tilemap <: tilemap_g,
        background <: background_g,

        pix :> green8
    );
    expandcolour BLUE(
        terminal_display <: terminal_display,
        terminal <: terminal_b,
        character_map_display <: character_map_display,
        character_map <: character_map_b,
        upper_sprites_display <: upper_sprites_display,
        upper_sprites <: upper_sprites_b,
        bitmap_display <: bitmap_display,
        bitmap <: bitmap_b,
        lower_sprites_display <: lower_sprites_display,
        lower_sprites <: lower_sprites_b,
        tilemap_display <: tilemap_display,
        tilemap <: tilemap_b,
        background <: background_b,

        pix :> blue8
    );

    pix_red := 0;
    pix_green := 0;
    pix_blue := 0;


    while (1) {
        if( pix_active ) {
            pix_red = red8;
            pix_green = green8;
            pix_blue = blue8;
        }
    }
}

// EXPAND FROM 2 bit to 8 bit colour
algorithm expandcolour(
    input   uint1   terminal_display,
    input   uint2   terminal,
    input   uint1   character_map_display,
    input   uint2   character_map,
    input   uint1   upper_sprites_display,
    input   uint2   upper_sprites,
    input   uint1   bitmap_display,
    input   uint2   bitmap,
    input   uint1   lower_sprites_display,
    input   uint2   lower_sprites,
    input   uint1   tilemap_display,
    input   uint2   tilemap,
    input   uint2   background,

    output! uint8   pix
) <autorun> {
    pix := ( terminal_display ) ? { {4{terminal}} } :
                                ( character_map_display ) ? { {4{character_map}} } :
                                ( upper_sprites_display ) ? { {4{upper_sprites}} } :
                                ( bitmap_display ) ? { {4{bitmap}} } :
                                ( lower_sprites_display ) ? { {4{lower_sprites}} } :
                                ( tilemap_display ) ? { {4{tilemap}} } :
                                { {4{background}} };

    while(1) {
    }
}

// Create 1hz (1 second counter, also can output the baseline 50MHz counter)
algorithm pulse1hz(
    output  uint16  counter1hz,
    input   uint1   resetCounter
) <autorun> {
    uint26  counter50mhz = 0;
    counter1hz = 0;

    while (1) {
        if( resetCounter == 1) {
            counter1hz = 0;
            counter50mhz = 0;
        } else {
            counter1hz = ( counter50mhz == 50000000 ) ? counter1hz + 1 : counter1hz;
            counter50mhz = ( counter50mhz == 50000000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// Create 1khz (1 milli-second counter)
algorithm pulse1khz(
    output  uint16  counter1khz,
    input   uint16  resetCount,
    input   uint1   resetCounter
) <autorun> {
    uint16 counter50mhz = 0;

    while (1) {
        if( resetCounter == 1 ) {
            counter1khz = resetCount;
            counter50mhz = 0;
        } else {
            counter1khz = ( counter1khz == 0 ) ? 0 : ( counter50mhz == 50000 ) ? counter1khz - 1 : counter1khz;
            counter50mhz = ( counter50mhz == 50000 ) ? 0 : counter50mhz + 1;
        }
    }
}

// 16 bit random number generator
// Translation into Silice of LFSR_Plus.v
algorithm random(
    output  uint16  g_noise_out,
    output  uint16  u_noise_out,
    input   uint1   resetRandom
) <autorun> {
    uint16  rand_out = 0;
    uint16  rand_ff = 24b011000110111011010011101;
    uint18  rand_en_ff = 24b001100010011011101100101;
    uint16  temp_u_noise3 = 0;
    uint16  temp_u_noise2 = 0;
    uint16  temp_u_noise1 = 0;
    uint16  temp_u_noise0 = 0;
    uint16  temp_g_noise_nxt = uninitialized;

    g_noise_out := ( rand_en_ff[17,1] ) ? temp_g_noise_nxt : ( rand_en_ff[10,1] ) ? rand_out : g_noise_out;
    u_noise_out := ( rand_en_ff[17,1] ) ? rand_out : u_noise_out;

    always {
        rand_en_ff = {(rand_en_ff[7,1] ^ rand_en_ff[0,1]) , rand_en_ff[1,17]};
        rand_ff = { ( rand_ff[5,1] ^ rand_ff[3,1] ^ rand_ff[2,1] ^ rand_ff[0,1]) , rand_ff[1,15] };
    }

    while(1) {
        if( resetRandom ) {
            rand_en_ff = 24b001100010011011101100101;
            rand_ff = 24b011000110111011010011101;
            rand_out = 0;
            temp_u_noise3 = 0;
            temp_u_noise2 = 0;
            temp_u_noise1 = 0;
            temp_u_noise0 = 0;
            g_noise_out = 0;
            u_noise_out = 0;
        } else {
            rand_out = rand_ff;
            temp_u_noise3 = { rand_out[15,1], rand_out[15,1], rand_out[2,13] };
            temp_u_noise2 = temp_u_noise3;
            temp_u_noise1 = temp_u_noise2;
            temp_u_noise0 = temp_u_noise1;
            temp_g_noise_nxt =  __signed(temp_u_noise3) + __signed(temp_u_noise2) + __signed(temp_u_noise1) + __signed(temp_u_noise0) + ( rand_en_ff[9,1] ? __signed(g_noise_out) : 0 );
        }
    }
}

algorithm terminal(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   terminal_display,

    input   uint8   terminal_character,
    input   uint2   terminal_write,
    input   uint1   showterminal,
    input   uint1   timer1hz,
    output  uint2   terminal_active
) <autorun> {
    // Character ROM 8x8 x 256
    brom uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // 80 x 4 character buffer for the input/output terminal
    simple_dualport_bram uint8 terminal <input!> [640] = uninitialized;
    simple_dualport_bram uint8 terminal_copy <input!> [640] = uninitialized;

    // Initial cursor position in the terminal, bottom left
    uint7 terminal_x = 0;
    uint3 terminal_y = 7;

    // Character position on the terminal x 0-79, y 0-7 * 80 ( fetch it one pixel ahead of the actual x pixel, so it is always ready )
    uint7 xterminalpos := ( pix_active ? pix_x + 2 : 0 ) >> 3;
    uint10 yterminalpos := (( pix_vblank ? 0 : pix_y - 416 ) >> 3) * 80;

    // Determine if cursor, and if cursor is flashing
    uint1 is_cursor := ( xterminalpos == terminal_x ) && ( ( ( pix_y - 416) >> 3 ) == terminal_y );

    // Derive the x and y coordinate within the current 8x8 terminal character block x 0-7, y 0-7
    uint3 xinterminal := (pix_x) & 7;
    uint3 yinterminal := (pix_y) & 7;

    // Derive the actual pixel in the current terminal
    uint1 terminalpixel := characterGenerator8x8.rdata[7 - xinterminal,1];

    // Terminal active (scroll) flag and temporary storage for scrolling
    uint10 terminal_scroll = 0;

    // Setup the reading of the terminal memory
    terminal.addr0 := xterminalpos + yterminalpos;

    // Setup the writing to the terminal memory
    terminal.wenable1 := 1;
    terminal_copy.wenable1 := 1;

    // Setup the reading of the characterGenerator8x8 ROM
    characterGenerator8x8.addr :=  terminal.rdata0 * 8 + yinterminal;

    // Default to transparent and active pixels always blue
    terminal_display := pix_active && showterminal && (pix_y > 415);
    pix_red := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_green := ( terminalpixel ) ? ( ( is_cursor && timer1hz ) ? 0 : 3 ) : ( ( is_cursor && timer1hz ) ? 3 : 0 );
    pix_blue := 3;

    // Render the terminal
    while(1) {
        switch( terminal_active ) {
            case 0: {
                switch( terminal_write ) {
                    case 1: {
                        // Display character
                        switch( terminal_character ) {
                            case 8: {
                                // BACKSPACE, move back one character
                                if( terminal_x != 0 ) {
                                    terminal_x = terminal_x - 1;
                                    terminal.addr1 = terminal_x + terminal_y * 80;
                                    terminal.wdata1 = 0;
                                    terminal_copy.addr1 = terminal_x + terminal_y * 80;
                                    terminal_copy.wdata1 = 0;
                                }
                            }
                            case 10: {
                                // LINE FEED, scroll
                                terminal_active = 1;
                            }
                            case 13: {
                                // CARRIAGE RETURN
                                terminal_x = 0;
                            }
                            default: {
                                // Display character
                                terminal.addr1 = terminal_x + terminal_y * 80;
                                terminal.wdata1 = terminal_character;
                                terminal_copy.addr1 = terminal_x + terminal_y * 80;
                                terminal_copy.wdata1 = terminal_character;
                                terminal_active = ( terminal_x == 79 ) ? 1 : 0;
                                terminal_x = ( terminal_x == 79 ) ? 0 : terminal_x + 1;
                            }
                        }
                    }
                    case 2: {
                        // RESET
                        terminal_active = 2;
                    }
                }

            }
            case 1: {
                // SCROLL
                terminal_scroll = 0;
                ++:
                while( terminal_scroll < 560 ) {
                    // Retrieve character on the next line
                    terminal_copy.addr0 = terminal_scroll + 80;
                    ++:
                    // Write retrieved character
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = terminal_copy.rdata0;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = terminal_copy.rdata0;

                    terminal_scroll = terminal_scroll + 1;
                }

                // BLANK LAST LINE
                while( terminal_scroll < 640 ) {
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = 0;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = 0;

                    terminal_scroll = terminal_scroll + 1;
                }

                terminal_active = 0;
            }
            case 2: {
                // RESET
                terminal_scroll = 0;
                ++:
                while( terminal_scroll < 640 ) {
                    terminal.addr1 = terminal_scroll;
                    terminal.wdata1 = 0;
                    terminal_copy.addr1 = terminal_scroll;
                    terminal_copy.wdata1 = 0;
                    terminal_scroll = terminal_scroll + 1;
                }
                terminal_x = 0;
                terminal_y = 7;

                terminal_active = 0;
            }
        }
    }
}

bitfield charactermapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint8   character
}

algorithm character_map(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   character_map_display,

    // TPU to SET characters, background, foreground
    input   uint7   tpu_x,
    input   uint5   tpu_y,
    input   uint8   tpu_character,
    input   uint6   tpu_foreground,
    input   uint7   tpu_background,
    input   uint3   tpu_write,

    output  uint1   tpu_active
) <autorun> {
    // Character ROM 8x16
    brom uint8 characterGenerator8x16[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h81, 8ha5, 8h81, 8h81, 8hbd, 8h99, 8h81, 8h81, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8hff, 8hdb, 8hff, 8hff, 8hc3, 8he7, 8hff, 8hff, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h6c, 8hfe, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8he7, 8he7, 8he7, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h7e, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h1e, 8h0e, 8h1a, 8h32, 8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h33, 8h3f, 8h30, 8h30, 8h30, 8h30, 8h70, 8hf0, 8he0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8h63, 8h7f, 8h63, 8h63, 8h63, 8h63, 8h67, 8he7, 8he6, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8hdb, 8h3c, 8he7, 8h3c, 8hdb, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h80, 8hc0, 8he0, 8hf0, 8hf8, 8hfe, 8hf8, 8hf0, 8he0, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h02, 8h06, 8h0e, 8h1e, 8h3e, 8hfe, 8h3e, 8h1e, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7f, 8hdb, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h1b, 8h1b, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h7c, 8hc6, 8h60, 8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h28, 8h6c, 8hfe, 8h6c, 8h28, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h38, 8h7c, 8h7c, 8hfe, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8hfe, 8h7c, 8h7c, 8h38, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h24, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h6c, 8hfe, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h7c, 8hc6, 8hc2, 8hc0, 8h7c, 8h06, 8h06, 8h86, 8hc6, 8h7c, 8h18, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hc2, 8hc6, 8h0c, 8h18, 8h30, 8h60, 8hc6, 8h86, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h30, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h18, 8h0c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h18, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h02, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hd6, 8hd6, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h38, 8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8h06, 8h06, 8h3c, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0c, 8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h0c, 8h0c, 8h1e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hfc, 8h06, 8h06, 8h06, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h60, 8hc0, 8hc0, 8hfc, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h06, 8h06, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h06, 8h06, 8h0c, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h18, 8h18, 8h30, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h60, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h0c, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hde, 8hde, 8hde, 8hdc, 8hc0, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h66, 8h66, 8h66, 8h66, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf8, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8h66, 8h62, 8h68, 8h78, 8h68, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hde, 8hc6, 8hc6, 8h66, 8h3a, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8hcc, 8h78, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he6, 8h66, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hf0, 8h60, 8h60, 8h60, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hde, 8h7c, 8h0c, 8h0e, 8h00, 8h00,
    8h00, 8h00, 8hfc, 8h66, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7c, 8hc6, 8hc6, 8h60, 8h38, 8h0c, 8h06, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h7e, 8h7e, 8h5a, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h10, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8hee, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8hc6, 8h6c, 8h7c, 8h38, 8h38, 8h7c, 8h6c, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8h86, 8h0c, 8h18, 8h30, 8h60, 8hc2, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h30, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h80, 8hc0, 8he0, 8h70, 8h38, 8h1c, 8h0e, 8h06, 8h02, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h78, 8h6c, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc0, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h0c, 8h0c, 8h3c, 8h6c, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h6c, 8h76, 8h66, 8h66, 8h66, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h06, 8h06, 8h00, 8h0e, 8h06, 8h06, 8h06, 8h06, 8h06, 8h06, 8h66, 8h66, 8h3c, 8h00,
    8h00, 8h00, 8he0, 8h60, 8h60, 8h66, 8h6c, 8h78, 8h78, 8h6c, 8h66, 8he6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hec, 8hfe, 8hd6, 8hd6, 8hd6, 8hd6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8h0c, 8h1e, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8h60, 8h60, 8hf0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7c, 8hc6, 8h60, 8h38, 8h0c, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h10, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h30, 8h30, 8h36, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hd6, 8hd6, 8hd6, 8hfe, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8h6c, 8h38, 8h38, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8hf8, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hcc, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h18, 8h18, 8h18, 8h70, 8h18, 8h18, 8h18, 8h18, 8h0e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h70, 8h18, 8h18, 8h18, 8h0e, 8h18, 8h18, 8h18, 8h18, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h66, 8hc2, 8hc0, 8hc0, 8hc0, 8hc2, 8h66, 8h3c, 8h0c, 8h06, 8h7c, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hcc, 8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h38, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h3c, 8h66, 8h60, 8h60, 8h66, 8h3c, 8h0c, 8h06, 8h3c, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hfe, 8hc0, 8hc0, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h00, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h66, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h38, 8h6c, 8h38, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h00, 8hfe, 8h66, 8h60, 8h7c, 8h60, 8h60, 8h66, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hcc, 8h76, 8h36, 8h7e, 8hd8, 8hd8, 8h6e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3e, 8h6c, 8hcc, 8hcc, 8hfe, 8hcc, 8hcc, 8hcc, 8hcc, 8hce, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h30, 8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h60, 8h30, 8h18, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hc6, 8h00, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7e, 8h06, 8h0c, 8h78, 8h00,
    8h00, 8hc6, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc6, 8h00, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h18, 8h3c, 8h66, 8h60, 8h60, 8h60, 8h66, 8h3c, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h64, 8h60, 8hf0, 8h60, 8h60, 8h60, 8h60, 8he6, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hf8, 8hcc, 8hcc, 8hf8, 8hc4, 8hcc, 8hde, 8hcc, 8hcc, 8hcc, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0e, 8h1b, 8h18, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8h70, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0c, 8h18, 8h30, 8h00, 8h38, 8h18, 8h18, 8h18, 8h18, 8h18, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h18, 8h30, 8h60, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8h00, 8hdc, 8h66, 8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h00, 8h00, 8h00,
    8h76, 8hdc, 8h00, 8hc6, 8he6, 8hf6, 8hfe, 8hde, 8hce, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h30, 8h30, 8h00, 8h30, 8h30, 8h60, 8hc0, 8hc6, 8hc6, 8h7c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8h06, 8h06, 8h06, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h60, 8hdc, 8h86, 8h0c, 8h18, 8h3e, 8h00, 8h00,
    8h00, 8hc0, 8hc0, 8hc2, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hce, 8h9e, 8h3e, 8h06, 8h06, 8h00, 8h00,
    8h00, 8h00, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h3c, 8h3c, 8h3c, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h36, 8h6c, 8hd8, 8h6c, 8h36, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hd8, 8h6c, 8h36, 8h6c, 8hd8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44, 8h11, 8h44,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77, 8hdd, 8h77,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8hd8, 8hd8, 8hd8, 8hdc, 8h76, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8hd8, 8hcc, 8hc6, 8hc6, 8hc6, 8hcc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hfe, 8hc6, 8hc6, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfe, 8hc6, 8h60, 8h30, 8h18, 8h30, 8h60, 8hc6, 8hfe, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h66, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hc0, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7e, 8h18, 8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8hc6, 8hc6, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h6c, 8h6c, 8h6c, 8hee, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1e, 8h30, 8h18, 8h0c, 8h3e, 8h66, 8h66, 8h66, 8h66, 8h3c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h7e, 8hdb, 8hdb, 8hdb, 8h7e, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h03, 8h06, 8h7e, 8hdb, 8hdb, 8hf3, 8h7e, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1c, 8h30, 8h60, 8h60, 8h7c, 8h60, 8h60, 8h60, 8h30, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h7c, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8hfe, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h7e, 8h18, 8h18, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h30, 8h18, 8h0c, 8h06, 8h0c, 8h18, 8h30, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h0c, 8h18, 8h30, 8h60, 8h30, 8h18, 8h0c, 8h00, 8h7e, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8hd8, 8h70, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h7e, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h0f, 8h0c, 8h0c, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h6c, 8h3c, 8h1c, 8h00, 8h00, 8h00, 8h00,
    8h00, 8hd8, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h70, 8hd8, 8h30, 8h60, 8hc8, 8hf8, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h7c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00


    };

    // 80 x 30 character buffer
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint21 charactermap[2400] = { 21b100000000000000000000, pad(21b100000000000000000000) };

    // Character position on the screen x 0-79, y 0-29 * 80 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    uint8 xcharacterpos := ( pix_active ?  pix_x + 2 : 0 ) >> 3;
    uint12 ycharacterpos := (( pix_vblank ? 0 : pix_y ) >> 4) * 80;

    // Derive the x and y coordinate within the current 8x16 character block x 0-7, y 0-15
    uint3 xincharacter := (pix_x) & 7;
    uint4 yincharacter := (pix_y) & 15;

    // Derive the actual pixel in the current character
    uint1 characterpixel := characterGenerator8x16.rdata[7 - xincharacter,1];

    // TPU character position
    uint7 tpu_active_x = 0;
    uint5 tpu_active_y = 0;

    // CS Counter
    uint12  tpu_cs_addr = uninitialized;

    // Set up reading of the charactermap
    charactermap.addr0 := xcharacterpos + ycharacterpos;

    // BRAM write access for the TPU
    charactermap.wenable1 := 1;

    // Setup the reading of the characterGenerator8x16 ROM
    characterGenerator8x16.addr :=  charactermapentry(charactermap.rdata0).character * 16 + yincharacter;

    // RENDER - Default to transparent
    character_map_display := pix_active && (( characterpixel ) || ( ~charactermapentry(charactermap.rdata0).alpha ));
    pix_red := characterpixel ? charactermap.rdata0[12,2] : charactermap.rdata0[18,2];
    pix_green := characterpixel ? charactermap.rdata0[10,2] : charactermap.rdata0[16,2];
    pix_blue := characterpixel ? charactermap.rdata0[8,2] : charactermap.rdata0[14,2];

    // Default to 0,0 and transparent
    charactermap.addr1 = 0; charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };

    while(1) {
        switch( tpu_active ) {
            case 0: {
                switch( tpu_write ) {
                    case 1: {
                        // Set cursor position
                        tpu_active_x = tpu_x;
                        tpu_active_y = tpu_y;
                    }
                    case 2: {
                        // Write character,foreground, background to current cursor position and move onto next character position
                        charactermap.addr1 = tpu_active_x + tpu_active_y * 80;
                        charactermap.wdata1 = { tpu_background, tpu_foreground, tpu_character };

                        tpu_active_y = ( tpu_active_x == 79 ) ? ( tpu_active_y == 29 ) ? 0 : tpu_active_y + 1 : tpu_active_y;
                        tpu_active_x = ( tpu_active_x == 79 ) ? 0 : tpu_active_x + 1;
                    }
                    case 3: {
                        // Start tpucs!
                        tpu_active_x = 0;
                        tpu_active_y = 0;
                        tpu_active = 1;
                        tpu_cs_addr = 0;
                        charactermap.wdata1 = { 1b1, 6b0, 6b0, 8b0 };
                    }
                }
            }

            // TPU CS
            case 1: {
                while( tpu_cs_addr < 2400 ) {
                    charactermap.addr1 = tpu_cs_addr;
                    tpu_cs_addr = tpu_cs_addr + 1;
                }
                ++:
                tpu_active = 0;
            }
        }
    }
}

algorithm bitmap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   bitmap_display,

    // Hardware scrolling
    input   uint3   bitmap_write_offset,
    output  uint10  x_offset,
    output  uint10  y_offset,

    // Pixel reader
    input   int16   bitmap_x_read,
    input   int16   bitmap_y_read,
    output  uint7   bitmap_colour_read,

    simple_dualbram_port0 bitmap
) <autorun> {
    // Pixel x and y fetching ( adjusting for offset )
    uint10  x_plus_one := ( pix_x + x_offset + 1 ) > 639 ? ( pix_x + x_offset + 1 ) - 639 : ( pix_x + x_offset + 1 );
    uint10  y_line := pix_vblank ? y_offset : ( ( pix_y + y_offset ) > 479 ? ( pix_y + y_offset ) - 479 : ( pix_y + y_offset ) );
    uint10  x_pixel := pix_active ? x_plus_one : x_offset;

    // Pixel being read?
    bitmap_colour_read := ( pix_x == bitmap_x_read ) && ( pix_y == bitmap_y_read ) ? bitmap.rdata0 : bitmap_colour_read;

    // Setup the address in the bitmap for the pixel being rendered
    // Use pre-fetching of the next pixel ready for the next cycle
    bitmap.addr0 := x_pixel + ( y_line * 640 );

    // RENDER - Default to transparent
    bitmap_display := pix_active && ~bitmap.rdata0[6,1];
    pix_red := bitmap.rdata0[4,2];
    pix_green := bitmap.rdata0[2,2];
    pix_blue := bitmap.rdata0[0,2];

    while(1) {
        switch( bitmap_write_offset ) {
            case 1: {
                x_offset = ( x_offset == 639 ) ? 0 : x_offset + 1;
            }
            case 2: {
                y_offset = ( y_offset == 479 ) ? 0 : y_offset + 1;
            }
            case 3: {
                x_offset = ( x_offset == 0 ) ? 639 : x_offset - 1;
            }
            case 4: {
                y_offset = ( y_offset == 0 ) ? 479 : y_offset - 1;
            }
            case 5: {
                x_offset = 0;
                y_offset = 0;
            }
        }
   }
}

algorithm bitmapwriter (
    // GPU to SET and GET pixels
    input   int11   bitmap_x_write,
    input   int11   bitmap_y_write,
    input   uint7   bitmap_colour_write,
    input   uint1   bitmap_write,

    input   uint10  x_offset,
    input   uint10  y_offset,

    simple_dualbram_port1 bitmap
) <autorun> {
    // Pixel x and y for writing ( adjusting for offset )
    uint10  x_write_pixel := ( bitmap_x_write + x_offset ) > 639 ? ( bitmap_x_write + x_offset ) - 639 : ( bitmap_x_write + x_offset );
    uint10  y_write_pixel := ( bitmap_y_write + y_offset ) > 479 ? ( bitmap_y_write + y_offset ) - 479 : ( bitmap_y_write + y_offset );

    // Write in range?
    uint1 write_pixel := (bitmap_x_write >= 0 ) && (bitmap_x_write < 640) && (bitmap_y_write >= 0) && (bitmap_y_write <= 479) && bitmap_write;

    // Bitmap write access for the GPU - Only enable when x and y are in range
    bitmap.wenable1 := 1;

    while(1) {
        if( write_pixel == 1 ) {
            bitmap.addr1 = x_write_pixel + y_write_pixel * 640;
            bitmap.wdata1 = bitmap_colour_write;
        }
    }
}

// HELPER CIRCUITS

// MINIMUM OF 2 VALUES
circuitry min(
    input   value1,
    input   value2,
    output  minimum
) {
    minimum = ( value1 < value2 ) ? value1 : value2;
}

// MINIMUM OF 3 VALUES
circuitry min3(
    input   value1,
    input   value2,
    input   value3,
    output  minimum
) {
    minimum = ( value1 < value2 ) ? ( value1 < value3 ? value1 : value3 ) : ( value2 < value3 ? value2 : value3 );
}

// MAXIMUM OF 2 VALUES
circuitry max(
    input   value1,
    input   value2,
    output  maximum
) {
    maximum = ( value1 > value2 ) ? value1 : value2;
}

// MAXIMUM OF 3 VALUES
circuitry max3(
    input   value1,
    input   value2,
    input   value3,
    output  maximum
) {
    maximum = ( value1 > value2 ) ? ( value1 > value3 ? value1 : value3 ) : ( value2 > value3 ? value2 : value3 );
}

// ABSOLUTE VALUE
circuitry abs(
    input   value1,
    output  absolute
) {
    absolute = ( value1 < 0 ) ? -value1 : value1;
}

// ABSOLUTE DELTA ( DIFFERENCE )
circuitry absdelta(
    input   value1,
    input   value2,
    output  delta
) {
    delta = ( value1 < value2 ) ? value2 - value1 : value1 - value2;
}

// COPY COORDINATES
circuitry copycoordinates(
    input   x,
    input   y,
    output  x1,
    output  y1
) {
    x1 = x;
    y1 = y;
}

// SWAP COORDINATES
circuitry swapcoordinates(
    input   x,
    input   y,
    input   x1,
    input   y1,
    output  x2,
    output  y2,
    output  x3,
    output  y3
) {
    x2 = x1;
    y2 = y1;
    x3 = x;
    y3 = y;
}

// ADJUST COORDINATES BY DELTAS
circuitry deltacoordinates(
    input   x,
    input   dx,
    input   y,
    input   dy,
    output  xdx,
    output  ydy
) {
    xdx = x + dx;
    ydy = y + dy;
}

// CROP COORDINATES TO SCREEN RANGE
circuitry cropleft(
    input   x,
    output  x1
) {
    x1 = ( x < 0 ) ? 0 : x;
}
circuitry croptop(
    input   y,
    output  y1
) {
    y1 = ( y < 0 ) ? 0 : y;
}
circuitry cropright(
    input   x,
    output  x1
) {
    x1 = ( x > 639 ) ? 639 : x;
}
circuitry cropbottom(
    input   y,
    output  y1
) {
    y1 = ( y > 479 ) ? 479 : y;
}

algorithm gpu(
    // GPU to SET and GET pixels
    output! int11 bitmap_x_write,
    output! int11 bitmap_y_write,
    output! uint7 bitmap_colour_write,
    output! uint1 bitmap_write,

    // From j1eforth
    input   int11 gpu_x,
    input   int11 gpu_y,
    input   uint8 gpu_colour,
    input   int11 gpu_param0,
    input   int11 gpu_param1,
    input   int11 gpu_param2,
    input   int11 gpu_param3,
    input   uint4 gpu_write,

    // For setting blit1 tile bitmaps
    input   uint5   blit1_writer_tile,
    input   uint4   blit1_writer_line,
    input   uint16  blit1_writer_bitmap,

    // VECTOR BLOCK
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,
    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   gpu_active,
    output  uint1   vector_block_active
) <autorun> {
    // 32 x 16 x 16 1 bit tilemap for blit1tilemap
    simple_dualport_bram uint16 blit1tilemap[ 512 ] = uninitialized;

    // Character ROM 8x8 x 256 for character blitter
    simple_dualport_bram uint8 characterGenerator8x8[] = {
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h7e, 8h81, 8ha5, 8h81, 8hbd, 8h99, 8h81, 8h7e,
    8h7e, 8hff, 8hdb, 8hff, 8hc3, 8he7, 8hff, 8h7e,
    8h6c, 8hfe, 8hfe, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h10, 8h00,
    8h38, 8h7c, 8h38, 8hfe, 8hfe, 8h7c, 8h38, 8h7c,
    8h10, 8h10, 8h38, 8h7c, 8hfe, 8h7c, 8h38, 8h7c,
    8h00, 8h00, 8h18, 8h3c, 8h3c, 8h18, 8h00, 8h00,
    8hff, 8hff, 8he7, 8hc3, 8hc3, 8he7, 8hff, 8hff,
    8h00, 8h3c, 8h66, 8h42, 8h42, 8h66, 8h3c, 8h00,
    8hff, 8hc3, 8h99, 8hbd, 8hbd, 8h99, 8hc3, 8hff,
    8h0f, 8h07, 8h0f, 8h7d, 8hcc, 8hcc, 8hcc, 8h78,
    8h3c, 8h66, 8h66, 8h66, 8h3c, 8h18, 8h7e, 8h18,
    8h3f, 8h33, 8h3f, 8h30, 8h30, 8h70, 8hf0, 8he0,
    8h7f, 8h63, 8h7f, 8h63, 8h63, 8h67, 8he6, 8hc0,
    8h99, 8h5a, 8h3c, 8he7, 8he7, 8h3c, 8h5a, 8h99,
    8h80, 8he0, 8hf8, 8hfe, 8hf8, 8he0, 8h80, 8h00,
    8h02, 8h0e, 8h3e, 8hfe, 8h3e, 8h0e, 8h02, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h7e, 8h3c, 8h18,
    8h66, 8h66, 8h66, 8h66, 8h66, 8h00, 8h66, 8h00,
    8h7f, 8hdb, 8hdb, 8h7b, 8h1b, 8h1b, 8h1b, 8h00,
    8h3e, 8h63, 8h38, 8h6c, 8h6c, 8h38, 8hcc, 8h78,
    8h00, 8h00, 8h00, 8h00, 8h7e, 8h7e, 8h7e, 8h00,
    8h18, 8h3c, 8h7e, 8h18, 8h7e, 8h3c, 8h18, 8hff,
    8h18, 8h3c, 8h7e, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h18, 8h18, 8h18, 8h18, 8h7e, 8h3c, 8h18, 8h00,
    8h00, 8h18, 8h0c, 8hfe, 8h0c, 8h18, 8h00, 8h00,
    8h00, 8h30, 8h60, 8hfe, 8h60, 8h30, 8h00, 8h00,
    8h00, 8h00, 8hc0, 8hc0, 8hc0, 8hfe, 8h00, 8h00,
    8h00, 8h24, 8h66, 8hff, 8h66, 8h24, 8h00, 8h00,
    8h00, 8h18, 8h3c, 8h7e, 8hff, 8hff, 8h00, 8h00,
    8h00, 8hff, 8hff, 8h7e, 8h3c, 8h18, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h30, 8h78, 8h78, 8h30, 8h30, 8h00, 8h30, 8h00,
    8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h6c, 8h6c, 8hfe, 8h6c, 8hfe, 8h6c, 8h6c, 8h00,
    8h30, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h30, 8h00,
    8h00, 8hc6, 8hcc, 8h18, 8h30, 8h66, 8hc6, 8h00,
    8h38, 8h6c, 8h38, 8h76, 8hdc, 8hcc, 8h76, 8h00,
    8h60, 8h60, 8hc0, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h18, 8h30, 8h60, 8h60, 8h60, 8h30, 8h18, 8h00,
    8h60, 8h30, 8h18, 8h18, 8h18, 8h30, 8h60, 8h00,
    8h00, 8h66, 8h3c, 8hff, 8h3c, 8h66, 8h00, 8h00,
    8h00, 8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h00, 8h00, 8h00, 8hfc, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h06, 8h0c, 8h18, 8h30, 8h60, 8hc0, 8h80, 8h00,
    8h7c, 8hc6, 8hce, 8hde, 8hf6, 8he6, 8h7c, 8h00,
    8h30, 8h70, 8h30, 8h30, 8h30, 8h30, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h60, 8hcc, 8hfc, 8h00,
    8h78, 8hcc, 8h0c, 8h38, 8h0c, 8hcc, 8h78, 8h00,
    8h1c, 8h3c, 8h6c, 8hcc, 8hfe, 8h0c, 8h1e, 8h00,
    8hfc, 8hc0, 8hf8, 8h0c, 8h0c, 8hcc, 8h78, 8h00,
    8h38, 8h60, 8hc0, 8hf8, 8hcc, 8hcc, 8h78, 8h00,
    8hfc, 8hcc, 8h0c, 8h18, 8h30, 8h30, 8h30, 8h00,
    8h78, 8hcc, 8hcc, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8hcc, 8h7c, 8h0c, 8h18, 8h70, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h30, 8h30, 8h00, 8h00, 8h30, 8h30, 8h60,
    8h18, 8h30, 8h60, 8hc0, 8h60, 8h30, 8h18, 8h00,
    8h00, 8h00, 8hfc, 8h00, 8h00, 8hfc, 8h00, 8h00,
    8h60, 8h30, 8h18, 8h0c, 8h18, 8h30, 8h60, 8h00,
    8h78, 8hcc, 8h0c, 8h18, 8h30, 8h00, 8h30, 8h00,
    8h7c, 8hc6, 8hde, 8hde, 8hde, 8hc0, 8h78, 8h00,
    8h30, 8h78, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h66, 8h66, 8hfc, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hc0, 8h66, 8h3c, 8h00,
    8hf8, 8h6c, 8h66, 8h66, 8h66, 8h6c, 8hf8, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h62, 8hfe, 8h00,
    8hfe, 8h62, 8h68, 8h78, 8h68, 8h60, 8hf0, 8h00,
    8h3c, 8h66, 8hc0, 8hc0, 8hce, 8h66, 8h3e, 8h00,
    8hcc, 8hcc, 8hcc, 8hfc, 8hcc, 8hcc, 8hcc, 8h00,
    8h78, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h1e, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78, 8h00,
    8he6, 8h66, 8h6c, 8h78, 8h6c, 8h66, 8he6, 8h00,
    8hf0, 8h60, 8h60, 8h60, 8h62, 8h66, 8hfe, 8h00,
    8hc6, 8hee, 8hfe, 8hfe, 8hd6, 8hc6, 8hc6, 8h00,
    8hc6, 8he6, 8hf6, 8hde, 8hce, 8hc6, 8hc6, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8hc6, 8h6c, 8h38, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h60, 8h60, 8hf0, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hdc, 8h78, 8h1c, 8h00,
    8hfc, 8h66, 8h66, 8h7c, 8h6c, 8h66, 8he6, 8h00,
    8h78, 8hcc, 8he0, 8h70, 8h1c, 8hcc, 8h78, 8h00,
    8hfc, 8hb4, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hfc, 8h00,
    8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8hc6, 8hc6, 8hc6, 8hd6, 8hfe, 8hee, 8hc6, 8h00,
    8hc6, 8hc6, 8h6c, 8h38, 8h38, 8h6c, 8hc6, 8h00,
    8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h30, 8h78, 8h00,
    8hfe, 8hc6, 8h8c, 8h18, 8h32, 8h66, 8hfe, 8h00,
    8h78, 8h60, 8h60, 8h60, 8h60, 8h60, 8h78, 8h00,
    8hc0, 8h60, 8h30, 8h18, 8h0c, 8h06, 8h02, 8h00,
    8h78, 8h18, 8h18, 8h18, 8h18, 8h18, 8h78, 8h00,
    8h10, 8h38, 8h6c, 8hc6, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8hff,
    8h30, 8h30, 8h18, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h76, 8h00,
    8he0, 8h60, 8h60, 8h7c, 8h66, 8h66, 8hdc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h00,
    8h1c, 8h0c, 8h0c, 8h7c, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h38, 8h6c, 8h60, 8hf0, 8h60, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8he0, 8h60, 8h6c, 8h76, 8h66, 8h66, 8he6, 8h00,
    8h30, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h0c, 8h00, 8h0c, 8h0c, 8h0c, 8hcc, 8hcc, 8h78,
    8he0, 8h60, 8h66, 8h6c, 8h78, 8h6c, 8he6, 8h00,
    8h70, 8h30, 8h30, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h00, 8hcc, 8hfe, 8hfe, 8hd6, 8hc6, 8h00,
    8h00, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8h00, 8h78, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8hdc, 8h66, 8h66, 8h7c, 8h60, 8hf0,
    8h00, 8h00, 8h76, 8hcc, 8hcc, 8h7c, 8h0c, 8h1e,
    8h00, 8h00, 8hdc, 8h76, 8h66, 8h60, 8hf0, 8h00,
    8h00, 8h00, 8h7c, 8hc0, 8h78, 8h0c, 8hf8, 8h00,
    8h10, 8h30, 8h7c, 8h30, 8h30, 8h34, 8h18, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h76, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h78, 8h30, 8h00,
    8h00, 8h00, 8hc6, 8hd6, 8hfe, 8hfe, 8h6c, 8h00,
    8h00, 8h00, 8hc6, 8h6c, 8h38, 8h6c, 8hc6, 8h00,
    8h00, 8h00, 8hcc, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8h00, 8h00, 8hfc, 8h98, 8h30, 8h64, 8hfc, 8h00,
    8h1c, 8h30, 8h30, 8he0, 8h30, 8h30, 8h1c, 8h00,
    8h18, 8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h00,
    8he0, 8h30, 8h30, 8h1c, 8h30, 8h30, 8he0, 8h00,
    8h76, 8hdc, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h10, 8h38, 8h6c, 8hc6, 8hc6, 8hfe, 8h00,
    8h78, 8hcc, 8hc0, 8hcc, 8h78, 8h18, 8h0c, 8h78,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h1c, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8h7e, 8hc3, 8h3c, 8h06, 8h3e, 8h66, 8h3f, 8h00,
    8hcc, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8he0, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h30, 8h30, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h00, 8h00, 8h78, 8hc0, 8hc0, 8h78, 8h0c, 8h38,
    8h7e, 8hc3, 8h3c, 8h66, 8h7e, 8h60, 8h3c, 8h00,
    8hcc, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8he0, 8h00, 8h78, 8hcc, 8hfc, 8hc0, 8h78, 8h00,
    8hcc, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h7c, 8hc6, 8h38, 8h18, 8h18, 8h18, 8h3c, 8h00,
    8he0, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8hc6, 8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8hc6, 8h00,
    8h30, 8h30, 8h00, 8h78, 8hcc, 8hfc, 8hcc, 8h00,
    8h1c, 8h00, 8hfc, 8h60, 8h78, 8h60, 8hfc, 8h00,
    8h00, 8h00, 8h7f, 8h0c, 8h7f, 8hcc, 8h7f, 8h00,
    8h3e, 8h6c, 8hcc, 8hfe, 8hcc, 8hcc, 8hce, 8h00,
    8h78, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8hcc, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8he0, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h78, 8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8he0, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hcc, 8h00, 8hcc, 8hcc, 8h7c, 8h0c, 8hf8,
    8hc3, 8h18, 8h3c, 8h66, 8h66, 8h3c, 8h18, 8h00,
    8hcc, 8h00, 8hcc, 8hcc, 8hcc, 8hcc, 8h78, 8h00,
    8h18, 8h18, 8h7e, 8hc0, 8hc0, 8h7e, 8h18, 8h18,
    8h38, 8h6c, 8h64, 8hf0, 8h60, 8he6, 8hfc, 8h00,
    8hcc, 8hcc, 8h78, 8hfc, 8h30, 8hfc, 8h30, 8h30,
    8hf8, 8hcc, 8hcc, 8hfa, 8hc6, 8hcf, 8hc6, 8hc7,
    8h0e, 8h1b, 8h18, 8h3c, 8h18, 8h18, 8hd8, 8h70,
    8h1c, 8h00, 8h78, 8h0c, 8h7c, 8hcc, 8h7e, 8h00,
    8h38, 8h00, 8h70, 8h30, 8h30, 8h30, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8h78, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h1c, 8h00, 8hcc, 8hcc, 8hcc, 8h7e, 8h00,
    8h00, 8hf8, 8h00, 8hf8, 8hcc, 8hcc, 8hcc, 8h00,
    8hfc, 8h00, 8hcc, 8hec, 8hfc, 8hdc, 8hcc, 8h00,
    8h3c, 8h6c, 8h6c, 8h3e, 8h00, 8h7e, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h7c, 8h00, 8h00,
    8h30, 8h00, 8h30, 8h60, 8hc0, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8hc0, 8hc0, 8h00, 8h00,
    8h00, 8h00, 8h00, 8hfc, 8h0c, 8h0c, 8h00, 8h00,
    8hc3, 8hc6, 8hcc, 8hde, 8h33, 8h66, 8hcc, 8h0f,
    8hc3, 8hc6, 8hcc, 8hdb, 8h37, 8h6f, 8hcf, 8h03,
    8h18, 8h18, 8h00, 8h18, 8h18, 8h18, 8h18, 8h00,
    8h00, 8h33, 8h66, 8hcc, 8h66, 8h33, 8h00, 8h00,
    8h00, 8hcc, 8h66, 8h33, 8h66, 8hcc, 8h00, 8h00,
    8h22, 8h88, 8h22, 8h88, 8h22, 8h88, 8h22, 8h88,
    8h55, 8haa, 8h55, 8haa, 8h55, 8haa, 8h55, 8haa,
    8hdb, 8h77, 8hdb, 8hee, 8hdb, 8h77, 8hdb, 8hee,
    8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8hf6, 8h36, 8h36, 8h36,
    8h00, 8h00, 8h00, 8h00, 8hfe, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hf8, 8h18, 8hf8, 8h18, 8h18, 8h18,
    8h36, 8h36, 8hf6, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hfe, 8h06, 8hf6, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf6, 8h06, 8hfe, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hfe, 8h00, 8h00, 8h00,
    8h18, 8h18, 8hf8, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hf8, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h18, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h36, 8h36, 8h36, 8h36, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h3f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3f, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h36, 8h36, 8hf7, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h37, 8h30, 8h37, 8h36, 8h36, 8h36,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8hf7, 8h00, 8hf7, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h00, 8hff, 8h00, 8h00, 8h00,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h00, 8h00, 8h00,
    8h00, 8h00, 8hff, 8h00, 8hff, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8hff, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8h3f, 8h00, 8h00, 8h00,
    8h18, 8h18, 8h1f, 8h18, 8h1f, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h1f, 8h18, 8h1f, 8h18, 8h18, 8h18,
    8h00, 8h00, 8h00, 8h00, 8h3f, 8h36, 8h36, 8h36,
    8h36, 8h36, 8h36, 8h36, 8hff, 8h36, 8h36, 8h36,
    8h18, 8h18, 8hff, 8h18, 8hff, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8hf8, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h1f, 8h18, 8h18, 8h18,
    8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff, 8hff,
    8h00, 8h00, 8h00, 8h00, 8hff, 8hff, 8hff, 8hff,
    8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0, 8hf0,
    8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f, 8h0f,
    8hff, 8hff, 8hff, 8hff, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h76, 8hdc, 8hc8, 8hdc, 8h76, 8h00,
    8h00, 8h78, 8hcc, 8hf8, 8hcc, 8hf8, 8hc0, 8hc0,
    8h00, 8hfc, 8hcc, 8hc0, 8hc0, 8hc0, 8hc0, 8h00,
    8h00, 8hfe, 8h6c, 8h6c, 8h6c, 8h6c, 8h6c, 8h00,
    8hfc, 8hcc, 8h60, 8h30, 8h60, 8hcc, 8hfc, 8h00,
    8h00, 8h00, 8h7e, 8hd8, 8hd8, 8hd8, 8h70, 8h00,
    8h00, 8h66, 8h66, 8h66, 8h66, 8h7c, 8h60, 8hc0,
    8h00, 8h76, 8hdc, 8h18, 8h18, 8h18, 8h18, 8h00,
    8hfc, 8h30, 8h78, 8hcc, 8hcc, 8h78, 8h30, 8hfc,
    8h38, 8h6c, 8hc6, 8hfe, 8hc6, 8h6c, 8h38, 8h00,
    8h38, 8h6c, 8hc6, 8hc6, 8h6c, 8h6c, 8hee, 8h00,
    8h1c, 8h30, 8h18, 8h7c, 8hcc, 8hcc, 8h78, 8h00,
    8h00, 8h00, 8h7e, 8hdb, 8hdb, 8h7e, 8h00, 8h00,
    8h06, 8h0c, 8h7e, 8hdb, 8hdb, 8h7e, 8h60, 8hc0,
    8h38, 8h60, 8hc0, 8hf8, 8hc0, 8h60, 8h38, 8h00,
    8h78, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8hcc, 8h00,
    8h00, 8hfc, 8h00, 8hfc, 8h00, 8hfc, 8h00, 8h00,
    8h30, 8h30, 8hfc, 8h30, 8h30, 8h00, 8hfc, 8h00,
    8h60, 8h30, 8h18, 8h30, 8h60, 8h00, 8hfc, 8h00,
    8h18, 8h30, 8h60, 8h30, 8h18, 8h00, 8hfc, 8h00,
    8h0e, 8h1b, 8h1b, 8h18, 8h18, 8h18, 8h18, 8h18,
    8h18, 8h18, 8h18, 8h18, 8h18, 8hd8, 8hd8, 8h70,
    8h30, 8h30, 8h00, 8hfc, 8h00, 8h30, 8h30, 8h00,
    8h00, 8h76, 8hdc, 8h00, 8h76, 8hdc, 8h00, 8h00,
    8h38, 8h6c, 8h6c, 8h38, 8h00, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h18, 8h18, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h18, 8h00, 8h00, 8h00,
    8h0f, 8h0c, 8h0c, 8h0c, 8hec, 8h6c, 8h3c, 8h1c,
    8h78, 8h6c, 8h6c, 8h6c, 8h6c, 8h00, 8h00, 8h00,
    8h70, 8h18, 8h30, 8h60, 8h78, 8h00, 8h00, 8h00,
    8h00, 8h00, 8h3c, 8h3c, 8h3c, 8h3c, 8h00, 8h00,
    8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00, 8h00

    };

    // GPU COLOUR
    uint7 gpu_active_colour = uninitialized;

    // GPU <-> VECTOR DRAWER Communication
    int11 v_gpu_x = uninitialised;
    int11 v_gpu_y = uninitialised;
    uint7 v_gpu_colour = uninitialised;
    int11 v_gpu_param0 = uninitialised;
    int11 v_gpu_param1 = uninitialised;
    uint1 v_gpu_write = uninitialised;

    // VECTOR DRAWER UNIT
    vectors vector_drawer (
        vector_block_number <: vector_block_number,
        vector_block_colour <: vector_block_colour,
        vector_block_xc <: vector_block_xc,
        vector_block_yc <: vector_block_yc,
        draw_vector <: draw_vector,
        vertices_writer_block <: vertices_writer_block,
        vertices_writer_vertex <: vertices_writer_vertex,
        vertices_writer_xdelta <: vertices_writer_xdelta,
        vertices_writer_ydelta <: vertices_writer_ydelta,
        vertices_writer_active <: vertices_writer_active,

        vector_block_active :> vector_block_active,

        gpu_x :> v_gpu_x,
        gpu_y :> v_gpu_y,
        gpu_colour :> v_gpu_colour,
        gpu_param0 :> v_gpu_param0,
        gpu_param1 :> v_gpu_param1,
        gpu_write :> v_gpu_write,
        gpu_active <: gpu_active
    );

    // GPU SUBUNITS
    rectangle GPUrectangle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1
    );
    line GPUline(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1
    );
    circle GPUcircle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0
    );
    disc GPUdisc(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0
    );
    triangle GPUtriangle(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1,
        param2 <: gpu_param2,
        param3 <: gpu_param3,
    );
    blit GPUblit(
        x <: gpu_x,
        y <: gpu_y,
        param0 <: gpu_param0,
        param1 <: gpu_param1,
        blit1tilemap <:> blit1tilemap,
        characterGenerator8x8 <:> characterGenerator8x8
    );

    // DRAW A LINE FROM VECTOR BLOCK OUTPUT
    line VECTORline(
        x <: v_gpu_x,
        y <: v_gpu_y,
        param0 <: v_gpu_param0,
        param1 <: v_gpu_param1
    );

    // blit1tilemap write access for the GPU to load tilemaps
    blit1tilemap.addr1 := blit1_writer_tile * 16 + blit1_writer_line;
    blit1tilemap.wdata1 := blit1_writer_bitmap;
    blit1tilemap.wenable1 := 1;

    // CONTROLS FOR BITMAP PIXEL WRITER
    bitmap_write := 0;
    bitmap_colour_write := gpu_active_colour;

    // CONTROLS FOR GPU SUBUNITS
    GPUrectangle.start := 0;
    GPUline.start := 0;
    GPUcircle.start := 0;
    GPUdisc.start := 0;
    GPUtriangle.start := 0;
    GPUblit.start := 0;
    VECTORline.start := 0;

    while(1) {
        if( v_gpu_write ) {
            // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1) from VECTOR BLOCK
            gpu_active_colour = v_gpu_colour;
            gpu_active = 1;
            VECTORline.start = 1;
            while( VECTORline.busy ) {
                bitmap_x_write = VECTORline.bitmap_x_write;
                bitmap_y_write = VECTORline.bitmap_y_write;
                bitmap_write = VECTORline.bitmap_write;
            }
            gpu_active = 0;
        } else {
            gpu_active_colour = gpu_colour;
            switch( gpu_write ) {
                case 1: {
                    // SET PIXEL (X,Y)
                    // NO GPU ACTIVATION
                    bitmap_x_write = gpu_x;
                    bitmap_y_write = gpu_y;
                    bitmap_write = 1;
                }

                case 2: {
                    // DRAW RECTANGLE FROM (X,Y) to (PARAM0,PARAM1)
                    gpu_active = 1;
                    GPUrectangle.start = 1;
                    while( GPUrectangle.busy ) {
                        bitmap_x_write = GPUrectangle.bitmap_x_write;
                        bitmap_y_write = GPUrectangle.bitmap_y_write;
                        bitmap_write = GPUrectangle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 3: {
                    // DRAW LINE FROM (X,Y) to (PARAM0,PARAM1)
                    gpu_active = 1;
                    GPUline.start = 1;
                    while( GPUline.busy ) {
                        bitmap_x_write = GPUline.bitmap_x_write;
                        bitmap_y_write = GPUline.bitmap_y_write;
                        bitmap_write = GPUline.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 4: {
                    // DRAW CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    gpu_active = 1;
                    GPUcircle.start = 1;
                    while( GPUcircle.busy ) {
                        bitmap_x_write = GPUcircle.bitmap_x_write;
                        bitmap_y_write = GPUcircle.bitmap_y_write;
                        bitmap_write = GPUcircle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 5: {
                    // BLIT 16 x 16 TILE PARAM0 TO (X,Y)
                    gpu_active = 1;
                    GPUblit.start = 1;
                    while( GPUblit.busy ) {
                        bitmap_x_write = GPUblit.bitmap_x_write;
                        bitmap_y_write = GPUblit.bitmap_y_write;
                        bitmap_write = GPUblit.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 6: {
                    // DRAW FILLED CIRCLE CENTRE (X,Y) with RADIUS PARAM0
                    gpu_active = 1;
                    GPUdisc.start = 1;
                    while( GPUdisc.busy ) {
                        bitmap_x_write = GPUdisc.bitmap_x_write;
                        bitmap_y_write = GPUdisc.bitmap_y_write;
                        bitmap_write = GPUdisc.bitmap_write;
                    }
                    gpu_active = 0;
                }

                case 7: {
                    // DRAW FILLED TRIANGLE WITH VERTICES (X,Y) (PARAM0,PARAM1) (PARAM2,PARAM3)
                    gpu_active = 1;
                    GPUtriangle.start = 1;
                    while( GPUtriangle.busy ) {
                        bitmap_x_write = GPUtriangle.bitmap_x_write;
                        bitmap_y_write = GPUtriangle.bitmap_y_write;
                        bitmap_write = GPUtriangle.bitmap_write;
                    }
                    gpu_active = 0;
                }

                default: { gpu_active = 0; }
            }
        }
    }
}

// RECTANGLE - OUTPUT PIXELS TO DRAW A RECTANGLE
algorithm rectangle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,

    output!  uint11  bitmap_x_write,
    output!  uint11  bitmap_y_write,
    output!  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_x1 = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_max_y = uninitialized;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a rectangle from x,y to param0,param1 in colour
            // Ensures that works left to right, top to bottom, crop to screen edges
            ( gpu_active_x ) = min( x, param0 );
            ( gpu_active_y ) = min( y, param1 );
            ( gpu_max_x ) = max( x, param0 );
            ( gpu_max_y ) = max( y, param1 );
            ++:
            ( gpu_active_x ) = cropleft( gpu_active_x );
            ( gpu_x1 ) = cropleft( gpu_active_x );
            ( gpu_active_y ) = croptop( gpu_active_y );
            ( gpu_max_x ) = cropright( gpu_max_x );
            ( gpu_max_y ) = cropbottom( gpu_max_y );
            ++:
            while( gpu_active_y <= gpu_max_y ) {
                bitmap_y_write = gpu_active_y;
                while( gpu_active_x <= gpu_max_x ) {
                    bitmap_x_write = gpu_active_x;
                    bitmap_write = 1;
                    gpu_active_x = gpu_active_x + 1;
                }
                gpu_active_x = gpu_x1;
                gpu_active_y = gpu_active_y + 1;
            }
            active = 0;
        }
    }
}

// LINE - OUTPUT PIXELS TO DRAW A LINE
algorithm line (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,

    output!  uint11  bitmap_x_write,
    output!  uint11  bitmap_y_write,
    output!  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_dx = uninitialized;
    int11   gpu_dy = uninitialized;
    int11   gpu_sy = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_max_y = uninitialized;
    int11   gpu_numerator = uninitialized;
    int11   gpu_numerator2 = uninitialized;
    int11   gpu_count = uninitialized;
    int11   gpu_max_count = uninitialized;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a line from x,y to param0,param1 in colour
            // Ensure LEFT to RIGHT
            ( gpu_active_x ) = min( x, param0 );
            gpu_active_y = ( x < param0 ) ? y : param1;
            // Determine if moving UP or DOWN
            gpu_sy = ( x < param0 ) ? ( ( y < param1 ) ? 1 : -1 ) : ( ( y < param1 ) ? -1 : 1 );
            // Absolute DELTAs
            ( gpu_dx ) = absdelta( x, param0 );
            ( gpu_dy ) = absdelta( y, param1 );
            ++:
            gpu_count = 0;
            gpu_numerator = ( gpu_dx > gpu_dy ) ? ( gpu_dx >> 1 ) : -( gpu_dy >> 1 );
            ( gpu_max_count ) = max( gpu_dx, gpu_dy );
            ++:
            while( gpu_count <= gpu_max_count ) {
                bitmap_x_write = gpu_active_x;
                bitmap_y_write = gpu_active_y;
                bitmap_write = 1;
                gpu_numerator2 = gpu_numerator;
                ++:
                if( gpu_numerator2 > (-gpu_dx) ) {
                    gpu_numerator = gpu_numerator - gpu_dy;
                    gpu_active_x = gpu_active_x + 1;
                }
                ++:
                if( gpu_numerator2 < gpu_dy ) {
                    gpu_numerator = gpu_numerator + gpu_dx;
                    gpu_active_y = gpu_active_y + gpu_sy;
                }
                gpu_count = gpu_count + 1;
            }
            active = 0;
        }
    }
}

// CIRCLE - OUTPUT PIXELS TO DRAW AN OUTLINE CIRCLE
algorithm circle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_xc = uninitialized;
    int11   gpu_yc = uninitialized;
    int11   gpu_numerator = uninitialized;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a circle centre x,y or radius param0 in colour
            gpu_active_x = 0;
            ( gpu_active_y ) = abs( param0 );
            ( gpu_xc, gpu_yc ) = copycoordinates( x, y );
            ++:
            gpu_numerator = 3 - ( 2 * gpu_active_y );
            ++:
            while( gpu_active_y >= gpu_active_x ) {
                bitmap_x_write = gpu_xc + gpu_active_x;
                bitmap_y_write = gpu_yc + gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc - gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc - gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc + gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc + gpu_active_y;
                bitmap_y_write = gpu_yc + gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc - gpu_active_x;
                bitmap_write = 1;
                ++:
                bitmap_x_write = gpu_xc - gpu_active_y;
                bitmap_write = 1;
                ++:
                bitmap_y_write = gpu_yc + gpu_active_x;
                bitmap_write = 1;

                gpu_active_x = gpu_active_x + 1;
                if( gpu_numerator > 0 ) {
                    gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                    gpu_active_y = gpu_active_y - 1;
                } else {
                    gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                }
            }
            active = 0;
        }
    }
}

//  DISC - OUTPUT PIXELS TO DRAW A FILLED CIRCLE
algorithm disc (
    input   int11   x,
    input   int11   y,
    input   int11   param0,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_xc = uninitialized;
    int11   gpu_yc = uninitialized;
    int11   gpu_numerator = uninitialized;
    int11   gpu_count = uninitialised;
    uint1   active = 0;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a filled circle centre x,y or radius param0 in colour
            // Minimum radius is 4, radius is always positive
            gpu_active_x = 0;
            ( gpu_active_y ) = abs( param0 );
            ( gpu_xc, gpu_yc ) = copycoordinates( x, y );
            ++:
            gpu_active_y = ( gpu_active_y < 4 ) ? 4 : gpu_active_y;
            ++:
            gpu_count = gpu_active_y;
            gpu_numerator = 3 - ( 2 * gpu_active_y );
            ++:
            while( gpu_active_y >= gpu_active_x ) {
                while( gpu_count != 0 ) {
                    bitmap_x_write = gpu_xc + gpu_active_x;
                    bitmap_y_write = gpu_yc + gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc - gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc - gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc + gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc + gpu_count;
                    bitmap_y_write = gpu_yc + gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc - gpu_active_x;
                    bitmap_write = 1;
                    ++:
                    bitmap_x_write = gpu_xc - gpu_count;
                    bitmap_write = 1;
                    ++:
                    bitmap_y_write = gpu_yc + gpu_active_x;
                    bitmap_write = 1;

                    gpu_count = gpu_count - 1;
                }
                gpu_active_x = gpu_active_x + 1;
                if( gpu_numerator > 0 ) {
                    gpu_numerator = gpu_numerator + 4 * (gpu_active_x - gpu_active_y) + 10;
                    gpu_active_y = gpu_active_y - 1;
                    gpu_count = gpu_active_y - 1;
                } else {
                    gpu_numerator = gpu_numerator + 4 * gpu_active_x + 6;
                    gpu_count = gpu_active_y;
                }
            }
            bitmap_x_write = gpu_xc;
            bitmap_y_write = gpu_yc;
            bitmap_write = 1;
            active = 0;
        }
    }
}

//  TRIANGLE - OUTPUT PIXELS TO DRAW A FILLED TRIANGLE
algorithm triangle (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   int11   param1,
    input   int11   param2,
    input   int11   param3,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    output  uint1   busy
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_x1 = uninitialized;
    int11   gpu_y1 = uninitialized;
    int11   gpu_x2 = uninitialized;
    int11   gpu_y2 = uninitialized;
    int11   gpu_dx = uninitialized;
    int11   gpu_sx = uninitialized;
    int11   gpu_dy = uninitialized;
    int11   gpu_sy = uninitialized;
    int11   gpu_min_x = uninitialized;
    int11   gpu_max_x = uninitialized;
    int11   gpu_min_y = uninitialized;
    int11   gpu_max_y = uninitialized;
    uint1   gpu_count = uninitialized;
    uint1   active = 0;

    // Filled triangle calculations
    // Is the point sx,sy inside the triangle given by active_x,active_y x1,y1 x2,y2?
    uint1 w0 = uninitialized;
    uint1 w1 = uninitialized;
    uint1 w2 = uninitialized;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            // Setup drawing a filled triangle x,y param0, param1, param2, param3
            ( gpu_active_x, gpu_active_y ) = copycoordinates( x, y);
            ( gpu_x1, gpu_y1 ) = copycoordinates( param0, param1 );
            ( gpu_x2, gpu_y2 ) = copycoordinates( param2, param3 );
            ++:
            // Find minimum and maximum of x, x1, x2, y, y1 and y2 for the bounding box
            ( gpu_min_x ) = min3( gpu_active_x, gpu_x1, gpu_x2 );
            ( gpu_min_y ) = min3( gpu_active_y, gpu_y1, gpu_y2 );
            ( gpu_max_x ) = max3( gpu_active_x, gpu_x1, gpu_x2 );
            ( gpu_max_y ) = max3( gpu_active_y, gpu_y1, gpu_y2 );
            ++:
            // Clip to the screen edge
            ( gpu_min_x ) = cropleft( gpu_min_x );
            ( gpu_max_x ) = cropright( gpu_max_x );
            ( gpu_min_y ) = croptop( gpu_min_y );
            ( gpu_max_y ) = cropbottom( gpu_max_y );
            ++:
            // Find the point closest to the top of the screen ( put into gpu_active_x and gpu_active_y )
            if( gpu_y1 < gpu_active_y ) {
                ( gpu_active_x, gpu_active_y, gpu_x1, gpu_y1 ) = swapcoordinates( gpu_active_x, gpu_active_y, gpu_x1, gpu_y1 );
            }
            ++:
            if( gpu_y2 < gpu_active_y ) {
                ( gpu_active_x, gpu_active_y, gpu_x2, gpu_y2 ) = swapcoordinates( gpu_active_x, gpu_active_y, gpu_x2, gpu_y2 );
            }
            ++:
            // Point order is top of screen then down to the right
            if( gpu_x1 < gpu_x2 ) {
                ( gpu_x1, gpu_y1, gpu_x2, gpu_y2 ) = swapcoordinates( gpu_x1, gpu_y1, gpu_x2, gpu_y2 );
            }
            ++:
            // Start at the top left
            ( gpu_sx, gpu_sy ) = copycoordinates( gpu_min_x, gpu_min_y );
            gpu_dx = 1;
            gpu_count = 0;
            ++:
            while( gpu_sy <= gpu_max_y ) {
                // Edge calculations to determine if inside the triangle - converted to DSP blocks
                w0 = (( gpu_x2 - gpu_x1 ) * ( gpu_sy - gpu_y1 ) - ( gpu_y2 - gpu_y1 ) * ( gpu_sx - gpu_x1 )) >= 0;
                w1 = (( gpu_active_x - gpu_x2 ) * ( gpu_sy - gpu_y2 ) - ( gpu_active_y - gpu_y2 ) * ( gpu_sx - gpu_x2 )) >= 0;
                w2 = (( gpu_x1 - gpu_active_x ) * ( gpu_sy - gpu_active_y ) - ( gpu_y1 - gpu_active_y ) * ( gpu_sx - gpu_active_x )) >= 0;
                ++:
                bitmap_x_write = gpu_sx;
                bitmap_y_write = gpu_sy;
                bitmap_write = ( w0 && w1 && w2 );
                gpu_count = ( w0 && w1 && w2 ) ? 1 : gpu_count;
                ++:
                if( gpu_count && ~( w0 && w1 && w2 ) ) {
                    // Exited the triangle, move to the next line
                    gpu_count = 0;
                    gpu_sy = gpu_sy + 1;
                    if( ( gpu_max_x - gpu_sx ) < ( gpu_sx - gpu_min_x ) ) {
                        // Closer to the right
                        gpu_sx = gpu_max_x;
                        gpu_dx = -1;
                    } else {
                        // Closer to the left
                        gpu_sx = gpu_min_x;
                        gpu_dx = 1;
                    }
                } else {
                    switch( gpu_dx ) {
                        case 1: {
                            if( gpu_sx < gpu_max_x ) {
                                gpu_sx = gpu_sx + 1;
                            } else {
                                gpu_dx = -1;
                                gpu_count = 0;
                                gpu_sy = gpu_sy + 1;
                            }
                        }
                        default: {
                            if( gpu_sx > gpu_min_x ) {
                                gpu_sx = gpu_sx - 1;
                            } else {
                                gpu_dx = 1;
                                gpu_count = 0;
                                gpu_sy = gpu_sy + 1;
                            }
                        }
                    }
                }
            }
            active = 0;
        }
    }
}

// BLIT - OUTPUT PIXELS TO BLIT A 16 x 16 TILE
algorithm blit (
    input   int11   x,
    input   int11   y,
    input   int11   param0,
    input   uint2   param1,

    output  uint11  bitmap_x_write,
    output  uint11  bitmap_y_write,
    output  uint1   bitmap_write,

    input   uint1   start,
    input   uint1   tilecharacter,
    output  uint1   busy,

    simple_dualbram_port0 blit1tilemap,
) <autorun> {
    int11   gpu_active_x = uninitialized;
    int11   gpu_active_y = uninitialized;
    int11   gpu_x1 = uninitialized;
    int11   gpu_y1 = uninitialized;
    int11   gpu_y2 = uninitialised;
    int11   gpu_max_x = uninitialized;
    int11   gpu_max_y = uninitialized;
    uint8   gpu_tile = uninitialized;

    uint1   active = 0;

    // tile and character bitmap addresses
    blit1tilemap.addr0 := gpu_tile * 16 + gpu_active_y;

    busy := start ? 1 : active;
    bitmap_write := 0;

    while(1) {
        if( start ) {
            active = 1;
            gpu_active_x = 0;
            gpu_active_y = 0;
            ( gpu_x1, gpu_y1 ) = copycoordinates( x, y );
            gpu_max_x = 16;
            gpu_max_y = 16;
            gpu_tile = param0;
            ++:
            while( gpu_active_y < gpu_max_y ) {
                while( gpu_active_x < gpu_max_x ) {
                    bitmap_x_write = gpu_x1 + gpu_active_x;
                    bitmap_y_write = gpu_y1 + gpu_active_y;
                    bitmap_write = blit1tilemap.rdata0[15 - gpu_active_x, 1];
                    gpu_active_x = gpu_active_x + 1;
                }
                gpu_active_x = 0;
                gpu_active_y = gpu_active_y + 1;
            }
            active = 0;
        }
    }
}

// Vector Block
// Stores blocks of upto 16 vertices which can be sent to the GPU for line drawing
// Each vertices represents a delta from the centre of the vector
// Deltas are stored as 6 bit 2's complement range -31 to 0 to 31
// Each vertices has an active flag, processing of a vector block stops when the active flag is 0
// Each vector block has a centre x and y coordinate and a colour { rrggbb } when drawn

// Vertex in the vector block
bitfield vectorentry {
    uint1   active,
    uint1   dxsign,
    uint5   dx,
    uint1   dysign,
    uint5   dy
}

algorithm vectors(
    input   uint5   vector_block_number,
    input   uint7   vector_block_colour,
    input   int11   vector_block_xc,
    input   int11   vector_block_yc,
    input   uint1   draw_vector,

    // For setting vertices
    input   uint5   vertices_writer_block,
    input   uint6   vertices_writer_vertex,
    input   int6    vertices_writer_xdelta,
    input   int6    vertices_writer_ydelta,
    input   uint1   vertices_writer_active,

    output  uint1   vector_block_active,

    // Communication with the GPU
    output  int11 gpu_x,
    output  int11 gpu_y,
    output  uint7 gpu_colour,
    output  int11 gpu_param0,
    output  int11 gpu_param1,
    output  uint1 gpu_write,

    input  uint1 gpu_active
) <autorun> {
    // 32 vector blocks each of 16 vertices
    simple_dualport_bram uint13 vertex[512] = uninitialised;

    // Extract deltax and deltay for the present vertices
    int11 deltax := { {6{vectorentry(vertex.rdata0).dxsign}}, vectorentry(vertex.rdata0).dx };
    int11 deltay := { {6{vectorentry(vertex.rdata0).dysign}}, vectorentry(vertex.rdata0).dy };

    // Vertices being processed, plus first coordinate of each line
    uint5 block_number = uninitialised;
    uint5 vertices_number = uninitialised;
    int11 start_x = uninitialised;
    int11 start_y = uninitialised;

    // Set read and write address for the vertices
    vertex.addr0 := block_number * 16 + vertices_number;
    vertex.addr1 := vertices_writer_block * 16 + vertices_writer_vertex;
    vertex.wdata1 := { vertices_writer_active, __unsigned(vertices_writer_xdelta), __unsigned(vertices_writer_ydelta) };
    vertex.wenable1 := 1;

    gpu_write := 0;

    vector_block_active = 0;
    vertices_number = 0;

    while(1) {
        if( draw_vector ) {
            block_number = vector_block_number;
            gpu_colour = vector_block_colour;
            vertices_number = 0;
            vector_block_active = 1;
            ++:
            ( start_x, start_y ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
            vertices_number = 1;
            ++:
            while( vectorentry(vertex.rdata0).active && ( vertices_number < 16 ) ) {
                // Dispatch line to GPU
                ( gpu_x, gpu_y ) = copycoordinates( start_x, start_y );
                ( gpu_param0, gpu_param1 ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
                while( gpu_active ) {}
                gpu_write = 1;
                // Move onto the next of the vertices
                ( start_x, start_y ) = deltacoordinates( vector_block_xc, deltax, vector_block_yc, deltay );
                vertices_number = vertices_number + 1;
                ++:
            }
            vector_block_active = 0;
        }
    }
}

algorithm background(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,

    input uint16 staticGenerator,

    input uint6 backgroundcolour,
    input uint6 backgroundcolour_alt,
    input uint4 backgroundcolour_mode,
    input uint3 background_write
) <autorun> {
    uint6 background = 0;
    uint6 background_alt = 0;
    uint4 background_mode = 0;

    // Variables for SNOW (from @sylefeb)
    int10   dotpos = 0;
    int2    speed = 0;
    int2    inv_speed = 0;
    int12   rand_x = 0;
    int32   frame = 0;

    // Default to SOLID
    pix_red := colour6(background).red;
    pix_green := colour6(background).green;
    pix_blue := colour6(background).blue;

    while(1) {
        // UPDATE BACKGROUND GENERATOR PARAMETERS
        switch( background_write ) {
            case 1: { background = backgroundcolour; }
            case 2: { background_alt = backgroundcolour_alt; }
            case 3: { background_mode = backgroundcolour_mode; }
        }

        // Increment frame number for the snow/star field
        frame = ( ( pix_x == 639 ) && ( pix_y == 470 ) ) ? frame + 1 : frame;

        // RENDER
        if( pix_active ) {
            switch( background_mode ) {
                case 1: {
                    // SMALL checkerboard
                    switch( { pix_x[0,1], pix_y[0,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 2: {
                    // MEDIUM checkerboard
                    switch( { pix_x[1,1], pix_y[1,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 3: {
                    // LARGE checkerboard
                    switch( { pix_x[2,1], pix_y[2,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 4: {
                    // HUGE checkerboard
                    switch( { pix_x[3,1], pix_y[3,1] } ) {
                        case 2b00: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                        case 2b01: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b10: {
                            pix_red = colour6(background_alt).red;
                            pix_green = colour6(background_alt).green;
                            pix_blue = colour6(background_alt).blue;
                        }
                        case 2b11: {
                            pix_red = colour6(background).red;
                            pix_green = colour6(background).green;
                            pix_blue = colour6(background).blue;
                        }
                    }
                }
                case 5: {
                    // 8 colour rainbow
                    switch( pix_y[6,3] ) {
                        case 3b000: { pix_red = 2; }
                        case 3b001: { pix_red = 3; }
                        case 3b010: { pix_red = 3; pix_green = 2; }
                        case 3b011: { pix_red = 3; pix_green = 3; }
                        case 3b100: { pix_green = 3; }
                        case 3b101: { pix_blue = 3; }
                        case 3b110: { pix_red = 1; pix_blue = 2; }
                        case 3b111: { pix_red = 1; pix_green = 2; pix_blue = 3; }
                    }
                }
                case 6: {
                    // Static
                    pix_red = staticGenerator[0,2];
                    pix_green = staticGenerator[0,2];
                    pix_blue = staticGenerator[0,2];
                }
                case 7: {
                    // SNOW (from @sylefeb)
                    rand_x = ( pix_x == 0)  ? 1 : rand_x * 31421 + 6927;
                    speed  = rand_x[10,2];
                    dotpos = ( frame >> speed ) + rand_x;
                        pix_red   = (pix_y == dotpos) ? colour6(background).red : colour6(background_alt).red;
                        pix_green = (pix_y == dotpos) ? colour6(background).green : colour6(background_alt).green;
                        pix_blue  = (pix_y == dotpos) ? colour6(background).blue : colour6(background_alt).blue;
                }
            }
        }
    }
}

// Sprite update flag
bitfield spriteupdate {
    uint1   y_act,              // 1 - kill when off screen, 0 - wrap
    uint1   x_act,              // 1 - kill when off screen, 0 - wrap
    uint1   tile_act,           // 1 - increase the tile number
    uint1   dysign,             // dy - 2's complement update for the y coordinate
    uint4   dy,
    uint1   dxsign,             // dx - 2's complement update for the x coordinate
    uint4   dx
}

algorithm sprite_layer(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   sprite_layer_display,

    // For setting sprite characteristics
    input   uint4   sprite_set_number,
    input   uint1   sprite_set_active,
    input   uint1   sprite_set_double,
    input   uint6   sprite_set_colour,
    input   int11   sprite_set_x,
    input   int11   sprite_set_y,
    input   uint3   sprite_set_tile,
    // Flag to set the above
    input   uint4   sprite_layer_write,

    // For reading sprite characteristics for sprite_set_number
    output uint1   sprite_read_active,
    output uint1   sprite_read_double,
    output uint6   sprite_read_colour,
    output int11   sprite_read_x,
    output int11   sprite_read_y,
    output uint3   sprite_read_tile,

    input   uint16  sprite_update,

    // FULL collision detection
    // (1) Bitmap, (2) Tile Map, (3) Other Sprite Layer
    input   uint1   collision_layer_1,
    input   uint1   collision_layer_2,
    input   uint1   collision_layer_3,
        output uint16 collision_0,
        output uint16 collision_1,
        output uint16 collision_2,
        output uint16 collision_3,
        output uint16 collision_4,
        output uint16 collision_5,
        output uint16 collision_6,
        output uint16 collision_7,
        output uint16 collision_8,
        output uint16 collision_9,
        output uint16 collision_10,
        output uint16 collision_11,
        output uint16 collision_12,

    // For setting sprite tile bitmaps
    input   uint4   sprite_writer_sprite,
    input   uint7   sprite_writer_line,
    input   uint16  sprite_writer_bitmap,
    input   uint1   sprite_writer_active

) <autorun> {
    // Storage for the sprites
    // Stored as registers as needed instantly
    uint1   sprite_active[13] = uninitialised;
    uint1   sprite_double[13] = uninitialised;
    int11   sprite_x[13] = uninitialised;
    int11   sprite_y[13] = uninitialised;
    uint6   sprite_colour[13] = uninitialised;
    uint3   sprite_tile_number[13] = uninitialised;

    uint1   output_collisions = 0;

        // Sprite Tiles
        simple_dualport_bram uint16 tiles_0 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_0 := sprite_double[0] ? 32 : 16;
        uint1 xinrange_0 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[0]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[0] + spritesize_0 ) );
        uint1 yinrange_0 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[0]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[0] + spritesize_0 ) );
        uint1 pix_visible_0 := sprite_active[0] && xinrange_0 && yinrange_0 && ( tiles_0.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[0] ) >>> sprite_double[0] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_0 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_1 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_1 := sprite_double[1] ? 32 : 16;
        uint1 xinrange_1 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[1]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[1] + spritesize_1 ) );
        uint1 yinrange_1 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[1]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[1] + spritesize_1 ) );
        uint1 pix_visible_1 := sprite_active[1] && xinrange_1 && yinrange_1 && ( tiles_1.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[1] ) >>> sprite_double[1] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_1 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_2 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_2 := sprite_double[2] ? 32 : 16;
        uint1 xinrange_2 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[2]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[2] + spritesize_2 ) );
        uint1 yinrange_2 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[2]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[2] + spritesize_2 ) );
        uint1 pix_visible_2 := sprite_active[2] && xinrange_2 && yinrange_2 && ( tiles_2.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[2] ) >>> sprite_double[2] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_2 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_3 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_3 := sprite_double[3] ? 32 : 16;
        uint1 xinrange_3 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[3]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[3] + spritesize_3 ) );
        uint1 yinrange_3 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[3]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[3] + spritesize_3 ) );
        uint1 pix_visible_3 := sprite_active[3] && xinrange_3 && yinrange_3 && ( tiles_3.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[3] ) >>> sprite_double[3] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_3 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_4 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_4 := sprite_double[4] ? 32 : 16;
        uint1 xinrange_4 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[4]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[4] + spritesize_4 ) );
        uint1 yinrange_4 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[4]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[4] + spritesize_4 ) );
        uint1 pix_visible_4 := sprite_active[4] && xinrange_4 && yinrange_4 && ( tiles_4.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[4] ) >>> sprite_double[4] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_4 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_5 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_5 := sprite_double[5] ? 32 : 16;
        uint1 xinrange_5 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[5]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[5] + spritesize_5 ) );
        uint1 yinrange_5 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[5]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[5] + spritesize_5 ) );
        uint1 pix_visible_5 := sprite_active[5] && xinrange_5 && yinrange_5 && ( tiles_5.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[5] ) >>> sprite_double[5] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_5 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_6 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_6 := sprite_double[6] ? 32 : 16;
        uint1 xinrange_6 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[6]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[6] + spritesize_6 ) );
        uint1 yinrange_6 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[6]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[6] + spritesize_6 ) );
        uint1 pix_visible_6 := sprite_active[6] && xinrange_6 && yinrange_6 && ( tiles_6.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[6] ) >>> sprite_double[6] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_6 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_7 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_7 := sprite_double[7] ? 32 : 16;
        uint1 xinrange_7 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[7]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[7] + spritesize_7 ) );
        uint1 yinrange_7 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[7]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[7] + spritesize_7 ) );
        uint1 pix_visible_7 := sprite_active[7] && xinrange_7 && yinrange_7 && ( tiles_7.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[7] ) >>> sprite_double[7] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_7 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_8 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_8 := sprite_double[8] ? 32 : 16;
        uint1 xinrange_8 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[8]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[8] + spritesize_8 ) );
        uint1 yinrange_8 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[8]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[8] + spritesize_8 ) );
        uint1 pix_visible_8 := sprite_active[8] && xinrange_8 && yinrange_8 && ( tiles_8.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[8] ) >>> sprite_double[8] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_8 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_9 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_9 := sprite_double[9] ? 32 : 16;
        uint1 xinrange_9 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[9]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[9] + spritesize_9 ) );
        uint1 yinrange_9 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[9]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[9] + spritesize_9 ) );
        uint1 pix_visible_9 := sprite_active[9] && xinrange_9 && yinrange_9 && ( tiles_9.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[9] ) >>> sprite_double[9] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_9 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_10 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_10 := sprite_double[10] ? 32 : 16;
        uint1 xinrange_10 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[10]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[10] + spritesize_10 ) );
        uint1 yinrange_10 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[10]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[10] + spritesize_10 ) );
        uint1 pix_visible_10 := sprite_active[10] && xinrange_10 && yinrange_10 && ( tiles_10.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[10] ) >>> sprite_double[10] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_10 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_11 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_11 := sprite_double[11] ? 32 : 16;
        uint1 xinrange_11 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[11]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[11] + spritesize_11 ) );
        uint1 yinrange_11 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[11]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[11] + spritesize_11 ) );
        uint1 pix_visible_11 := sprite_active[11] && xinrange_11 && yinrange_11 && ( tiles_11.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[11] ) >>> sprite_double[11] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_11 = uninitialised;
        // Sprite Tiles
        simple_dualport_bram uint16 tiles_12 <input!> [128] = uninitialised;

        // Calculate if sprite is visible
        uint6 spritesize_12 := sprite_double[12] ? 32 : 16;
        uint1 xinrange_12 := ( __signed({1b0, pix_x}) >= __signed(sprite_x[12]) ) && ( __signed({1b0, pix_x}) < __signed( sprite_x[12] + spritesize_12 ) );
        uint1 yinrange_12 := ( __signed({1b0, pix_y}) >= __signed(sprite_y[12]) ) && ( __signed({1b0, pix_y}) < __signed( sprite_y[12] + spritesize_12 ) );
        uint1 pix_visible_12 := sprite_active[12] && xinrange_12 && yinrange_12 && ( tiles_12.rdata0[ ( 15  - ( ( __signed({1b0, pix_x}) - sprite_x[12] ) >>> sprite_double[12] ) ), 1 ] );

        // Collision detection flag
        uint16      detect_collision_12 = uninitialised;

    // Expand Sprite Update Deltas
    int11   deltax := { {7{spriteupdate( sprite_update ).dxsign}}, spriteupdate( sprite_update ).dx };
    int11   deltay := { {7{spriteupdate( sprite_update ).dysign}}, spriteupdate( sprite_update ).dy };

    // Sprite update helpers
    int11   sprite_offscreen_negative ::= sprite_double[ sprite_set_number ] ? -32 : -16;
    int11   sprite_to_negative ::= sprite_double[ sprite_set_number ] ? -31 : -15;
    uint1   sprite_offscreen_x ::= ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_x[ sprite_set_number ] ) > __signed(640) );
    uint1   sprite_offscreen_y ::= ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) || ( __signed( sprite_y[ sprite_set_number ] ) > __signed(480) );

        // Set read and write address for the tiles
        tiles_0.addr0 := sprite_tile_number[0] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[0] ) >>> sprite_double[0] );
        tiles_0.wenable1 := 1;

        collision_0 := ( output_collisions ) ? detect_collision_0 : collision_0;
        // Set read and write address for the tiles
        tiles_1.addr0 := sprite_tile_number[1] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[1] ) >>> sprite_double[1] );
        tiles_1.wenable1 := 1;

        collision_1 := ( output_collisions ) ? detect_collision_1 : collision_1;
        // Set read and write address for the tiles
        tiles_2.addr0 := sprite_tile_number[2] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[2] ) >>> sprite_double[2] );
        tiles_2.wenable1 := 1;

        collision_2 := ( output_collisions ) ? detect_collision_2 : collision_2;
        // Set read and write address for the tiles
        tiles_3.addr0 := sprite_tile_number[3] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[3] ) >>> sprite_double[3] );
        tiles_3.wenable1 := 1;

        collision_3 := ( output_collisions ) ? detect_collision_3 : collision_3;
        // Set read and write address for the tiles
        tiles_4.addr0 := sprite_tile_number[4] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[4] ) >>> sprite_double[4] );
        tiles_4.wenable1 := 1;

        collision_4 := ( output_collisions ) ? detect_collision_4 : collision_4;
        // Set read and write address for the tiles
        tiles_5.addr0 := sprite_tile_number[5] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[5] ) >>> sprite_double[5] );
        tiles_5.wenable1 := 1;

        collision_5 := ( output_collisions ) ? detect_collision_5 : collision_5;
        // Set read and write address for the tiles
        tiles_6.addr0 := sprite_tile_number[6] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[6] ) >>> sprite_double[6] );
        tiles_6.wenable1 := 1;

        collision_6 := ( output_collisions ) ? detect_collision_6 : collision_6;
        // Set read and write address for the tiles
        tiles_7.addr0 := sprite_tile_number[7] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[7] ) >>> sprite_double[7] );
        tiles_7.wenable1 := 1;

        collision_7 := ( output_collisions ) ? detect_collision_7 : collision_7;
        // Set read and write address for the tiles
        tiles_8.addr0 := sprite_tile_number[8] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[8] ) >>> sprite_double[8] );
        tiles_8.wenable1 := 1;

        collision_8 := ( output_collisions ) ? detect_collision_8 : collision_8;
        // Set read and write address for the tiles
        tiles_9.addr0 := sprite_tile_number[9] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[9] ) >>> sprite_double[9] );
        tiles_9.wenable1 := 1;

        collision_9 := ( output_collisions ) ? detect_collision_9 : collision_9;
        // Set read and write address for the tiles
        tiles_10.addr0 := sprite_tile_number[10] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[10] ) >>> sprite_double[10] );
        tiles_10.wenable1 := 1;

        collision_10 := ( output_collisions ) ? detect_collision_10 : collision_10;
        // Set read and write address for the tiles
        tiles_11.addr0 := sprite_tile_number[11] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[11] ) >>> sprite_double[11] );
        tiles_11.wenable1 := 1;

        collision_11 := ( output_collisions ) ? detect_collision_11 : collision_11;
        // Set read and write address for the tiles
        tiles_12.addr0 := sprite_tile_number[12] * 16 + ( ( __signed({1b0, pix_y}) - sprite_y[12] ) >>> sprite_double[12] );
        tiles_12.wenable1 := 1;

        collision_12 := ( output_collisions ) ? detect_collision_12 : collision_12;

    // Default to transparent
    sprite_layer_display := 0;

    // Sprite details reader
    sprite_read_active := sprite_active[ sprite_set_number ];
    sprite_read_double := sprite_double[ sprite_set_number ];
    sprite_read_colour := sprite_colour[ sprite_set_number ];
    sprite_read_x := sprite_x[ sprite_set_number ];
    sprite_read_y := sprite_y[ sprite_set_number ];
    sprite_read_tile := sprite_tile_number[ sprite_set_number ];

    while(1) {
        // RENDER + COLLISION DETECTION
        if( pix_vblank ) {
            if( ~output_collisions ) {
                // RESET collision detection
                    detect_collision_0 = 0;
                    detect_collision_1 = 0;
                    detect_collision_2 = 0;
                    detect_collision_3 = 0;
                    detect_collision_4 = 0;
                    detect_collision_5 = 0;
                    detect_collision_6 = 0;
                    detect_collision_7 = 0;
                    detect_collision_8 = 0;
                    detect_collision_9 = 0;
                    detect_collision_10 = 0;
                    detect_collision_11 = 0;
                    detect_collision_12 = 0;
            } else {
                output_collisions = 0;
            }
        } else {
            if( pix_active ) {
                    if(  ( pix_visible_0 ) ) {
                        pix_red = sprite_colour[0][4,2];
                        pix_green = sprite_colour[0][2,2];
                        pix_blue = sprite_colour[0][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_0 = detect_collision_0 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_1 ) ) {
                        pix_red = sprite_colour[1][4,2];
                        pix_green = sprite_colour[1][2,2];
                        pix_blue = sprite_colour[1][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_1 = detect_collision_1 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_2 ) ) {
                        pix_red = sprite_colour[2][4,2];
                        pix_green = sprite_colour[2][2,2];
                        pix_blue = sprite_colour[2][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_2 = detect_collision_2 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_3 ) ) {
                        pix_red = sprite_colour[3][4,2];
                        pix_green = sprite_colour[3][2,2];
                        pix_blue = sprite_colour[3][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_3 = detect_collision_3 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_4 ) ) {
                        pix_red = sprite_colour[4][4,2];
                        pix_green = sprite_colour[4][2,2];
                        pix_blue = sprite_colour[4][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_4 = detect_collision_4 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_5 ) ) {
                        pix_red = sprite_colour[5][4,2];
                        pix_green = sprite_colour[5][2,2];
                        pix_blue = sprite_colour[5][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_5 = detect_collision_5 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_6 ) ) {
                        pix_red = sprite_colour[6][4,2];
                        pix_green = sprite_colour[6][2,2];
                        pix_blue = sprite_colour[6][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_6 = detect_collision_6 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_7 ) ) {
                        pix_red = sprite_colour[7][4,2];
                        pix_green = sprite_colour[7][2,2];
                        pix_blue = sprite_colour[7][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_7 = detect_collision_7 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_8 ) ) {
                        pix_red = sprite_colour[8][4,2];
                        pix_green = sprite_colour[8][2,2];
                        pix_blue = sprite_colour[8][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_8 = detect_collision_8 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_9 ) ) {
                        pix_red = sprite_colour[9][4,2];
                        pix_green = sprite_colour[9][2,2];
                        pix_blue = sprite_colour[9][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_9 = detect_collision_9 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_10 ) ) {
                        pix_red = sprite_colour[10][4,2];
                        pix_green = sprite_colour[10][2,2];
                        pix_blue = sprite_colour[10][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_10 = detect_collision_10 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_11 ) ) {
                        pix_red = sprite_colour[11][4,2];
                        pix_green = sprite_colour[11][2,2];
                        pix_blue = sprite_colour[11][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_11 = detect_collision_11 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }
                    if(  ( pix_visible_12 ) ) {
                        pix_red = sprite_colour[12][4,2];
                        pix_green = sprite_colour[12][2,2];
                        pix_blue = sprite_colour[12][0,2];

                        sprite_layer_display = 1;

                        // Perform collision detection
                        detect_collision_12 = detect_collision_12 | {
                            collision_layer_1, collision_layer_2, collision_layer_3, pix_visible_12, pix_visible_11,
                            pix_visible_10, pix_visible_9, pix_visible_8, pix_visible_7,
                            pix_visible_6, pix_visible_5, pix_visible_4, pix_visible_3,
                            pix_visible_2, pix_visible_1, pix_visible_0
                        };
                    }

                // Output collision detection
                output_collisions = ( pix_x == 639 ) && ( pix_y == 479 );
            }
        }

        // WRITE BITMAP TO SPRITE TILE
        if( sprite_writer_active ) {
            switch( sprite_writer_sprite ) {
                    case 0: {
                        tiles_0.addr1 = sprite_writer_line;
                        tiles_0.wdata1 = sprite_writer_bitmap;
                    }
                    case 1: {
                        tiles_1.addr1 = sprite_writer_line;
                        tiles_1.wdata1 = sprite_writer_bitmap;
                    }
                    case 2: {
                        tiles_2.addr1 = sprite_writer_line;
                        tiles_2.wdata1 = sprite_writer_bitmap;
                    }
                    case 3: {
                        tiles_3.addr1 = sprite_writer_line;
                        tiles_3.wdata1 = sprite_writer_bitmap;
                    }
                    case 4: {
                        tiles_4.addr1 = sprite_writer_line;
                        tiles_4.wdata1 = sprite_writer_bitmap;
                    }
                    case 5: {
                        tiles_5.addr1 = sprite_writer_line;
                        tiles_5.wdata1 = sprite_writer_bitmap;
                    }
                    case 6: {
                        tiles_6.addr1 = sprite_writer_line;
                        tiles_6.wdata1 = sprite_writer_bitmap;
                    }
                    case 7: {
                        tiles_7.addr1 = sprite_writer_line;
                        tiles_7.wdata1 = sprite_writer_bitmap;
                    }
                    case 8: {
                        tiles_8.addr1 = sprite_writer_line;
                        tiles_8.wdata1 = sprite_writer_bitmap;
                    }
                    case 9: {
                        tiles_9.addr1 = sprite_writer_line;
                        tiles_9.wdata1 = sprite_writer_bitmap;
                    }
                    case 10: {
                        tiles_10.addr1 = sprite_writer_line;
                        tiles_10.wdata1 = sprite_writer_bitmap;
                    }
                    case 11: {
                        tiles_11.addr1 = sprite_writer_line;
                        tiles_11.wdata1 = sprite_writer_bitmap;
                    }
                    case 12: {
                        tiles_12.addr1 = sprite_writer_line;
                        tiles_12.wdata1 = sprite_writer_bitmap;
                    }
            }
        }

        // SET ATTRIBUTES + PERFORM UPDATE
        switch( sprite_layer_write ) {
            case 1: { sprite_active[ sprite_set_number ] = sprite_set_active; }
            case 2: { sprite_tile_number[ sprite_set_number ] = sprite_set_tile; }
            case 3: { sprite_colour[ sprite_set_number ] = sprite_set_colour; }
            case 4: { sprite_x[ sprite_set_number ] = sprite_set_x; }
            case 5: { sprite_y[ sprite_set_number ] = sprite_set_y; }
            case 6: { sprite_double[ sprite_set_number ] = sprite_set_double; }
            case 10: {
                // Perform sprite update
                if( spriteupdate( sprite_update ).tile_act ) {
                    sprite_tile_number[ sprite_set_number ] = sprite_tile_number[ sprite_set_number ] + 1;
                }

                if( spriteupdate( sprite_update ).x_act || spriteupdate( sprite_update ).y_act) {
                    sprite_active[ sprite_set_number ] = ( sprite_offscreen_x || sprite_offscreen_y ) ? 0 : sprite_active[ sprite_set_number ];
                }

                sprite_x[ sprite_set_number ] = sprite_offscreen_x ? ( ( __signed( sprite_x[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ?__signed(640) : sprite_to_negative ) :
                                                sprite_x[ sprite_set_number ] + deltax;

                sprite_y[ sprite_set_number ] = sprite_offscreen_y ? ( ( __signed( sprite_y[ sprite_set_number ] ) < __signed( sprite_offscreen_negative ) ) ? __signed(480) : sprite_to_negative ) :
                                                sprite_y[ sprite_set_number ] + deltay;
            }
        }
    }
}

// Entry in the tilemap
bitfield tilemapentry {
    uint1   alpha,
    uint6   background,
    uint6   foreground,
    uint5   tilenumber
}

algorithm tilemap(
    input   uint10  pix_x,
    input   uint10  pix_y,
    input   uint1   pix_active,
    input   uint1   pix_vblank,
    output! uint2   pix_red,
    output! uint2   pix_green,
    output! uint2   pix_blue,
    output! uint1   tilemap_display,

    // Set TM at x, y, character with foreground and background
    input uint6 tm_x,
    input uint6 tm_y,
    input uint5 tm_character,
    input uint6 tm_foreground,
    input uint7 tm_background,
    input uint1 tm_write,

    // For setting tile bitmaps
    input   uint5   tile_writer_tile,
    input   uint4   tile_writer_line,
    input   uint16  tile_writer_bitmap,

    // For scrolling/wrapping
    input   uint4   tm_scrollwrap,
    output  uint4   tm_lastaction,
    output  uint2   tm_active
) <autorun> {
    // Tile Map 32 x 16 x 16
    simple_dualport_bram uint16 tiles16x16[ 512 ] = { 0, pad(0) };

    // 42 x 32 tile map, allows for pixel scrolling with border { 7 bits background, 6 bits foreground, 5 bits tile number }
    // Setting background to 40 (ALPHA) allows the bitmap/background to show through
    simple_dualport_bram uint18 tiles <input!> [1344] = { 18b100000000000000000, pad(18b100000000000000000) };
    simple_dualport_bram uint18 tiles_copy <input!> [1344] = { 18b100000000000000000, pad(18b100000000000000000) };

    // Scroll position - -15 to 0 to 15
    // -15 or 15 will trigger appropriate scroll when next moved in that direction
    int5    tm_offset_x = 0;
    int5    tm_offset_y = 0;

    // Scroller/Wrapper storage
    uint1   tm_scroll = uninitialized;
    uint1   tm_goleft = uninitialized;
    uint1   tm_goup = uninitialized;
    uint6   x_cursor = uninitialized;
    uint6   y_cursor = uninitialized;
    uint11  y_cursor_addr = uninitialized;
    uint18  new_tile = uninitialized;
    uint18  scroll_tile = uninitialized;

    // CS address
    uint11  tmcsaddr = uninitialized;

    // Character position on the screen x 0-41, y 0-31 * 42 ( fetch it two pixels ahead of the actual x pixel, so it is always ready )
    // Adjust for the offsets, effective 0 point margin is ( 1,1 ) to ( 40,30 ) with a 1 tile border
    uint11  xtmpos :=  ( pix_active ? pix_x + ( 11d18 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) : ( 11d16 + {{6{tm_offset_x[4,1]}}, tm_offset_x} ) ) >> 4;
    uint11  ytmpos := (( pix_vblank ? ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) : pix_y + ( 11d16 + {{6{tm_offset_y[4,1]}}, tm_offset_y} ) ) >> 4) * 42;

    // Derive the x and y coordinate within the current 16x16 tilemap block x 0-7, y 0-15
    // Needs adjusting for the offsets
    uint4   xintm := { 1b0, (pix_x) & 15 } + tm_offset_x;
    uint4   yintm := { 1b0, (pix_y) & 15 } + tm_offset_y;

    // Derive the actual pixel in the current character
    uint1   tmpixel := tiles16x16.rdata0[15 - xintm,1];

    // Set up reading of the tilemap
    tiles.addr0 := xtmpos + ytmpos;
    tiles.wenable1 := 1;
    tiles_copy.wenable1 := 1;

    // Setup the reading and writing of the tiles16x16
    tiles16x16.addr0 :=  tilemapentry(tiles.rdata0).tilenumber * 16 + yintm;
    tiles16x16.addr1 := tile_writer_tile * 16 + tile_writer_line;
    tiles16x16.wdata1 := tile_writer_bitmap;
    tiles16x16.wenable1 := 1;

    // RENDER - Default to transparent
    tilemap_display := pix_active && ( ( tmpixel ) || ( ~tilemapentry(tiles.rdata0).alpha ) );
    pix_red := tmpixel ? tiles.rdata0[9,2] : tiles.rdata0[15,2];
    pix_green := tmpixel ? tiles.rdata0[7,2] : tiles.rdata0[13,2];
    pix_blue := tmpixel ?  tiles.rdata0[5,2] : tiles.rdata0[11,2];

    // Default to 0,0 and transparent
    tiles.addr1 = 0; tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
    tiles_copy.addr1 = 0; tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };

    while(1) {
        // Write character to the tilemap
        if( tm_write == 1 ) {
            tiles.addr1 = tm_x + tm_y * 42;
            tiles.wdata1 = { tm_background, tm_foreground, tm_character };
            tiles_copy.addr1 = tm_x + tm_y * 42;
            tiles_copy.wdata1 = { tm_background, tm_foreground, tm_character };
        }

        switch( tm_active ) {
            case 0: {
                // Perform Scrolling/Wrapping
                switch( tm_scrollwrap ) {
                    // LEFT
                    case 1: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_goleft = 1;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 2: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_goup = 1;
                            tm_active = 2;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 3: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_goleft = 0;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 4: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 1;
                            tm_lastaction = tm_scrollwrap;
                            tm_goup = 0;
                            tm_active = 2;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }
                    // LEFT
                    case 5: {
                        if( tm_offset_x == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_goleft = 1;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // UP
                    case 6: {
                        if( tm_offset_y == 15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_goup = 1;
                            tm_active = 2;
                        } else {
                            tm_offset_y = tm_offset_y + 1;
                            tm_lastaction = 0;
                        }
                    }

                    // RIGHT
                    case 7: {
                        if( tm_offset_x == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_goleft = 0;
                            tm_active = 1;
                        } else {
                            tm_offset_x = tm_offset_x - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // DOWN
                    case 8: {
                        if( tm_offset_y == -15 ) {
                            tm_scroll = 0;
                            tm_lastaction = tm_scrollwrap;
                            tm_goup = 0;
                            tm_active = 2;
                        } else {
                            tm_offset_y = tm_offset_y - 1;
                            tm_lastaction = 0;
                        }
                    }

                    // CLEAR
                    case 9: {
                        tm_active = 3;
                        tm_lastaction = 9;
                    }
                }
            }

            // SCROLL/WRAP LEFT/RIGHT
            case 1: {
                y_cursor = 0;
                y_cursor_addr = 0;
                ++:
                while( y_cursor < 32 ) {
                    x_cursor = tm_goleft ? 0 : 41;
                    tiles_copy.addr0 = tm_goleft ? y_cursor_addr : 41 + y_cursor_addr;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( tm_goleft ? ( x_cursor < 42 ) : ( x_cursor > 0 ) ) {
                        tiles_copy.addr0 = tm_goleft ? ( x_cursor + 1 + y_cursor_addr ) : ( x_cursor - 1 + y_cursor_addr);
                        ++:
                        tiles.addr1 = x_cursor + y_cursor_addr;
                        tiles.wdata1 = tiles_copy.rdata0;
                        tiles_copy.addr1 = x_cursor + y_cursor_addr;
                        tiles_copy.wdata1 = tiles_copy.rdata0;
                        x_cursor = tm_goleft ? ( x_cursor + 1 ) : ( x_cursor - 1);
                    }
                    ++:
                    tiles.addr1 = tm_goleft ? ( 41 + y_cursor_addr ) : ( y_cursor_addr );
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = tm_goleft ? ( 41 + y_cursor_addr ) : ( y_cursor_addr );
                    tiles_copy.wdata1 = new_tile;
                    y_cursor = y_cursor + 1;
                    y_cursor_addr = y_cursor_addr + 42;
                }
                ++:
                tm_offset_x = 0;
                tm_active = 0;
            }

            // SCROLL/WRAP UP/DOWN
            case 2: {
                x_cursor = 0;
                ++:
                while( x_cursor < 42 ) {
                    y_cursor = tm_goup ? 0 : 31;
                    y_cursor_addr = tm_goup ? 0 : 1302;
                    tiles_copy.addr0 = x_cursor;
                    ++:
                    new_tile = ( tm_scroll == 1 ) ? { 1b1, 6b0, 6b0, 5b0 } : tiles_copy.rdata0;
                    ++:
                    while( tm_goup ? ( y_cursor < 31 ) : ( y_cursor > 0 ) ) {
                        tiles_copy.addr0 = tm_goup ? ( x_cursor + y_cursor_addr + 42 ) : ( x_cursor + y_cursor_addr - 42 );
                        ++:
                        tiles.addr1 = x_cursor + y_cursor_addr;
                        tiles.wdata1 = tiles_copy.rdata0;
                        tiles_copy.addr1 = x_cursor + y_cursor_addr;
                        tiles_copy.wdata1 = tiles_copy.rdata0;
                        y_cursor = tm_goup ? ( y_cursor + 1 ) : ( y_cursor - 1 );
                        y_cursor_addr = tm_goup ? ( y_cursor_addr + 42 ) : ( y_cursor_addr - 42 );
                    }
                    tiles.addr1 = tm_goup ? ( x_cursor + 1302 ) : ( x_cursor );
                    tiles.wdata1 = new_tile;
                    tiles_copy.addr1 = tm_goup ? ( x_cursor + 1302 ) : ( x_cursor );
                    tiles_copy.wdata1 = new_tile;
                    x_cursor = x_cursor + 1;
                }
                ++:
                tm_offset_y = 0;
                tm_active = 0;
            }

            // CLEAR
            case 3: {
                tmcsaddr = 0;
                ++:
                while( tmcsaddr < 1344 ) {
                    tiles.addr1 = tmcsaddr;
                    tiles.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                    tiles_copy.addr1 = tmcsaddr;
                    tiles_copy.wdata1 = { 1b1, 6b0, 6b0, 5b0 };
                    tmcsaddr = tmcsaddr + 1;
                }
                ++:

                tm_offset_x = 0;
                tm_offset_y = 0;
                tm_active = 0;
            }
        }
    }
}

// Runs at 25MHz, using the video clock
algorithm apu(
    // Waveform selected 0 = square, 1 = sawtooth, 2 = triangle, 3 = sine wave, 4 = noise
    input   uint4   waveform,
    // Note selected 0 = silence, 1 - x = Deep C through to Double High D (gives 64 distint notes)
    input   uint7   note,

    // Duration in ms, 1000 = 1 second,
    input   uint16  duration,
    output! uint1   audio_active,

    // Activate the APU (select the channel, 1, 2 or 3(?) )
    input   uint2   apu_write,

    output! uint4   audio_output,

    input uint16 staticGenerator
) <autorun> {
    // 32 step points per waveform
    brom uint4 waveformtable_1[512] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,

        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6

        ,pad(1)
    };
    brom uint4 waveformtable_2[512] = {
        // Square wave
        15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

        // Sawtooth wave
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
        8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,

        // Triangle wave,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0,

        // Sine wave,
        7, 8, 10, 11, 12, 13, 13, 14, 15, 14, 13, 13, 12, 11, 10, 8,
        7, 6, 4, 3, 2, 1, 1, 0, 0, 0, 1, 1, 2, 3, 4, 6

        ,pad(1)
    };

    // Calculated as 25MHz / note frequency / 32 to give 32 step points per note
    brom uint16 frequencytable_1[128] = {
        0,
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 1 = C 2 or Deep C
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 13 = C 3
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 25 = C 4 or Middle C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 37 = C 5 or Tenor C
        1493, 1409, 1330, 1256, 1185, 1119, 1056, 997, 941, 888, 838, 791,                      // 49 = C 6 or Soprano C
        747, 705, 665, pad(1024)                                                                // 61 = C 7 or Double High C
    };
    brom uint16 frequencytable_2[128] = {
        0,
        23889, 22548, 21283, 20088, 18961, 17897, 16892, 15944, 15049, 14205, 13407, 12655,     // 1 = C 2 or Deep C
        11945, 11274, 10641, 10044, 9480, 8948, 8446, 7972, 7525, 7102, 6704, 6327,             // 13 = C 3
        5972, 5637, 5321, 5022, 4740, 4474, 4223, 3986, 3762, 3551, 3352, 3164,                 // 25 = C 4 or Middle C
        2896, 2819, 2660, 2511, 2370, 2237, 2112, 1993, 1881, 1776, 1676, 1582,                 // 37 = C 5 or Tenor C
        1493, 1409, 1330, 1256, 1185, 1119, 1056, 997, 941, 888, 838, 791,                      // 49 = C 6 or Soprano C
        747, 705, 665, pad(1024)                                                                // 61 = C 7 or Double High C
    };

    uint3   waveform_1 = uninitialized;
    uint6   note_1 = uninitialized;
    uint5   point_1 = uninitialized;
    uint16  counter25mhz_1 = uninitialized;
    uint16  counter1khz_1 = uninitialized;
    uint16  milliseconds_1 = uninitialized;
    uint3   waveform_2 = uninitialized;
    uint6   note_2 = uninitialized;
    uint5   point_2 = uninitialized;
    uint16  counter25mhz_2 = uninitialized;
    uint16  counter1khz_2 = uninitialized;
    uint16  milliseconds_2 = uninitialized;

    uint16  duration_1 = uninitialized;
    uint16  duration_2 = uninitialized;

    waveformtable_1.addr := waveform_1 * 32 + point_1;
    waveformtable_2.addr := waveform_2 * 32 + point_2;
    frequencytable_1.addr := note_1;
    frequencytable_2.addr := note_2;

    audio_active := ( duration_1 > 0) || ( duration_2 > 0 );

    always {
        if( ( duration_1 != 0 ) && ( counter25mhz_1 == 0 ) ) {
            audio_output = ( waveform_1 == 4 ) ? staticGenerator : waveformtable_1.rdata;
        }
        if( ( duration_2 != 0 ) && ( counter25mhz_2 == 0 ) ) {
            audio_output = ( waveform_2 == 4 ) ? staticGenerator : waveformtable_2.rdata;
        }
    }

    while(1) {
        switch( apu_write) {
            case 1: {
                // Latch the selected note, waveform and duration
                waveform_1 = waveform;
                note_1 = note;
                duration_1 = duration;
                milliseconds_1 = 0;
                point_1 = 0;
                counter25mhz_1 = 0;
                counter1khz_1 = 25000;
            }
            case 2: {
                // Latch the selected note, waveform and duration
                waveform_2 = waveform;
                note_2 = note;
                duration_2 = duration;
                milliseconds_2 = 0;
                point_2 = 0;
                counter25mhz_2 = 0;
                counter1khz_2 = 25000;
            }
            default: {
                if( duration_1 != 0 ) {
                    counter25mhz_1 = ( counter25mhz_1 != 0 ) ? counter25mhz_1 - 1 : frequencytable_1.rdata;
                    point_1 = ( counter25mhz_1 != 0 ) ? point_1 : point_1 + 1;
                    counter1khz_1 = ( counter1khz_1 != 0 ) ? counter1khz_1 - 1 : 25000;
                    duration_1 = ( counter1khz_1 != 0 ) ? duration_1 : duration_1 - 1;
                }
                if( duration_2 != 0 ) {
                    counter25mhz_2 = ( counter25mhz_2 != 0 ) ? counter25mhz_2 - 1 : frequencytable_2.rdata;
                    point_2 = ( counter25mhz_2 != 0 ) ? point_2 : point_2 + 1;
                    counter1khz_2 = ( counter1khz_2 != 0 ) ? counter1khz_2 - 1 : 25000;
                    duration_2 = ( counter1khz_2 != 0 ) ? duration_2 : duration_2 - 1;
                }
            }
        }
   }
}

// Hardware Accelerated Mathematics For j1eforth

// UNSIGNED / SIGNED 32 by 16 bit division giving 16 bit remainder and quotient
// INPUT divisor from j1eforth is 16 bit expanded to 32 bit
// OUTPUT quotient and remainder are 16 bit

algorithm divmod32by16 (
    input   uint16  dividendh,
    input   uint16  dividendl,
    input   uint16  divisor,
    output  uint16  quotient,
    output  uint16  remainder,
    input   uint2   start,
    output  uint1   active
) <autorun> {
    uint32  dividend_copy = uninitialized;
    uint32  divisor_copy = uninitialized;
    uint32  quotient_copy = uninitialized;
    uint32  remainder_copy = uninitialized;
    uint1   resultsign = uninitialized;
    uint6   bit = uninitialized;

    while (1) {
        if( start != 0 ) {

            if( divisor == 0 ) {
                // DIVIDE BY 0
                quotient_copy = 32hffff;
                remainder_copy = divisor;
            } else {
                bit = 32;
                quotient_copy = 0;
                remainder_copy = 0;

                dividend_copy = ( start == 1 ) ? { dividendh, dividendl } : dividendh[15,1] ? -{ dividendh, dividendl } : { dividendh, dividendl };
                divisor_copy = ( start == 1 ) ? { 16b0, divisor } : divisor[15,1] ? { 16b0, -divisor } : { 16b0, divisor };
                resultsign = ( start == 1 ) ? 0 : dividendh[15,1] != divisor[15,1];

                active = 1;

                ++:

                while( bit != 0 ) {
                    if( __unsigned( { remainder_copy[0,31], dividend_copy[bit - 1,1] } ) >= __unsigned(divisor_copy) ) {
                        remainder_copy = { remainder_copy[0,31], dividend_copy[bit - 1,1] } - divisor_copy;
                        quotient_copy[bit - 1,1] = 1;
                    } else {
                        remainder_copy = { remainder_copy[0,31], dividend_copy[bit - 1,1] };
                    }
                    bit = bit - 1;
                }

                ++:

                quotient = resultsign ? -quotient_copy[0,16] : quotient_copy[0,16];
                remainder = remainder_copy[0,16];
                active = 0;

            }
        }

    }
}

// SIGNED 16 by 16 bit division giving 16 bit remainder and quotient

algorithm divmod16by16 (
    input   uint16  dividend,
    input   uint16  divisor,
    output  uint16  quotient,
    output  uint16  remainder,
    input   uint1   start,
    output  uint1   active
) <autorun> {
    uint16  dividend_copy = uninitialized;
    uint16  divisor_copy = uninitialized;
    uint16  quotient_copy = uninitialized;
    uint16  remainder_copy = uninitialized;
    uint1   resultsign = uninitialized;
    uint6   bit = uninitialized;

    while (1) {
        if( start ) {
            if( divisor != 0 ) {
                bit = 16;
                quotient_copy = 0;
                remainder_copy = 0;
                dividend_copy = dividend[15,1] ? -dividend : dividend;
                divisor_copy = divisor[15,1] ? -divisor : divisor;
                resultsign = dividend[15,1] != divisor[15,1];
                active = 1;

                ++:

                while( bit != 0 ) {
                    if( __unsigned( { remainder_copy[0,15], dividend_copy[bit - 1,1] } ) >= __unsigned(divisor_copy) ) {
                        remainder_copy = { remainder_copy[0,15], dividend_copy[bit - 1,1] } - divisor_copy;
                        quotient_copy[bit - 1,1] = 1;
                    } else {
                        remainder_copy = { remainder_copy[0,15], dividend_copy[bit - 1,1] };
                    }
                    bit = bit - 1;
                }

                ++:

                quotient = resultsign ? -quotient_copy : quotient_copy;
                remainder = remainder_copy;
                active = 0;
            } else {
                quotient_copy = 16hffff;
                remainder_copy = divisor;
            }
        }
    }
}

// UNSIGNED / SIGNED 16 by 16 bit multiplication giving 32 bit product
// DSP INFERENCE

algorithm multi16by16to32DSP (
    input   uint16  factor1,
    input   uint16  factor2,
    output  uint32  product,

    input   uint2   start,
    output  uint1   active
) <autorun> {
    uint18  factor1copy = uninitialized;
    uint18  factor2copy = uninitialized;

    uint32  nosignproduct = uninitialized;
    uint1   productsign = uninitialized;

    while(1) {
        if( start != 0 ) {
            switch( start ) {
                case 1: {
                    // UNSIGNED MULTIPLICATION
                    factor1copy = factor1;
                    factor2copy = factor2;
                    productsign = 0;
                }
                case 2: {
                    // SIGNED MULTIPLICATION
                    product = 0;
                    factor1copy = { 2b0, factor1[15,1] ? -factor1 : factor1 };
                    factor2copy = { 2b0, factor2[15,1] ? -factor2 : factor2 };
                    productsign = factor1[15,1] != factor2[15,1];
                }
            }
            product = 0;
            active = 1;

            ++:

            // PERFORM UNSIGNED MULTIPLICATION
            nosignproduct = factor1copy * factor2copy;

            ++:

            product = productsign ? -nosignproduct : nosignproduct;
            active = 0;
        }
    }
}

// Basic double arithmetic for j1eforth
// 2 input operations

algorithm doubleaddsub2input(
    input   uint16  operand1h,
    input   uint16  operand1l,
    input   uint16  operand2h,
    input   uint16  operand2l,

    output  uint32  total,
    output  uint32  difference,

    output  uint32  binaryxor,
    output  uint32  binaryor,
    output  uint32  binaryand,

    output  uint32  maximum,
    output  uint32  minimum,

    output  uint16  equal,
    output  uint16  lessthan
) <autorun> {
    uint32  operand1 := { operand1h, operand1l };
    uint32  operand2 := { operand2h, operand2l };

    total := operand1 + operand2;
    difference := operand1 - operand2;


    binaryxor := operand1 ^ operand2;
    binaryor := operand1 | operand2;
    binaryand := operand1 & operand2;

    maximum := ( operand1 > operand2 ) ? operand1 : operand2;
    minimum := ( operand1 < operand2 ) ? operand1 : operand2;

    equal := {16{(operand1 == operand2)}};
    lessthan := {16{(operand1 < operand2)}};

    while(1) {}
}

// 1 input operations

algorithm doubleaddsub1input(
    input   uint16  operand1h,
    input   uint16  operand1l,

    output  uint32  increment,
    output  uint32  decrement,

    output  uint32  times2,
    output  uint32  divide2,

    output  uint32  negation,

    output  uint32  binaryinvert,

    output  uint32  absolute,

    output  uint16  zeroequal,
    output  uint16  zeroless
) <autorun> {
    uint32  operand1 := { operand1h, operand1l };

    increment := operand1 + 1;
    decrement := operand1 - 1;

    times2 := operand1 << 1;
    divide2 := { operand1[31,1], operand1[1,31] };

    negation := -operand1;

    binaryinvert := ~operand1;

    absolute := ( operand1[31,1] ) ? -operand1 : operand1;

    zeroequal := {16{(operand1 == 0)}};
    zeroless := {16{(operand1 < 0)}};

    while(1) {}
}

// 7 bit colour either ALPHA (background or lower layer) or red, green, blue { Arrggbb }
bitfield colour7 {
    uint1   alpha,
    uint2   red,
    uint2   green,
    uint2   blue
}

// 6 bit colour red, green, blue { rrggbb }
bitfield colour6 {
    uint2   red,
    uint2   green,
    uint2   blue
}

// Simplify access to high/low word
bitfield words {
    uint16  hword,
    uint16  lword
}

// Simplify access to high/low byte
bitfield bytes {
    uint8   byte1,
    uint8   byte0
}

// Simplify access to 4bit nibbles (used to extract shift left/right amount)
bitfield nibbles {
    uint4   nibble3,
    uint4   nibble2,
    uint4   nibble1,
    uint4   nibble0
}

algorithm memmap_io (
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r,

    // VGA/HDMI
    output! uint8   video_r,
    output! uint8   video_g,
    output! uint8   video_b,
    input   uint1   vblank,
    input   uint1   pix_active,
    input   uint10  pix_x,
    input   uint10  pix_y,

    // CLOCKS
    input   uint1   clock_50mhz,
    input   uint1   clock_25mhz,
    input   uint1   video_clock,
    input   uint1   video_reset,

    // Memory access
    input   uint16  memoryAddress,
    input   uint16  writeData,
    input   uint1   memoryWrite,
    input   uint1   memoryRead,
    output! uint16  readData
) <autorun> {
    // 1hz timers (p1hz used for systemClock, timer1hz for user purposes)
    uint16 systemClock = uninitialized;
    pulse1hz p1hz <@clock_50mhz,!reset> (
        counter1hz :> systemClock,
    );
    pulse1hz timer1hz <@clock_50mhz,!reset> ( );

    // 1khz timers (sleepTimer used for sleep command, timer1khz for user purposes)
    pulse1khz sleepTimer <@clock_50mhz,!reset> ( );
    pulse1khz timer1khz <@clock_50mhz,!reset> ( );

    // RNG random number generator
    uint16 staticGenerator = 0;
    random rng <@clock_50mhz,!reset> (
        g_noise_out :> staticGenerator
    );

    // UART tx and rx
    // UART written in Silice by https://github.com/sylefeb/Silice
    uart_out uo;
    uart_sender usend <@clock_50mhz,!reset> (
        io      <:> uo,
        uart_tx :>  uart_tx
    );
    uart_in ui;
    uart_receiver urecv <@clock_50mhz,!reset> (
        io      <:> ui,
        uart_rx <:  uart_rx
    );

    // CREATE DISPLAY LAYERS
    // BACKGROUND
    uint2   background_r = uninitialized;
    uint2   background_g = uninitialized;
    uint2   background_b = uninitialized;
    background background_generator <@video_clock,!video_reset>  (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> background_r,
        pix_green  :> background_g,
        pix_blue   :> background_b,
        staticGenerator <: staticGenerator
    );

    // TILEMAP
    uint2   tilemap_r = uninitialized;
    uint2   tilemap_g = uninitialized;
    uint2   tilemap_b = uninitialized;
    uint1   tilemap_display = uninitialized;

    tilemap tile_map <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> tilemap_r,
        pix_green  :> tilemap_g,
        pix_blue   :> tilemap_b,
        tilemap_display :> tilemap_display,
    );

    // Bitmap Window
    uint2   bitmap_r = uninitialized;
    uint2   bitmap_g = uninitialized;
    uint2   bitmap_b = uninitialized;
    uint10  x_offset = uninitialized;
    uint10  y_offset = uninitialized;
    // From GPU to set a pixel
    uint1   bitmap_display = uninitialized;
    int11   bitmap_x_write = uninitialized;
    int11   bitmap_y_write = uninitialized;
    uint7   bitmap_colour_write = uninitialized;
    uint1   bitmap_write = uninitialized;

    // 640 x 480 x 7 bit { Arrggbb } colour bitmap
    simple_dualport_bram uint7 bitmap <@video_clock,@video_clock,input!> [ 307200 ] = uninitialized;
    bitmap bitmap_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> bitmap_r,
        pix_green  :> bitmap_g,
        pix_blue   :> bitmap_b,
        bitmap_display :> bitmap_display,
        x_offset :> x_offset,
        y_offset :> y_offset,
        bitmap <:> bitmap
    );
    bitmapwriter pixel_writer <@video_clock> (
        bitmap_x_write <: bitmap_x_write,
        bitmap_y_write <: bitmap_y_write,
        bitmap_colour_write <: bitmap_colour_write,
        bitmap_write <: bitmap_write,
        x_offset <: x_offset,
        y_offset <: y_offset,
        bitmap <:> bitmap
    );

    // Lower Sprite Layer - Between BACKGROUND and BITMAP
    // Upper Sprite Layer - Between BITMAP and CHARACTER MAP
    uint2   lower_sprites_r = uninitialized;
    uint2   lower_sprites_g = uninitialized;
    uint2   lower_sprites_b = uninitialized;
    uint1   lower_sprites_display = uninitialized;
    uint2   upper_sprites_r = uninitialized;
    uint2   upper_sprites_g = uninitialized;
    uint2   upper_sprites_b = uninitialized;
    uint1   upper_sprites_display = uninitialized;

    sprite_layer lower_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> lower_sprites_r,
        pix_green  :> lower_sprites_g,
        pix_blue   :> lower_sprites_b,
        sprite_layer_display :> lower_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: upper_sprites_display
    );

    sprite_layer upper_sprites <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> upper_sprites_r,
        pix_green  :> upper_sprites_g,
        pix_blue   :> upper_sprites_b,
        sprite_layer_display :> upper_sprites_display,
        collision_layer_1 <: bitmap_display,
        collision_layer_2 <: tilemap_display,
        collision_layer_3 <: lower_sprites_display
    );

    // Character Map Window
    uint2   character_map_r = uninitialized;
    uint2   character_map_g = uninitialized;
    uint2   character_map_b = uninitialized;
    uint1   character_map_display = uninitialized;

    character_map character_map_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> character_map_r,
        pix_green  :> character_map_g,
        pix_blue   :> character_map_b,
        character_map_display :> character_map_display
    );

    // Terminal window at the bottom of the screen
    uint2   terminal_r = uninitialized;
    uint2   terminal_g = uninitialized;
    uint2   terminal_b = uninitialized;
    uint1   terminal_display = uninitialized;

    terminal terminal_window <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> terminal_r,
        pix_green  :> terminal_g,
        pix_blue   :> terminal_b,
        terminal_display :> terminal_display,
        timer1hz   <: systemClock
    );

    // Combine the display layers for display
    multiplex_display display <@video_clock,!video_reset> (
        pix_x      <: pix_x,
        pix_y      <: pix_y,
        pix_active <: pix_active,
        pix_vblank <: vblank,
        pix_red    :> video_r,
        pix_green  :> video_g,
        pix_blue   :> video_b,

        background_r <: background_r,
        background_g <: background_g,
        background_b <: background_b,

        tilemap_r <: tilemap_r,
        tilemap_g <: tilemap_g,
        tilemap_b <: tilemap_b,
        tilemap_display <: tilemap_display,

        lower_sprites_r <: lower_sprites_r,
        lower_sprites_g <: lower_sprites_g,
        lower_sprites_b <: lower_sprites_b,
        lower_sprites_display <: lower_sprites_display,

        bitmap_r <: bitmap_r,
        bitmap_g <: bitmap_g,
        bitmap_b <: bitmap_b,
        bitmap_display <: bitmap_display,

        upper_sprites_r <: upper_sprites_r,
        upper_sprites_g <: upper_sprites_g,
        upper_sprites_b <: upper_sprites_b,
        upper_sprites_display <: upper_sprites_display,

        character_map_r <: character_map_r,
        character_map_g <: character_map_g,
        character_map_b <: character_map_b,
        character_map_display <: character_map_display,

        terminal_r <: terminal_r,
        terminal_g <: terminal_g,
        terminal_b <: terminal_b,
        terminal_display <: terminal_display
    );

    // Left and Right audio channels
    // Sync'd with video_clock
    apu apu_processor_L
<@clock_25mhz,!reset>
    (
        staticGenerator <: staticGenerator,
        audio_output :> audio_l
    );
    apu apu_processor_R
<@clock_25mhz,!reset>
    (
        staticGenerator <: staticGenerator,
        audio_output :> audio_r
    );

    gpu gpu_processor <@video_clock,!video_reset> (
        bitmap_x_write :> bitmap_x_write,
        bitmap_y_write :> bitmap_y_write,
        bitmap_colour_write :> bitmap_colour_write,
        bitmap_write :> bitmap_write,
    );

    // Mathematics Co-Processors
    divmod32by16 divmod32by16to16qr <@clock_50mhz,!reset> ();
    divmod16by16 divmod16by16to16qr <@clock_50mhz,!reset> ();
    multi16by16to32DSP multiplier16by16to32 <@clock_50mhz,!reset> ();
    doubleaddsub2input doperations2 <@clock_50mhz,!reset> ();
    doubleaddsub1input doperations1 <@clock_50mhz,!reset> ();

    // UART input FIFO (4096 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartInBuffer[4096] = uninitialized;
    uint13  uartInBufferNext = 0;
    uint13  uartInBufferTop = 0;

    // UART output FIFO (16 character) as dualport bram (code from @sylefeb)
    simple_dualport_bram uint8 uartOutBuffer[256] = uninitialized;
    uint8   uartOutBufferNext = 0;
    uint8   uartOutBufferTop = 0;
    uint8   newuartOutBufferTop = 0;

    // Co-Processor reset counter
    uint2   coProReset = 0;

    // register buttons
    uint7 reg_btns = 0;
    reg_btns ::= btns;

    // UART Buffers
    uartInBuffer.wenable1  := 1;  // always write on port 1
    uartInBuffer.addr0     := uartInBufferNext; // FIFO reads on next
    uartInBuffer.addr1     := uartInBufferTop;  // FIFO writes on top

    uartOutBuffer.wenable1 := 1; // always write on port 1
    uartOutBuffer.addr0    := uartOutBufferNext; // FIFO reads on next
    uartOutBuffer.addr1    := uartOutBufferTop;  // FIFO writes on top

    // Setup the UART
    uo.data_in_ready := 0; // maintain low

    // RESET Mathematics Co-Processor Controls
    divmod32by16to16qr.start := 0;
    divmod16by16to16qr.start := 0;
    multiplier16by16to32.start := 0;

    // RESET Timer Co-Processor Controls
    p1hz.resetCounter := 0;
    sleepTimer.resetCounter := 0;
    timer1hz.resetCounter := 0;
    timer1khz.resetCounter := 0;
    rng.resetRandom := 0;

    // UART input and output buffering
    uartInBuffer.wdata1  := ui.data_out;
    uartInBufferTop      := ( ui.data_out_ready ) ? uartInBufferTop + 1 : uartInBufferTop;
    uo.data_in      := uartOutBuffer.rdata0;
    uo.data_in_ready     := (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy );
    uartOutBufferNext := ( (uartOutBufferNext != uartOutBufferTop) && ( !uo.busy ) ) ? uartOutBufferNext + 1 : uartOutBufferNext;

    // Setup the terminal
    terminal_window.showterminal = 1;

    while(1) {
        // Update UART output buffer top if character has been put into buffer
        uartOutBufferTop = newuartOutBufferTop;

        // READ IO Memory
        if( memoryRead ) {
            switch( memoryAddress[12,4] ) {
                case 4hf: {
                    switch( memoryAddress[8,4] ) {
                        case 4h0: {
                            switch( memoryAddress[0,4] ) {
                                // f000
                                case 4h0: { readData = { 8b0, uartInBuffer.rdata0 }; uartInBufferNext = uartInBufferNext + 1; }
                                case 4h1: { readData = { 14b0, ( uartOutBufferTop + 1 == uartOutBufferNext ), ( uartInBufferNext != uartInBufferTop )}; }
                                case 4h2: { readData = leds; }
                                case 4h3: { readData = {9b0, reg_btns[0,7]}; }
                                case 4h4: { readData = systemClock; }
                            }
                        }
                        case 4hf: {
                            switch( memoryAddress[4,4] ) {
                                case 4h0: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff00 -
                                        case 4h7: { readData = gpu_processor.gpu_active; }
                                        case 4h8: { readData = bitmap_window.bitmap_colour_read; }
                                    }
                                }
                                case 4h1: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff10 -
                                        case 4h5: { readData = character_map_window.tpu_active; }
                                    }
                                }
                                case 4h2: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff20 -
                                        case 4h0: { readData = terminal_window.terminal_active; }
                                    }
                                }
                                case 4h3: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff30 -
                                        case 4h1: { readData = lower_sprites.sprite_read_active; }
                                        case 4h2: { readData = lower_sprites.sprite_read_tile; }
                                        case 4h3: { readData = lower_sprites.sprite_read_colour; }
                                        case 4h4: { readData = lower_sprites.sprite_read_x; }
                                        case 4h5: { readData = lower_sprites.sprite_read_y; }
                                        case 4h6: { readData = lower_sprites.sprite_read_double; }
                                    }
                                }
                                case 4h4: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff40 -
                                        case 4h1: { readData = upper_sprites.sprite_read_active; }
                                        case 4h2: { readData = upper_sprites.sprite_read_tile; }
                                        case 4h3: { readData = upper_sprites.sprite_read_colour; }
                                        case 4h4: { readData = upper_sprites.sprite_read_x; }
                                        case 4h5: { readData = upper_sprites.sprite_read_y; }
                                        case 4h6: { readData = upper_sprites.sprite_read_double; }
                                    }
                                }
                                case 4h5: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff50 -
                                        case 4h0: { readData = lower_sprites.collision_0; }
                                        case 4h1: { readData = lower_sprites.collision_1; }
                                        case 4h2: { readData = lower_sprites.collision_2; }
                                        case 4h3: { readData = lower_sprites.collision_3; }
                                        case 4h4: { readData = lower_sprites.collision_4; }
                                        case 4h5: { readData = lower_sprites.collision_5; }
                                        case 4h6: { readData = lower_sprites.collision_6; }
                                        case 4h7: { readData = lower_sprites.collision_7; }
                                        case 4h8: { readData = lower_sprites.collision_8; }
                                        case 4h9: { readData = lower_sprites.collision_9; }
                                        case 4ha: { readData = lower_sprites.collision_10; }
                                        case 4hb: { readData = lower_sprites.collision_11; }
                                        case 4hc: { readData = lower_sprites.collision_12; }
                                    }
                                }
                                case 4h6: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff60 -
                                        case 4h0: { readData = upper_sprites.collision_0; }
                                        case 4h1: { readData = upper_sprites.collision_1; }
                                        case 4h2: { readData = upper_sprites.collision_2; }
                                        case 4h3: { readData = upper_sprites.collision_3; }
                                        case 4h4: { readData = upper_sprites.collision_4; }
                                        case 4h5: { readData = upper_sprites.collision_5; }
                                        case 4h6: { readData = upper_sprites.collision_6; }
                                        case 4h7: { readData = upper_sprites.collision_7; }
                                        case 4h8: { readData = upper_sprites.collision_8; }
                                        case 4h9: { readData = upper_sprites.collision_9; }
                                        case 4ha: { readData = upper_sprites.collision_10; }
                                        case 4hb: { readData = upper_sprites.collision_11; }
                                        case 4hc: { readData = upper_sprites.collision_12; }
                                    }
                                }
                                case 4h7: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff70 -
                                        case 4h4: { readData = gpu_processor.vector_block_active; }
                                    }
                                }

                                case 4h9: {
                                    switch( memoryAddress[0,4] ) {
                                        // ff90 -
                                        case 4h9: { readData = tile_map.tm_lastaction; }
                                        case 4ha: { readData = tile_map.tm_active; }
                                    }
                                }
                                case 4ha: {
                                    switch( memoryAddress[0,4] ) {
                                        case 4h0: { readData = words(doperations2.total).hword; }
                                        case 4h1: { readData = words(doperations2.total).lword; }
                                        case 4h2: { readData = words(doperations2.difference).hword; }
                                        case 4h3: { readData = words(doperations2.difference).lword; }
                                        case 4h4: { readData = words(doperations1.increment).hword; }
                                        case 4h5: { readData = words(doperations1.increment).lword; }
                                        case 4h6: { readData = words(doperations1.decrement).hword; }
                                        case 4h7: { readData = words(doperations1.decrement).lword; }
                                        case 4h8: { readData = words(doperations1.times2).hword; }
                                        case 4h9: { readData = words(doperations1.times2).lword; }
                                        case 4ha: { readData = words(doperations1.divide2).hword; }
                                        case 4hb: { readData = words(doperations1.divide2).lword; }
                                        case 4hc: { readData = words(doperations1.negation).hword; }
                                        case 4hd: { readData = words(doperations1.negation).lword; }
                                        case 4he: { readData = words(doperations1.binaryinvert).hword; }
                                        case 4hf: { readData = words(doperations1.binaryinvert).lword; }
                                    }
                                }
                                case 4hb: {
                                    switch( memoryAddress[0,4] ) {
                                        case 4h0: { readData = words(doperations2.binaryxor).hword; }
                                        case 4h1: { readData = words(doperations2.binaryxor).lword; }
                                        case 4h2: { readData = words(doperations2.binaryand).hword; }
                                        case 4h3: { readData = words(doperations2.binaryand).lword; }
                                        case 4h4: { readData = words(doperations2.binaryor).hword; }
                                        case 4h5: { readData = words(doperations2.binaryor).lword; }
                                        case 4h6: { readData = words(doperations1.absolute).hword; }
                                        case 4h7: { readData = words(doperations1.absolute).lword; }
                                        case 4h8: { readData = words(doperations2.maximum).hword; }
                                        case 4h9: { readData = words(doperations2.maximum).lword; }
                                        case 4ha: { readData = words(doperations2.minimum).hword; }
                                        case 4hb: { readData = words(doperations2.minimum).lword; }
                                        case 4hc: { readData = doperations1.zeroequal; }
                                        case 4hd: { readData = doperations1.zeroless; }
                                        case 4he: { readData = doperations2.equal; }
                                        case 4hf: { readData = doperations2.lessthan; }
                                    }
                                }
                                case 4hd: {
                                    switch( memoryAddress[0,4] ) {
                                        case 4h0: { readData = divmod32by16to16qr.quotient[0,16]; }
                                        case 4h1: { readData = divmod32by16to16qr.remainder[0,16]; }
                                        case 4h3: { readData = divmod32by16to16qr.active; }
                                        case 4h4: { readData = divmod16by16to16qr.quotient; }
                                        case 4h5: { readData = divmod16by16to16qr.remainder; }
                                        case 4h6: { readData = divmod16by16to16qr.active; }
                                        case 4h7: { readData = multiplier16by16to32.product[16,16]; }
                                        case 4h8: { readData = multiplier16by16to32.product[0,16]; }
                                        case 4h9: { readData = multiplier16by16to32.active; }
                                    }
                                }
                                case 4he: {
                                    switch( memoryAddress[0,4] ) {
                                        // ffe0 -
                                        case 4h0: { readData = staticGenerator; }
                                        case 4h3: { readData = apu_processor_L.audio_active; }
                                        case 4h7: { readData = apu_processor_R.audio_active; }
                                        case 4hd: { readData = timer1hz.counter1hz; }
                                        case 4he: { readData = timer1khz.counter1khz; }
                                        case 4hf: { readData = sleepTimer.counter1khz; }
                                    }
                                }
                                case 4hf: {
                                    switch( memoryAddress[0,4] ) {
                                        // fff0 -
                                        case 4hf: { readData = vblank; }
                                    }
                                }
                            }
                        }
                    }
                }
            } // READ IO Memory
        } // memoryRead

        // WRITE IO Memory
        if( memoryWrite ) {
            coProReset = 3;

            switch( memoryAddress[12,4] ) {
                case 4hf: {
                    switch( memoryAddress[8,4] ) {
                        case 4h0: {
                            switch( memoryAddress[0,4] ) {
                                // f000 -
                                case 4h0: { uartOutBuffer.wdata1 = writeData[0,8]; newuartOutBufferTop = uartOutBufferTop + 1; }
                                case 4h2: { leds = writeData; }
                            }
                        }
                        case 4hf: {
                            switch( memoryAddress[0,8] ) {
                                // ff00 -
                                case 8h00: { gpu_processor.gpu_x = writeData; }
                                case 8h01: { gpu_processor.gpu_y = writeData; }
                                case 8h02: { gpu_processor.gpu_colour = writeData; }
                                case 8h03: { gpu_processor.gpu_param0 = writeData; }
                                case 8h04: { gpu_processor.gpu_param1 = writeData; }
                                case 8h05: { gpu_processor.gpu_param2 = writeData; }
                                case 8h06: { gpu_processor.gpu_param3 = writeData; }
                                case 8h07: { gpu_processor.gpu_write = writeData; }
                                case 8h08: { bitmap_window.bitmap_write_offset = writeData; }
                                case 8h09: { bitmap_window.bitmap_x_read = writeData; }
                                case 8h0a: { bitmap_window.bitmap_y_read = writeData; }
                                case 8h0b: { gpu_processor.blit1_writer_tile = writeData; }
                                case 8h0c: { gpu_processor.blit1_writer_line = writeData; }
                                case 8h0d: { gpu_processor.blit1_writer_bitmap = writeData; }

                                // ff10 -
                                case 8h10: { character_map_window.tpu_x = writeData; }
                                case 8h11: { character_map_window.tpu_y = writeData; }
                                case 8h12: { character_map_window.tpu_character = writeData; }
                                case 8h13: { character_map_window.tpu_background = writeData; }
                                case 8h14: { character_map_window.tpu_foreground = writeData; }
                                case 8h15: { character_map_window.tpu_write = writeData; }

                                // ff20 -
                                case 8h20: { terminal_window.terminal_character = writeData; terminal_window.terminal_write = 1; }
                                case 8h21: { terminal_window.showterminal = writeData; }

                                // ff30 -
                                case 8h30: { lower_sprites.sprite_set_number = writeData; }
                                case 8h31: { lower_sprites.sprite_set_active = writeData; lower_sprites.sprite_layer_write = 1; }
                                case 8h32: { lower_sprites.sprite_set_tile = writeData; lower_sprites.sprite_layer_write = 2; }
                                case 8h33: { lower_sprites.sprite_set_colour = writeData; lower_sprites.sprite_layer_write = 3; }
                                case 8h34: { lower_sprites.sprite_set_x = writeData; lower_sprites.sprite_layer_write = 4; }
                                case 8h35: { lower_sprites.sprite_set_y = writeData; lower_sprites.sprite_layer_write = 5; }
                                case 8h36: { lower_sprites.sprite_set_double = writeData; lower_sprites.sprite_layer_write = 6; }
                                case 8h38: { lower_sprites.sprite_writer_sprite = writeData; }
                                case 8h39: { lower_sprites.sprite_writer_line = writeData; }
                                case 8h3a: { lower_sprites.sprite_writer_bitmap = writeData; lower_sprites.sprite_writer_active = 1; }
                                case 8h3e: { lower_sprites.sprite_update = writeData; lower_sprites.sprite_layer_write = 10; }

                                // ff40 -
                                case 8h40: { upper_sprites.sprite_set_number = writeData; }
                                case 8h41: { upper_sprites.sprite_set_active = writeData; upper_sprites.sprite_layer_write = 1; }
                                case 8h42: { upper_sprites.sprite_set_tile = writeData; upper_sprites.sprite_layer_write = 2; }
                                case 8h43: { upper_sprites.sprite_set_colour = writeData; upper_sprites.sprite_layer_write = 3; }
                                case 8h44: { upper_sprites.sprite_set_x = writeData; upper_sprites.sprite_layer_write = 4; }
                                case 8h45: { upper_sprites.sprite_set_y = writeData; upper_sprites.sprite_layer_write = 5; }
                                case 8h46: { upper_sprites.sprite_set_double = writeData; upper_sprites.sprite_layer_write = 6; }
                                case 8h48: { upper_sprites.sprite_writer_sprite = writeData; }
                                case 8h49: { upper_sprites.sprite_writer_line = writeData; }
                                case 8h4a: { upper_sprites.sprite_writer_bitmap = writeData; upper_sprites.sprite_writer_active = 1; }
                                case 8h4e: { upper_sprites.sprite_update = writeData; upper_sprites.sprite_layer_write = 10; }

                                // ff70 -
                                case 8h70: { gpu_processor.vector_block_number = writeData; }
                                case 8h71: { gpu_processor.vector_block_colour = writeData; }
                                case 8h72: { gpu_processor.vector_block_xc = writeData; }
                                case 8h73: { gpu_processor.vector_block_yc = writeData; }
                                case 8h74: { gpu_processor.draw_vector = 1; }
                                case 8h75: { gpu_processor.vertices_writer_block = writeData; }
                                case 8h76: { gpu_processor.vertices_writer_vertex = writeData; }
                                case 8h77: { gpu_processor.vertices_writer_xdelta = writeData; }
                                case 8h78: { gpu_processor.vertices_writer_ydelta = writeData; }
                                case 8h79: { gpu_processor.vertices_writer_active = writeData; }

                                // ff90 -
                                case 8h90: { tile_map.tm_x = writeData; }
                                case 8h91: { tile_map.tm_y = writeData; }
                                case 8h92: { tile_map.tm_character = writeData; }
                                case 8h93: { tile_map.tm_background = writeData; }
                                case 8h94: { tile_map.tm_foreground = writeData; }
                                case 8h95: { tile_map.tm_write = 1; }
                                case 8h96: { tile_map.tile_writer_tile = writeData; }
                                case 8h97: { tile_map.tile_writer_line = writeData; }
                                case 8h98: { tile_map.tile_writer_bitmap = writeData; }
                                case 8h99: { tile_map.tm_scrollwrap = writeData; }

                                // ffa0 -
                                case 8ha0: { doperations2.operand1h = writeData; doperations1.operand1h = writeData; }
                                case 8ha1: { doperations2.operand1l = writeData; doperations1.operand1l = writeData; }
                                case 8ha2: { doperations2.operand2h = writeData; }
                                case 8ha3: { doperations2.operand2l = writeData; }

                                // ffd0 -
                                case 8hd0: { divmod32by16to16qr.dividendh = writeData; }
                                case 8hd1: { divmod32by16to16qr.dividendl = writeData; }
                                case 8hd2: { divmod32by16to16qr.divisor = writeData; }
                                case 8hd3: { divmod32by16to16qr.start = writeData; }
                                case 8hd4: { divmod16by16to16qr.dividend = writeData; }
                                case 8hd5: { divmod16by16to16qr.divisor = writeData; }
                                case 8hd6: { divmod16by16to16qr.start = writeData; }
                                case 8hd7: { multiplier16by16to32.factor1 = writeData; }
                                case 8hd8: { multiplier16by16to32.factor2 = writeData; }
                                case 8hd9: { multiplier16by16to32.start = writeData; }

                                // ffe0 -
                                case 8he0: { apu_processor_L.waveform = writeData; }
                                case 8he1: { apu_processor_L.note = writeData; }
                                case 8he2: { apu_processor_L.duration = writeData; }
                                case 8he3: { apu_processor_L.apu_write = writeData; }
                                case 8he4: { apu_processor_R.waveform = writeData; }
                                case 8he5: { apu_processor_R.note = writeData; }
                                case 8he6: { apu_processor_R.duration = writeData; }
                                case 8he7: { apu_processor_R.apu_write = writeData; }
                                case 8he8: { rng.resetRandom = 1; }
                                case 8hed: { timer1hz.resetCounter = 1; }
                                case 8hee: { timer1khz.resetCount = writeData; timer1khz.resetCounter = 1; }
                                case 8hef: { sleepTimer.resetCount = writeData; sleepTimer.resetCounter = 1; }

                                // fff0 -
                                case 8hf0: { background_generator.backgroundcolour = writeData; background_generator.background_write = 1; }
                                case 8hf1: { background_generator.backgroundcolour_alt = writeData; background_generator.background_write = 2; }
                                case 8hf2: { background_generator.backgroundcolour_mode = writeData; background_generator.background_write = 3; }
                            }
                        }
                    }
                }
            }
        } else { // WRITE IO Memory
            coProReset = ( coProReset == 0 ) ? 0 : coProReset - 1;
        }

        // RESET Co-Processor Controls
        // Main processor and memory map runs at 50MHz, display co-processors at 25MHz
        // Delay to reset co-processors therefore required
        if( coProReset == 1 ) {
            background_generator.background_write = 0;
            tile_map.tm_write = 0;
            tile_map.tm_scrollwrap = 0;
            lower_sprites.sprite_layer_write = 0;
            lower_sprites.sprite_writer_active = 0;
            bitmap_window.bitmap_write_offset = 0;
            gpu_processor.gpu_write = 0;
            gpu_processor.draw_vector = 0;
            upper_sprites.sprite_layer_write = 0;
            upper_sprites.sprite_writer_active = 0;
            character_map_window.tpu_write = 0;
            terminal_window.terminal_write = 0;
            apu_processor_L.apu_write = 0;
            apu_processor_R.apu_write = 0;
        }
    } // while(1)
}


import('../common/ulx3s_clk_50_25.v')
import('../common/reset_conditioner.v')

// BITFIELDS to help with bit/field access

// Instruction is 3 bits 1xx = literal value, 000 = branch, 001 = 0branch, 010 = call, 011 = alu, followed by 13 bits of instruction specific data
bitfield instruction {
    uint3   is_litcallbranchalu,
    uint13   padding
}

// A literal instruction is 1 followed by a 15 bit UNSIGNED literal value
bitfield literal {
    uint1   is_literal,
    uint15  literalvalue
}

// A branch, 0branch or call instruction is 0 followed by 00 = branch, 01 = 0branch, 10 = call followed by 13bit target address
bitfield callbranch {
    uint1   is_literal,
    uint2   is_callbranchalu,
    uint13  address
}
// An alu instruction is 0 (not literal) followed by 11 = alu
bitfield aluop {
    uint1   is_literal,
    uint2   is_callbranchalu,
    uint1   is_r2pc,                // return from subroutine
    uint4   operation,              // arithmetic / memory read/write operation to perform
    uint1   is_t2n,                 // top to next in stack
    uint1   is_t2r,                 // top to return stack
    uint1   is_n2memt,              // write to memory
    uint1   is_j1j1plus,            // Original J1 or extra J1+ alu operations
    uint1   rdelta1,                // two's complement adjustment for rsp
    uint1   rdelta0,
    uint1   ddelta1,                // two's complement adjustment for dsp
    uint1   ddelta0
}

algorithm main(
    // LEDS (8 of)
    output  uint8   leds,
    input   uint7 btns,

    output  uint4   gpdi_dp,
    output  uint4   gpdi_dn,

    // UART
    output! uint1   uart_tx,
    input   uint1   uart_rx,

    // AUDIO
    output! uint4   audio_l,
    output! uint4   audio_r

)
<@clock_50mhz>
{
    // VGA/HDMI Display
    uint1   video_reset = uninitialized;
    uint1   video_clock = uninitialized;
    uint1   pll_lock = uninitialized;

    // Generate the 100MHz SDRAM and 25MHz VIDEO clocks
    uint1 clock_50mhz = uninitialized;
    ulx3s_clk_50_25 clk_gen (
        clkin    <: clock,
        clkout0  :> clock_50mhz,
        clkout1  :> video_clock,
        locked   :> pll_lock
    );

    // Video Reset
    reset_conditioner vga_rstcond (
        rcclk <: video_clock ,
        in  <: reset,
        out :> video_reset
    );

    // Status of the screen, if in range, if in vblank, actual pixel x and y
    uint1   vblank = uninitialized;
    uint1   pix_active = uninitialized;
    uint10  pix_x  = uninitialized;
    uint10  pix_y  = uninitialized;

    // VGA or HDMI driver

    uint8   video_r = uninitialized;
    uint8   video_g = uninitialized;
    uint8   video_b = uninitialized;

    hdmi video<@clock,!reset> (
        vblank  :> vblank,
        active  :> pix_active,
        x       :> pix_x,
        y       :> pix_y,
        gpdi_dp :> gpdi_dp,
        gpdi_dn :> gpdi_dn,
        red     <: video_r,
        green   <: video_g,
        blue    <: video_b
    );

    // J1+ CPU
    // instruction being executed, plus decoding, including 5bit deltas for dsp and rsp expanded from 2bit encoded in the alu instruction
    uint16  instruction = uninitialized;
    uint16  immediate := ( literal(instruction).literalvalue );
    uint1   is_alu := ( instruction(instruction).is_litcallbranchalu == 3b011 );
    uint1   is_call := ( instruction(instruction).is_litcallbranchalu == 3b010 );
    uint1   is_lit := literal(instruction).is_literal;
    uint1   is_n2memt := is_alu && aluop(instruction).is_n2memt;
    uint2   is_callbranchalu := callbranch(instruction).is_callbranchalu;
    uint1   dstackWrite := ( is_lit | (is_alu & aluop(instruction).is_t2n) );
    uint1   rstackWrite := ( is_call | (is_alu & aluop(instruction).is_t2r) );
    uint8   ddelta := { {7{aluop(instruction).ddelta1}}, aluop(instruction).ddelta0 };
    uint8   rdelta := { {7{aluop(instruction).rdelta1}}, aluop(instruction).rdelta0 };

    // program counter
    uint13  pc = 0;
    uint13  pcPlusOne := pc + 1;
    uint13  newPC = uninitialized;
    uint13  callBranchAddress := callbranch(instruction).address;

    // dstack 257x16bit (as 3256 array + stackTop) and pointer, next pointer, write line, delta
    simple_dualport_bram uint16 dstack[256] = uninitialized; // bram (code from @sylefeb)
    uint16  stackTop = 0;
    uint8   dsp = 0;
    uint8   newDSP = uninitialized;
    uint16  newStackTop = uninitialized;

    // rstack 256x16bit and pointer, next pointer, write line
    simple_dualport_bram uint16 rstack[256] = uninitialized; // bram (code from @sylefeb)
    uint8   rsp = 0;
    uint8   newRSP = uninitialized;
    uint16  rstackWData = uninitialized;

    uint16  stackNext := dstack.rdata0;
    uint16  rStackTop := rstack.rdata0;

    uint16  IOmemoryRead := IO_Map.readData;
    uint16  RAMmemoryRead := ram.rdata0;

    j1eforthplusALU ALU
        <@clock_50mhz,!reset>
    (
        instruction <: instruction,

        dsp <: dsp,
        rsp <: rsp,

        stackTop <: stackTop,
        stackNext <: stackNext,
        rStackTop <: rStackTop,

        IOmemoryRead <: IOmemoryRead,
        RAMmemoryRead <: RAMmemoryRead
    );

    j1eforthcallbranch CALLBRANCH
        <@clock_50mhz,!reset>
    (
        is_callbranchalu <: is_callbranchalu,
        stackTop <: stackTop,
        stackNext <: stackNext,
        pcPlusOne <: pcPlusOne,
        callBranchAddress <: callBranchAddress,
        dsp <: dsp,
        rsp <: rsp,
    );

    // 16bit ROM with included with compiled j1eForth developed from https://github.com/samawati/j1eforth
    simple_dualport_bram uint16 ram[16384] = {
16h0CF0,
16h0010,
16h0000,
16h0000,
16h0000,
16h7F00,
16h0E24,
16h0F02,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h2406,
16h23EE,
16h0940,
16h0952,
16h19A8,
16h0BE0,
16h0CCC,
16h13D8,
16h145A,
16h1482,
16h14EE,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h6003,
16h710C,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h6001,
16h700C,
16h6100,
16h700C,
16h404E,
16h005E,
16h404D,
16h005D,
16h404C,
16h005C,
16h404B,
16h005B,
16h404A,
16h005A,
16h4049,
16h0059,
16h4048,
16h0058,
16h4047,
16h0057,
16h4046,
16h0056,
16h4045,
16h0055,
16h4044,
16h0054,
16h4043,
16h0053,
16h4042,
16h0052,
16h4041,
16h0051,
16h4040,
16h0050,
16h700C,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h0000,
16h6E04,
16h6F6F,
16h0070,
16h700C,
16h0182,
16h2B01,
16h720F,
16h018C,
16h7803,
16h726F,
16h750F,
16h0192,
16h6103,
16h646E,
16h730F,
16h019A,
16h6F02,
16h0072,
16h740F,
16h01A2,
16h6906,
16h766E,
16h7265,
16h0074,
16h760C,
16h01AA,
16h3D01,
16h770F,
16h01B6,
16h3C01,
16h780F,
16h01BC,
16h7502,
16h003C,
16h7F0F,
16h01C2,
16h7304,
16h6177,
16h0070,
16h718C,
16h01CA,
16h7502,
16h003E,
16h6180,
16h7F0F,
16h01D4,
16h6403,
16h7075,
16h708D,
16h01DE,
16h6404,
16h6F72,
16h0070,
16h710F,
16h01E6,
16h6F04,
16h6576,
16h0072,
16h718D,
16h01F0,
16h6E03,
16h7069,
16h700F,
16h01FA,
16h6C06,
16h6873,
16h6669,
16h0074,
16h7D0F,
16h0202,
16h7206,
16h6873,
16h6669,
16h0074,
16h790F,
16h020E,
16h3102,
16h002D,
16h7A0C,
16h021A,
16h3E42,
16h0072,
16h6B8D,
16h6180,
16h6147,
16h6147,
16h700C,
16h0222,
16h7242,
16h003E,
16h6B8D,
16h6B8D,
16h6180,
16h6147,
16h700C,
16h0232,
16h7242,
16h0040,
16h6B8D,
16h6B8D,
16h6081,
16h6147,
16h6180,
16h6147,
16h700C,
16h0242,
16h4001,
16h7C0C,
16h0256,
16h2101,
16h6023,
16h710F,
16h025C,
16h3C02,
16h003E,
16h721F,
16h0264,
16h3002,
16h003C,
16h791C,
16h026C,
16h3002,
16h003D,
16h701C,
16h0274,
16h3003,
16h3E3C,
16h711C,
16h027C,
16h3E01,
16h7B1F,
16h0284,
16h3002,
16h003E,
16h7A1C,
16h028A,
16h3E02,
16h003D,
16h7C1F,
16h0292,
16h7404,
16h6375,
16h006B,
16h6180,
16h718D,
16h029A,
16h2D04,
16h6F72,
16h0074,
16h6180,
16h6147,
16h6180,
16h6B8D,
16h700C,
16h02A6,
16h3202,
16h002F,
16h771C,
16h02B8,
16h3202,
16h002A,
16h751C,
16h02C0,
16h3102,
16h002B,
16h731C,
16h02C8,
16h7303,
16h4070,
16h6E81,
16h80FF,
16h730F,
16h02D0,
16h6507,
16h6578,
16h7563,
16h6574,
16h6147,
16h700C,
16h02DC,
16h6203,
16h6579,
16h8FFD,
16h6600,
16h6023,
16h710F,
16h02EA,
16h6302,
16h0040,
16h6081,
16h6C00,
16h6180,
16h8001,
16h6303,
16h2187,
16h8008,
16h6903,
16h0189,
16h80FF,
16h730F,
16h700C,
16h02F8,
16h6302,
16h0021,
16h6180,
16h80FF,
16h6303,
16h6081,
16h8008,
16h6D03,
16h6403,
16h6180,
16h4150,
16h6081,
16h6C00,
16h6180,
16h8001,
16h6303,
16h8000,
16h6703,
16h80FF,
16h6503,
16h6147,
16h6181,
16h6503,
16h6B8D,
16h6303,
16h6503,
16h6180,
16h6023,
16h710F,
16h0316,
16h7503,
16h2B6D,
16h6181,
16h6181,
16h6203,
16h6147,
16h6B81,
16h8000,
16h6C13,
16h6147,
16h6181,
16h6181,
16h6303,
16h6910,
16h6B8D,
16h6403,
16h6147,
16h6403,
16h6910,
16h6B8D,
16h6303,
16h6600,
16h6310,
16h6B8D,
16h718C,
16h0352,
16h6445,
16h766F,
16h7261,
16h6B8D,
16h700C,
16h0386,
16h7502,
16h0070,
16h41C6,
16h7E8C,
16h0392,
16h6446,
16h756F,
16h6573,
16h0072,
16h41CB,
16h6C00,
16h6B8D,
16h6C00,
16h720F,
16h039C,
16h6204,
16h7361,
16h0065,
16hFE80,
16h700C,
16h03B0,
16h7404,
16h6D65,
16h0070,
16hFE82,
16h700C,
16h03BC,
16h3E03,
16h6E69,
16hFE84,
16h700C,
16h03C8,
16h2304,
16h6974,
16h0062,
16hFE86,
16h700C,
16h03D2,
16h7403,
16h6269,
16hFE88,
16h700C,
16h03DE,
16h2705,
16h7665,
16h6C61,
16hFE8A,
16h700C,
16h03E8,
16h2706,
16h6261,
16h726F,
16h0074,
16hFE8C,
16h700C,
16h03F4,
16h6803,
16h646C,
16hFE8E,
16h700C,
16h0402,
16h6307,
16h6E6F,
16h6574,
16h7478,
16hFE90,
16h700C,
16h6413,
16h040C,
16h660E,
16h726F,
16h6874,
16h772D,
16h726F,
16h6C64,
16h7369,
16h0074,
16hFE94,
16h700C,
16h041C,
16h6307,
16h7275,
16h6572,
16h746E,
16hFE9A,
16h700C,
16h0432,
16h6402,
16h0070,
16hFE9E,
16h700C,
16h0440,
16h6C04,
16h7361,
16h0074,
16hFEA0,
16h700C,
16h044A,
16h2705,
16h6B3F,
16h7965,
16hFEA2,
16h700C,
16h0456,
16h2705,
16h6D65,
16h7469,
16hFEA4,
16h700C,
16h0462,
16h2705,
16h6F62,
16h746F,
16hFEA6,
16h700C,
16h046E,
16h2702,
16h005C,
16hFEA8,
16h700C,
16h047A,
16h2706,
16h616E,
16h656D,
16h003F,
16hFEAA,
16h700C,
16h0484,
16h2704,
16h2C24,
16h006E,
16hFEAC,
16h700C,
16h0492,
16h2706,
16h766F,
16h7265,
16h0074,
16hFEAE,
16h700C,
16h049E,
16h2702,
16h003B,
16hFEB0,
16h700C,
16h04AC,
16h2707,
16h7263,
16h6165,
16h6574,
16hFEB2,
16h700C,
16h04B6,
16h6402,
16h0021,
16h6180,
16h6181,
16h6023,
16h6103,
16h6310,
16h6023,
16h710F,
16h04C4,
16h6402,
16h0040,
16h6081,
16h6310,
16h6C00,
16h6180,
16h7C0C,
16h04D8,
16h3F04,
16h7564,
16h0070,
16h6081,
16h227A,
16h708D,
16h700C,
16h04E8,
16h7203,
16h746F,
16h6147,
16h6180,
16h6B8D,
16h718C,
16h04F8,
16h3205,
16h7264,
16h706F,
16h6103,
16h710F,
16h0506,
16h3204,
16h7564,
16h0070,
16h6181,
16h718D,
16h0512,
16h6E06,
16h6765,
16h7461,
16h0065,
16h761C,
16h051E,
16h6407,
16h656E,
16h6167,
16h6574,
16h805F,
16h6600,
16h4264,
16h8053,
16h6600,
16h026E,
16h052A,
16h2D01,
16h781F,
16h0540,
16h6103,
16h7362,
16h7D1C,
16h0546,
16h6D03,
16h7861,
16h7E1F,
16h054E,
16h6D03,
16h6E69,
16h7F1F,
16h0556,
16h7706,
16h7469,
16h6968,
16h006E,
16h6181,
16h42A1,
16h6147,
16h42A1,
16h6B8D,
16h7F0F,
16h055E,
16h6D03,
16h212F,
16h802D,
16h6600,
16h6023,
16h6103,
16h802F,
16h6600,
16h0264,
16h0574,
16h6D03,
16h3F2F,
16h802C,
16h6600,
16h6023,
16h6103,
16h802C,
16h6600,
16h6C00,
16h6010,
16h22CA,
16h802E,
16h6600,
16h6C00,
16h802F,
16h6600,
16h7C0C,
16h0588,
16h7506,
16h2F6D,
16h6F6D,
16h0064,
16h42BC,
16h8001,
16h02C6,
16h05AC,
16h6D05,
16h6D2F,
16h646F,
16h42BC,
16h8002,
16h02C6,
16h05BC,
16h2F02,
16h0021,
16h802A,
16h6600,
16h6023,
16h6103,
16h802B,
16h6600,
16h6023,
16h6103,
16h8001,
16h8029,
16h6600,
16h6023,
16h710F,
16h05CA,
16h2F04,
16h6F6D,
16h0064,
16h42E7,
16h8029,
16h6600,
16h6C00,
16h6010,
16h22F9,
16h802A,
16h6600,
16h6C00,
16h802B,
16h6600,
16h7C0C,
16h05EA,
16h6D03,
16h646F,
16h42F8,
16h710F,
16h060A,
16h2F01,
16h42F8,
16h700F,
16h0614,
16h6D03,
16h212A,
16h8028,
16h6600,
16h6023,
16h6103,
16h8027,
16h6600,
16h6023,
16h710F,
16h061C,
16h6D03,
16h3F2A,
16h8026,
16h6600,
16h6023,
16h6103,
16h8028,
16h6600,
16h026E,
16h0632,
16h7503,
16h2A6D,
16h4310,
16h8001,
16h031B,
16h0646,
16h6D02,
16h002A,
16h4310,
16h8002,
16h031B,
16h0652,
16h2A01,
16h741F,
16h065E,
16h2A05,
16h6D2F,
16h646F,
16h6147,
16h432B,
16h6B8D,
16h02E1,
16h0664,
16h2A02,
16h002F,
16h4335,
16h700F,
16h0674,
16h6305,
16h6C65,
16h2B6C,
16h8002,
16h720F,
16h067E,
16h6305,
16h6C65,
16h2D6C,
16h8002,
16h02A1,
16h068A,
16h6305,
16h6C65,
16h736C,
16h8001,
16h7D0F,
16h0696,
16h6202,
16h006C,
16h8020,
16h700C,
16h06A2,
16h3E05,
16h6863,
16h7261,
16h807F,
16h6303,
16h6081,
16h807F,
16h4353,
16h42B3,
16h2362,
16h6103,
16h805F,
16h700C,
16h700C,
16h06AC,
16h2B02,
16h0021,
16h4150,
16h6C00,
16h6203,
16h6180,
16h6023,
16h710F,
16h06CA,
16h3202,
16h0021,
16h6180,
16h6181,
16h6023,
16h6103,
16h4342,
16h6023,
16h710F,
16h06DC,
16h3202,
16h0040,
16h6081,
16h4342,
16h6C00,
16h6180,
16h7C0C,
16h06F0,
16h6305,
16h756F,
16h746E,
16h6081,
16h6310,
16h6180,
16h017E,
16h0700,
16h6804,
16h7265,
16h0065,
16hFE9E,
16h7C0C,
16h0710,
16h6107,
16h696C,
16h6E67,
16h6465,
16h6081,
16h8000,
16h8002,
16h42DA,
16h6103,
16h6081,
16h239C,
16h8002,
16h6180,
16h42A1,
16h720F,
16h071C,
16h6105,
16h696C,
16h6E67,
16h438B,
16h4392,
16hFE9E,
16h6023,
16h710F,
16h073C,
16h7003,
16h6461,
16h438B,
16h8050,
16h6203,
16h0392,
16h074E,
16h4008,
16h7865,
16h6365,
16h7475,
16h0065,
16h6C00,
16h4277,
16h23B7,
16h0172,
16h700C,
16h075C,
16h6604,
16h6C69,
16h006C,
16h6180,
16h6147,
16h6180,
16h03C3,
16h428C,
16h418D,
16h6310,
16h6B81,
16h23C9,
16h6B8D,
16h6A00,
16h6147,
16h03C0,
16h6B8D,
16h6103,
16h0286,
16h0772,
16h6505,
16h6172,
16h6573,
16h8000,
16h03BC,
16h079A,
16h6405,
16h6769,
16h7469,
16h8009,
16h6181,
16h6803,
16h8007,
16h6303,
16h6203,
16h8030,
16h720F,
16h07A6,
16h6507,
16h7478,
16h6172,
16h7463,
16h8000,
16h6180,
16h42DA,
16h6180,
16h03D6,
16h07BE,
16h3C02,
16h0023,
16h43A9,
16hFE8E,
16h6023,
16h710F,
16h07D2,
16h6804,
16h6C6F,
16h0064,
16hFE8E,
16h6C00,
16h6A00,
16h6081,
16hFE8E,
16h6023,
16h6103,
16h018D,
16h07E0,
16h2301,
16hFE80,
16h6C00,
16h43E3,
16h03F3,
16h07F8,
16h2302,
16h0073,
16h43FD,
16h6081,
16h2408,
16h0404,
16h700C,
16h0804,
16h7304,
16h6769,
16h006E,
16h6910,
16h2411,
16h802D,
16h03F3,
16h700C,
16h0814,
16h2302,
16h003E,
16h6103,
16hFE8E,
16h6C00,
16h43A9,
16h6181,
16h02A1,
16h0826,
16h7303,
16h7274,
16h6081,
16h6147,
16h6D10,
16h43EB,
16h4404,
16h6B8D,
16h440D,
16h0415,
16h0838,
16h6803,
16h7865,
16h8010,
16hFE80,
16h6023,
16h710F,
16h084E,
16h6407,
16h6365,
16h6D69,
16h6C61,
16h800A,
16hFE80,
16h6023,
16h710F,
16h085C,
16h6406,
16h6769,
16h7469,
16h003F,
16h6147,
16h8030,
16h42A1,
16h8009,
16h6181,
16h6803,
16h244E,
16h6081,
16h8020,
16h6B13,
16h2448,
16h8020,
16h42A1,
16h8007,
16h42A1,
16h6081,
16h800A,
16h6803,
16h6403,
16h6081,
16h6B8D,
16h7F0F,
16h086E,
16h6E07,
16h6D75,
16h6562,
16h3F72,
16hFE80,
16h6C00,
16h6147,
16h8000,
16h6181,
16h4383,
16h6181,
16h417E,
16h8024,
16h6703,
16h2466,
16h4429,
16h6180,
16h6310,
16h6180,
16h6A00,
16h6181,
16h417E,
16h802D,
16h6703,
16h6147,
16h6180,
16h6B81,
16h42A1,
16h6180,
16h6B81,
16h6203,
16h4277,
16h2497,
16h6A00,
16h6147,
16h6081,
16h6147,
16h417E,
16hFE80,
16h6C00,
16h443B,
16h2491,
16h6180,
16hFE80,
16h6C00,
16h6413,
16h6203,
16h6B8D,
16h6310,
16h6B81,
16h2489,
16h6B8D,
16h6A00,
16h6147,
16h0475,
16h6B8D,
16h6103,
16h6B81,
16h6003,
16h248F,
16h6610,
16h6180,
16h0496,
16h6B8D,
16h6B8D,
16h4286,
16h4286,
16h8000,
16h6081,
16h6B8D,
16h4286,
16h6B8D,
16hFE80,
16h6023,
16h710F,
16h08A4,
16h3F03,
16h7872,
16h8FFE,
16h6600,
16h6C00,
16h8001,
16h6303,
16h711C,
16h093C,
16h7403,
16h2178,
16h8FFE,
16h6600,
16h6C00,
16h8002,
16h6303,
16h6010,
16h24A9,
16h6081,
16h8FFF,
16h6600,
16h6023,
16h6103,
16h80DF,
16h6600,
16h6C00,
16h6010,
16h24B5,
16h80DF,
16h6600,
16h6023,
16h710F,
16h094E,
16h3F04,
16h656B,
16h0079,
16hFEA2,
16h03B3,
16h097E,
16h6504,
16h696D,
16h0074,
16hFEA4,
16h03B3,
16h098A,
16h6B03,
16h7965,
16h44C2,
16h24CD,
16h8FFF,
16h6600,
16h7C0C,
16h0996,
16h6E04,
16h6675,
16h003F,
16h44C2,
16h6081,
16h24DD,
16h6103,
16h44CD,
16h800D,
16h770F,
16h700C,
16h09A6,
16h7305,
16h6170,
16h6563,
16h4353,
16h04C8,
16h09BE,
16h7306,
16h6170,
16h6563,
16h0073,
16h8000,
16h6E13,
16h6147,
16h04EE,
16h44E2,
16h6B81,
16h24F4,
16h6B8D,
16h6A00,
16h6147,
16h04ED,
16h6B8D,
16h710F,
16h09CA,
16h7404,
16h7079,
16h0065,
16h6147,
16h04FE,
16h4383,
16h44C8,
16h6B81,
16h2504,
16h6B8D,
16h6A00,
16h6147,
16h04FC,
16h6B8D,
16h6103,
16h710F,
16h09EE,
16h6302,
16h0072,
16h800D,
16h44C8,
16h800A,
16h04C8,
16h0A10,
16h6443,
16h246F,
16h6B8D,
16h6B81,
16h6B8D,
16h4383,
16h6203,
16h4392,
16h6147,
16h6180,
16h6147,
16h700C,
16h0A1E,
16h2443,
16h7C22,
16h4511,
16h700C,
16h0A38,
16h2E02,
16h0024,
16h4383,
16h04FA,
16h0A42,
16h2E43,
16h7C22,
16h4511,
16h0523,
16h0A4C,
16h2E02,
16h0072,
16h6147,
16h441E,
16h6B8D,
16h6181,
16h42A1,
16h44E9,
16h04FA,
16h0A56,
16h7503,
16h722E,
16h6147,
16h43EB,
16h4404,
16h4415,
16h6B8D,
16h6181,
16h42A1,
16h44E9,
16h04FA,
16h0A6A,
16h7502,
16h002E,
16h43EB,
16h4404,
16h4415,
16h44E2,
16h04FA,
16h0A82,
16h2E01,
16hFE80,
16h6C00,
16h800A,
16h6503,
16h2550,
16h0543,
16h441E,
16h44E2,
16h04FA,
16h0A92,
16h6305,
16h6F6D,
16h6576,
16h6147,
16h0561,
16h6147,
16h6081,
16h417E,
16h6B81,
16h418D,
16h6310,
16h6B8D,
16h6310,
16h6B81,
16h2567,
16h6B8D,
16h6A00,
16h6147,
16h0559,
16h6B8D,
16h6103,
16h0286,
16h0AA8,
16h7005,
16h6361,
16h246B,
16h6081,
16h6147,
16h428C,
16h6023,
16h6103,
16h6310,
16h6180,
16h4557,
16h6B8D,
16h700C,
16h0AD6,
16h3F01,
16h6C00,
16h054A,
16h0AF2,
16h2807,
16h6170,
16h7372,
16h2965,
16hFE82,
16h6023,
16h6103,
16h6181,
16h6147,
16h6081,
16h25CC,
16h6A00,
16hFE82,
16h6C00,
16h4353,
16h6703,
16h25A8,
16h6147,
16h4383,
16hFE82,
16h6C00,
16h6180,
16h42A1,
16h6910,
16h6600,
16h6B81,
16h6A10,
16h6303,
16h25A6,
16h6B81,
16h25A0,
16h6B8D,
16h6A00,
16h6147,
16h058F,
16h6B8D,
16h6103,
16h6B8D,
16h6103,
16h8000,
16h708D,
16h6A00,
16h6B8D,
16h6181,
16h6180,
16h6147,
16h4383,
16hFE82,
16h6C00,
16h6180,
16h42A1,
16hFE82,
16h6C00,
16h4353,
16h6703,
16h25B6,
16h6910,
16h25C2,
16h6B81,
16h25BD,
16h6B8D,
16h6A00,
16h6147,
16h05AB,
16h6B8D,
16h6103,
16h6081,
16h6147,
16h05C7,
16h6B8D,
16h6103,
16h6081,
16h6147,
16h6A00,
16h6181,
16h42A1,
16h6B8D,
16h6B8D,
16h02A1,
16h6181,
16h6B8D,
16h02A1,
16h0AFA,
16h7005,
16h7261,
16h6573,
16h6147,
16hFE88,
16h6C00,
16hFE84,
16h6C00,
16h6203,
16hFE86,
16h6C00,
16hFE84,
16h6C00,
16h42A1,
16h6B8D,
16h4581,
16hFE84,
16h0367,
16h0BA0,
16h2E82,
16h0028,
16h8029,
16h45D3,
16h04FA,
16h0BC6,
16h2881,
16h8029,
16h45D3,
16h0286,
16h0BD2,
16h3C83,
16h3E5C,
16hFE86,
16h6C00,
16hFE84,
16h6023,
16h710F,
16h0BDC,
16h5C81,
16hFEA8,
16h03B3,
16h0BEC,
16h7704,
16h726F,
16h0064,
16h45D3,
16h438B,
16h4342,
16h056E,
16h0BF4,
16h7405,
16h6B6F,
16h6E65,
16h4353,
16h05FD,
16h0C04,
16h6E05,
16h6D61,
16h3E65,
16h4383,
16h801F,
16h6303,
16h6203,
16h0392,
16h0C10,
16h7305,
16h6D61,
16h3F65,
16h6A00,
16h6147,
16h0624,
16h6181,
16h6B81,
16h6203,
16h417E,
16h6181,
16h6B81,
16h6203,
16h417E,
16h42A1,
16h4277,
16h2624,
16h6B8D,
16h710F,
16h6B81,
16h262A,
16h6B8D,
16h6A00,
16h6147,
16h0617,
16h6B8D,
16h6103,
16h8000,
16h700C,
16h0C22,
16h6604,
16h6E69,
16h0064,
16h6180,
16h6081,
16h417E,
16hFE82,
16h6023,
16h6103,
16h6081,
16h6C00,
16h6147,
16h4342,
16h6180,
16h6C00,
16h6081,
16h2650,
16h6081,
16h6C00,
16hFF1F,
16h6303,
16h6B81,
16h6503,
16h264B,
16h4342,
16h8000,
16h6600,
16h064F,
16h4342,
16hFE82,
16h6C00,
16h4614,
16h0655,
16h6B8D,
16h6103,
16h6180,
16h4348,
16h718C,
16h265A,
16h8002,
16h434E,
16h42A1,
16h063D,
16h6B8D,
16h6103,
16h6003,
16h4348,
16h6081,
16h460B,
16h718C,
16h0C5E,
16h3C07,
16h616E,
16h656D,
16h3E3F,
16hFE90,
16h6081,
16h437A,
16h6503,
16h266C,
16h4348,
16h6147,
16h6B8D,
16h4342,
16h6081,
16h6147,
16h6C00,
16h4277,
16h2679,
16h4632,
16h4277,
16h266D,
16h6B8D,
16h710F,
16h6B8D,
16h6103,
16h8000,
16h700C,
16h0CC4,
16h6E05,
16h6D61,
16h3F65,
16hFEAA,
16h03B3,
16h0CFC,
16h5E02,
16h0068,
16h6147,
16h6181,
16h6B81,
16h6803,
16h6081,
16h2691,
16h8008,
16h6081,
16h44C8,
16h44E2,
16h44C8,
16h6B8D,
16h720F,
16h0D08,
16h7403,
16h7061,
16h6081,
16h44C8,
16h6181,
16h418D,
16h731C,
16h0D28,
16h6B04,
16h6174,
16h0070,
16h6081,
16h800D,
16h6503,
16h26A9,
16h8008,
16h6503,
16h26A8,
16h4353,
16h0696,
16h0686,
16h6103,
16h6003,
16h708D,
16h0D38,
16h6106,
16h6363,
16h7065,
16h0074,
16h6181,
16h6203,
16h6181,
16h428C,
16h6503,
16h26C2,
16h44CD,
16h6081,
16h4353,
16h42A1,
16h807F,
16h6F03,
16h26C0,
16h4696,
16h06C1,
16h469F,
16h06B4,
16h6103,
16h6181,
16h02A1,
16h0D5A,
16h7105,
16h6575,
16h7972,
16hFE88,
16h6C00,
16h8050,
16h46B1,
16hFE86,
16h6023,
16h6103,
16h6103,
16h8000,
16hFE84,
16h6023,
16h710F,
16h0D8C,
16h6106,
16h6F62,
16h7472,
16h0032,
16h4511,
16h710F,
16h0DAC,
16h6106,
16h6F62,
16h7472,
16h0031,
16h44E2,
16h4523,
16h803F,
16h44C8,
16h450A,
16hFE8C,
16h43B3,
16h06DA,
16h0DBA,
16h3C49,
16h613F,
16h6F62,
16h7472,
16h3E22,
16h26F2,
16h4511,
16h06E1,
16h06DA,
16h0DD4,
16h6606,
16h726F,
16h6567,
16h0074,
16h4605,
16h4681,
16h4277,
16h270A,
16h4348,
16h6081,
16hFE9E,
16h6023,
16h6103,
16h6C00,
16h6081,
16hFE90,
16h6023,
16h6103,
16hFEA0,
16h6023,
16h6103,
16h710F,
16h06E1,
16h0DE8,
16h240A,
16h6E69,
16h6574,
16h7072,
16h6572,
16h0074,
16h4681,
16h4277,
16h2722,
16h6C00,
16h8040,
16h6303,
16h46EF,
16h630C,
16h6D6F,
16h6970,
16h656C,
16h6F2D,
16h6C6E,
16h0079,
16h0172,
16h0726,
16h4456,
16h2725,
16h700C,
16h06E1,
16h0E18,
16h5B81,
16h8E24,
16hFE8A,
16h6023,
16h710F,
16h0E4E,
16h2E03,
16h6B6F,
16h8E24,
16hFE8A,
16h6C00,
16h6703,
16h2737,
16h4528,
16h2003,
16h6B6F,
16h050A,
16h0E5A,
16h6504,
16h6176,
16h006C,
16h4605,
16h6081,
16h417E,
16h2743,
16hFE8A,
16h43B3,
16h073C,
16h6103,
16h072F,
16h0E72,
16h2445,
16h7665,
16h6C61,
16hFE84,
16h6C00,
16h6147,
16hFE86,
16h6C00,
16h6147,
16hFE88,
16h6C00,
16h6147,
16hFE84,
16h8000,
16h6180,
16h6023,
16h6103,
16hFE86,
16h6023,
16h6103,
16hFE88,
16h6023,
16h6103,
16h473C,
16h6B8D,
16hFE88,
16h6023,
16h6103,
16h6B8D,
16hFE86,
16h6023,
16h6103,
16h6B8D,
16hFE84,
16h6023,
16h710F,
16h0E8C,
16h7006,
16h6572,
16h6573,
16h0074,
16hFF00,
16hFE86,
16h4342,
16h6023,
16h710F,
16h0ED6,
16h7104,
16h6975,
16h0074,
16h4728,
16h46C9,
16h473C,
16h0779,
16h700C,
16h0EEA,
16h6105,
16h6F62,
16h7472,
16h6103,
16h476F,
16h472F,
16h0778,
16h0EFC,
16h2701,
16h4605,
16h4681,
16h278B,
16h700C,
16h06E1,
16h0F0C,
16h6105,
16h6C6C,
16h746F,
16h4392,
16hFE9E,
16h0367,
16h0F1A,
16h2C01,
16h438B,
16h6081,
16h4342,
16hFE9E,
16h6023,
16h6103,
16h6023,
16h710F,
16h0F28,
16h6345,
16h6C61,
16h2C6C,
16h8001,
16h6903,
16hC000,
16h6403,
16h0795,
16h0F3C,
16h3F47,
16h7262,
16h6E61,
16h6863,
16h8001,
16h6903,
16hA000,
16h6403,
16h0795,
16h0F4E,
16h6246,
16h6172,
16h636E,
16h0068,
16h8001,
16h6903,
16h8000,
16h6403,
16h0795,
16h0F62,
16h5B89,
16h6F63,
16h706D,
16h6C69,
16h5D65,
16h4787,
16h07A1,
16h0F76,
16h6347,
16h6D6F,
16h6970,
16h656C,
16h6B8D,
16h6081,
16h6C00,
16h4795,
16h4342,
16h6147,
16h700C,
16h0F86,
16h7287,
16h6365,
16h7275,
16h6573,
16hFEA0,
16h6C00,
16h460B,
16h07A1,
16h0F9E,
16h7004,
16h6369,
16h006B,
16h6081,
16h6510,
16h6510,
16h80C0,
16h6203,
16h6147,
16h700C,
16h0FB0,
16h6C87,
16h7469,
16h7265,
16h6C61,
16h6081,
16hFFFF,
16h6600,
16h6303,
16h27F3,
16h8000,
16h6600,
16h6503,
16h47E7,
16h47C7,
16h6600,
16h07F7,
16hFFFF,
16h6600,
16h6403,
16h0795,
16h700C,
16h0FC6,
16h5B83,
16h5D27,
16h4787,
16h07E7,
16h0FF2,
16h2403,
16h222C,
16h8022,
16h45D3,
16h438B,
16h456E,
16h4383,
16h6203,
16h4392,
16hFE9E,
16h6023,
16h710F,
16h0FFC,
16h66C3,
16h726F,
16h47C7,
16h4113,
16h038B,
16h1016,
16h62C5,
16h6765,
16h6E69,
16h038B,
16h1022,
16h2846,
16h656E,
16h7478,
16h0029,
16h6B8D,
16h6B8D,
16h4277,
16h2823,
16h6A00,
16h6147,
16h6C00,
16h6147,
16h700C,
16h4342,
16h6147,
16h700C,
16h102C,
16h6EC4,
16h7865,
16h0074,
16h47C7,
16h481A,
16h0795,
16h104E,
16h2844,
16h6F64,
16h0029,
16h6B8D,
16h6081,
16h6147,
16h6180,
16h427E,
16h6147,
16h6147,
16h4342,
16h6147,
16h700C,
16h105C,
16h64C2,
16h006F,
16h47C7,
16h4831,
16h8000,
16h4795,
16h038B,
16h1078,
16h2847,
16h656C,
16h7661,
16h2965,
16h6B8D,
16h6103,
16h6B8D,
16h6103,
16h6B8D,
16h710F,
16h1088,
16h6CC5,
16h6165,
16h6576,
16h47C7,
16h4848,
16h700C,
16h109E,
16h2846,
16h6F6C,
16h706F,
16h0029,
16h6B8D,
16h6B8D,
16h6310,
16h6B8D,
16h428C,
16h6213,
16h2866,
16h6147,
16h6147,
16h6C00,
16h6147,
16h700C,
16h6147,
16h6A00,
16h6147,
16h4342,
16h6147,
16h700C,
16h10AC,
16h2848,
16h6E75,
16h6F6C,
16h706F,
16h0029,
16h6B8D,
16h6B8D,
16h6103,
16h6B8D,
16h6103,
16h6B8D,
16h6103,
16h6147,
16h700C,
16h10DA,
16h75C6,
16h6C6E,
16h6F6F,
16h0070,
16h47C7,
16h4872,
16h700C,
16h10F8,
16h2845,
16h643F,
16h296F,
16h428C,
16h6213,
16h2894,
16h6B8D,
16h6081,
16h6147,
16h6180,
16h427E,
16h6147,
16h6147,
16h4342,
16h6147,
16h700C,
16h0286,
16h700C,
16h1108,
16h3FC3,
16h6F64,
16h47C7,
16h4887,
16h8000,
16h4795,
16h038B,
16h112E,
16h6CC4,
16h6F6F,
16h0070,
16h47C7,
16h485A,
16h6081,
16h4795,
16h47C7,
16h4872,
16h4348,
16h438B,
16h8001,
16h6903,
16h6180,
16h6023,
16h710F,
16h113E,
16h2847,
16h6C2B,
16h6F6F,
16h2970,
16h6B8D,
16h6180,
16h6B8D,
16h6B8D,
16h428C,
16h42A1,
16h6147,
16h8002,
16h47DB,
16h6B81,
16h6203,
16h6B81,
16h6503,
16h6910,
16h6010,
16h8003,
16h47DB,
16h6B8D,
16h6503,
16h6910,
16h6010,
16h6403,
16h28D1,
16h6147,
16h6203,
16h6147,
16h6C00,
16h6147,
16h700C,
16h6147,
16h6147,
16h6103,
16h4342,
16h6147,
16h700C,
16h1160,
16h2BC5,
16h6F6C,
16h706F,
16h47C7,
16h48B4,
16h6081,
16h4795,
16h47C7,
16h4872,
16h4348,
16h438B,
16h8001,
16h6903,
16h6180,
16h6023,
16h710F,
16h11B0,
16h2843,
16h2969,
16h6B8D,
16h6B8D,
16h4150,
16h6147,
16h6147,
16h700C,
16h11D2,
16h69C1,
16h47C7,
16h48EB,
16h700C,
16h11E4,
16h75C5,
16h746E,
16h6C69,
16h07AB,
16h11EE,
16h61C5,
16h6167,
16h6E69,
16h07B5,
16h11F8,
16h69C2,
16h0066,
16h438B,
16h8000,
16h07AB,
16h1202,
16h74C4,
16h6568,
16h006E,
16h438B,
16h8001,
16h6903,
16h6181,
16h6C00,
16h6403,
16h6180,
16h6023,
16h710F,
16h120E,
16h72C6,
16h7065,
16h6165,
16h0074,
16h47B5,
16h090A,
16h1228,
16h73C4,
16h696B,
16h0070,
16h438B,
16h8000,
16h07B5,
16h1236,
16h61C3,
16h7466,
16h6103,
16h491E,
16h4814,
16h718C,
16h1244,
16h65C4,
16h736C,
16h0065,
16h491E,
16h6180,
16h090A,
16h1252,
16h77C5,
16h6968,
16h656C,
16h4903,
16h718C,
16h1260,
16h2846,
16h6163,
16h6573,
16h0029,
16h6B8D,
16h6180,
16h6147,
16h6147,
16h700C,
16h126C,
16h63C4,
16h7361,
16h0065,
16h47C7,
16h493A,
16h8030,
16h700C,
16h1280,
16h2844,
16h666F,
16h0029,
16h6B8D,
16h6B81,
16h6180,
16h6147,
16h770F,
16h1290,
16h6FC2,
16h0066,
16h47C7,
16h494B,
16h0903,
16h12A2,
16h65C5,
16h646E,
16h666F,
16h492C,
16h8031,
16h700C,
16h12AE,
16h2809,
16h6E65,
16h6364,
16h7361,
16h2965,
16h6B8D,
16h6B8D,
16h6103,
16h6147,
16h700C,
16h12BC,
16h65C7,
16h646E,
16h6163,
16h6573,
16h6081,
16h8031,
16h6703,
16h2974,
16h6103,
16h490A,
16h096D,
16h8030,
16h6213,
16h46EF,
16h6213,
16h6461,
16h6320,
16h7361,
16h2065,
16h6F63,
16h736E,
16h7274,
16h6375,
16h2E74,
16h47C7,
16h4963,
16h700C,
16h12D2,
16h24C2,
16h0022,
16h47C7,
16h451E,
16h0800,
16h130A,
16h2EC2,
16h0022,
16h47C7,
16h4528,
16h0800,
16h1316,
16h3E05,
16h6F62,
16h7964,
16h0342,
16h1322,
16h2844,
16h6F74,
16h0029,
16h6B8D,
16h6081,
16h4342,
16h6147,
16h6C00,
16h6023,
16h710F,
16h132C,
16h74C2,
16h006F,
16h47C7,
16h4999,
16h4787,
16h4994,
16h0795,
16h1342,
16h2845,
16h742B,
16h296F,
16h6B8D,
16h6081,
16h4342,
16h6147,
16h6C00,
16h0367,
16h1352,
16h2BC3,
16h6F74,
16h47C7,
16h49AC,
16h4787,
16h4994,
16h0795,
16h1366,
16h670B,
16h7465,
16h632D,
16h7275,
16h6572,
16h746E,
16hFE9A,
16h7C0C,
16h1376,
16h730B,
16h7465,
16h632D,
16h7275,
16h6572,
16h746E,
16hFE9A,
16h6023,
16h710F,
16h1388,
16h640B,
16h6665,
16h6E69,
16h7469,
16h6F69,
16h736E,
16hFE90,
16h6C00,
16h09CA,
16h139C,
16h3F07,
16h6E75,
16h7169,
16h6575,
16h6081,
16h49C1,
16h4632,
16h29E7,
16h4528,
16h2007,
16h6572,
16h6564,
16h2066,
16h6181,
16h4523,
16h710F,
16h13B0,
16h3C05,
16h2C24,
16h3E6E,
16h6081,
16h417E,
16h2A01,
16h49DC,
16h6081,
16h4383,
16h6203,
16h4392,
16hFE9E,
16h6023,
16h6103,
16h6081,
16hFEA0,
16h6023,
16h6103,
16h4348,
16h49C1,
16h6C00,
16h6180,
16h6023,
16h710F,
16h6103,
16h451E,
16h6E04,
16h6D61,
16h0065,
16h06E1,
16h13D2,
16h2403,
16h6E2C,
16hFEAC,
16h03B3,
16h1410,
16h2408,
16h6F63,
16h706D,
16h6C69,
16h0065,
16h4681,
16h4277,
16h2A1C,
16h6C00,
16h8080,
16h6303,
16h2A1B,
16h0172,
16h0A1C,
16h07A1,
16h4456,
16h2A1F,
16h07E7,
16h06E1,
16h141A,
16h6186,
16h6F62,
16h7472,
16h0022,
16h47C7,
16h46EF,
16h0800,
16h1442,
16h3C07,
16h766F,
16h7265,
16h3E74,
16hFEA0,
16h6C00,
16h49C1,
16h6023,
16h710F,
16h1452,
16h6F05,
16h6576,
16h7472,
16hFEAE,
16h03B3,
16h1466,
16h6504,
16h6978,
16h0074,
16h6B8D,
16h710F,
16h1472,
16h3CC3,
16h3E3B,
16h47C7,
16h4A3C,
16h4728,
16h4A36,
16h8000,
16h438B,
16h6023,
16h710F,
16h147E,
16h3BC1,
16hFEB0,
16h03B3,
16h1494,
16h5D01,
16h9424,
16hFE8A,
16h6023,
16h710F,
16h149C,
16h3A01,
16h4605,
16h4A0A,
16h0A4F,
16h14A8,
16h6909,
16h6D6D,
16h6465,
16h6169,
16h6574,
16h8080,
16hFEA0,
16h6C00,
16h6C00,
16h6403,
16hFEA0,
16h6C00,
16h6023,
16h710F,
16h14B2,
16h7504,
16h6573,
16h0072,
16h4605,
16h4A0A,
16h4A36,
16h47C7,
16h41D2,
16h0795,
16h14D0,
16h3C08,
16h7263,
16h6165,
16h6574,
16h003E,
16h4605,
16h4A0A,
16h4A36,
16h838C,
16h07A1,
16h14E4,
16h6306,
16h6572,
16h7461,
16h0065,
16hFEB2,
16h03B3,
16h14FA,
16h7608,
16h7261,
16h6169,
16h6C62,
16h0065,
16h4A81,
16h8000,
16h0795,
16h1508,
16h2847,
16h6F64,
16h7365,
16h293E,
16h6B8D,
16h8001,
16h6903,
16h438B,
16h8001,
16h6903,
16hFEA0,
16h6C00,
16h460B,
16h6081,
16h4342,
16hFFFF,
16h6600,
16h6403,
16h4795,
16h6023,
16h6103,
16h0795,
16h151A,
16h630C,
16h6D6F,
16h6970,
16h656C,
16h6F2D,
16h6C6E,
16h0079,
16h8040,
16hFEA0,
16h6C00,
16h6C00,
16h6403,
16hFEA0,
16h6C00,
16h6023,
16h710F,
16h1548,
16h6485,
16h656F,
16h3E73,
16h47C7,
16h4A91,
16h700C,
16h156A,
16h6304,
16h6168,
16h0072,
16h4353,
16h45FD,
16h6310,
16h017E,
16h1578,
16h5B86,
16h6863,
16h7261,
16h005D,
16h4ABF,
16h07E7,
16h1588,
16h6308,
16h6E6F,
16h7473,
16h6E61,
16h0074,
16h4A81,
16h4795,
16h4A91,
16h7C0C,
16h1596,
16h3209,
16h6F63,
16h736E,
16h6174,
16h746E,
16h4A81,
16h4795,
16h4795,
16h4AB8,
16h037A,
16h15AA,
16h3209,
16h6176,
16h6972,
16h6261,
16h656C,
16h4A81,
16h8002,
16h434E,
16h0790,
16h15C0,
16h6405,
16h6665,
16h7265,
16h4A81,
16h8000,
16h4795,
16h4A91,
16h6C00,
16h4277,
16h8000,
16h6703,
16h46EF,
16h750D,
16h696E,
16h696E,
16h6974,
16h6C61,
16h7A69,
16h6465,
16h0172,
16h15D4,
16h6982,
16h0073,
16h4787,
16h4994,
16h6023,
16h710F,
16h15FE,
16h2E03,
16h6469,
16h4277,
16h2B0E,
16h4383,
16h801F,
16h6303,
16h04FA,
16h450A,
16h4528,
16h7B08,
16h6F6E,
16h616E,
16h656D,
16h007D,
16h700C,
16h160C,
16h7708,
16h726F,
16h6C64,
16h7369,
16h0074,
16h43A1,
16h438B,
16h8000,
16h4795,
16h6081,
16hFE9A,
16h4342,
16h6081,
16h6C00,
16h4795,
16h6023,
16h6103,
16h8000,
16h0795,
16h162E,
16h6F06,
16h6472,
16h7265,
16h0040,
16h6081,
16h6C00,
16h6081,
16h2B39,
16h6147,
16h4342,
16h4B2F,
16h6B8D,
16h6180,
16h731C,
16h700F,
16h1656,
16h6709,
16h7465,
16h6F2D,
16h6472,
16h7265,
16hFE90,
16h0B2F,
16h1676,
16h3E04,
16h6977,
16h0064,
16h0342,
16h1686,
16h2E04,
16h6977,
16h0064,
16h44E2,
16h6081,
16h4B46,
16h4342,
16h6C00,
16h4277,
16h2B54,
16h4B08,
16h710F,
16h8000,
16h0537,
16h1690,
16h2104,
16h6977,
16h0064,
16h4B46,
16h4342,
16hFEA0,
16h6C00,
16h6180,
16h6023,
16h710F,
16h16AE,
16h7604,
16h636F,
16h0073,
16h450A,
16h4528,
16h7605,
16h636F,
16h3A73,
16hFE9A,
16h4342,
16h6C00,
16h4277,
16h2B73,
16h6081,
16h4B4B,
16h4B46,
16h0B6C,
16h700C,
16h16C4,
16h6F05,
16h6472,
16h7265,
16h450A,
16h4528,
16h7307,
16h6165,
16h6372,
16h3A68,
16h4B40,
16h4277,
16h2B85,
16h6180,
16h4B4B,
16h6A00,
16h0B7F,
16h450A,
16h4528,
16h6407,
16h6665,
16h6E69,
16h3A65,
16h49C1,
16h0B4B,
16h16EA,
16h7309,
16h7465,
16h6F2D,
16h6472,
16h7265,
16h6081,
16h8000,
16h6600,
16h6703,
16h2B9B,
16h6103,
16hFE94,
16h8001,
16h8008,
16h6181,
16h6F03,
16h46EF,
16h6F12,
16h6576,
16h2072,
16h6973,
16h657A,
16h6F20,
16h2066,
16h7623,
16h636F,
16h0073,
16hFE90,
16h6180,
16h6081,
16h2BB6,
16h6147,
16h6180,
16h6181,
16h6023,
16h6103,
16h4342,
16h6B8D,
16h6A00,
16h0BAB,
16h6180,
16h6023,
16h710F,
16h171C,
16h6F04,
16h6C6E,
16h0079,
16h8000,
16h6600,
16h0B93,
16h1774,
16h6104,
16h736C,
16h006F,
16h4B40,
16h6181,
16h6180,
16h6310,
16h0B93,
16h1782,
16h7008,
16h6572,
16h6976,
16h756F,
16h0073,
16h4B40,
16h6180,
16h6103,
16h6A00,
16h0B93,
16h1794,
16h3E04,
16h6F76,
16h0063,
16h4A81,
16h6081,
16h4795,
16h4B5A,
16h4A91,
16h6C00,
16h6147,
16h4B40,
16h6180,
16h6103,
16h6B8D,
16h6180,
16h0B93,
16h17AA,
16h7705,
16h6469,
16h666F,
16h4787,
16h4994,
16h7C0C,
16h17CC,
16h760A,
16h636F,
16h6261,
16h6C75,
16h7261,
16h0079,
16h4B1C,
16h0BD8,
16h17DA,
16h5F05,
16h7974,
16h6570,
16h6147,
16h0BFE,
16h4383,
16h4359,
16h44C8,
16h6B81,
16h2C04,
16h6B8D,
16h6A00,
16h6147,
16h0BFB,
16h6B8D,
16h6103,
16h710F,
16h17EC,
16h6403,
16h2B6D,
16h6181,
16h8004,
16h4537,
16h44E2,
16h6147,
16h0C13,
16h4383,
16h8003,
16h4537,
16h6B81,
16h2C19,
16h6B8D,
16h6A00,
16h6147,
16h0C10,
16h6B8D,
16h710F,
16h1810,
16h6404,
16h6D75,
16h0070,
16hFE80,
16h6C00,
16h6147,
16h4429,
16h8010,
16h430B,
16h6147,
16h450A,
16h8010,
16h428C,
16h4C0A,
16h4156,
16h8002,
16h44E9,
16h4BF9,
16h6B81,
16h2C34,
16h6B8D,
16h6A00,
16h6147,
16h0C26,
16h6B8D,
16h6103,
16h6103,
16h6B8D,
16hFE80,
16h6023,
16h710F,
16h1838,
16h2E02,
16h0073,
16h450A,
16h416A,
16h6A00,
16h800F,
16h6303,
16h6147,
16h6B81,
16h47DB,
16h454A,
16h6B81,
16h2C4D,
16h6B8D,
16h6A00,
16h6147,
16h0C44,
16h6B8D,
16h6103,
16h4528,
16h3C04,
16h6F74,
16h0073,
16h700C,
16h1878,
16h2807,
16h6E3E,
16h6D61,
16h2965,
16h6C00,
16h4277,
16h2C63,
16h428C,
16h460B,
16h6503,
16h2C62,
16h4348,
16h0C59,
16h700F,
16h6103,
16h8000,
16h700C,
16h18AA,
16h3E05,
16h616E,
16h656D,
16h6147,
16h4B40,
16h4277,
16h2C86,
16h6180,
16h6B81,
16h6180,
16h4C59,
16h4277,
16h2C84,
16h6147,
16h6A00,
16h6147,
16h0C79,
16h6103,
16h6B81,
16h2C7F,
16h6B8D,
16h6A00,
16h6147,
16h0C78,
16h6B8D,
16h6103,
16h6B8D,
16h6B8D,
16h710F,
16h6A00,
16h0C6C,
16h6B8D,
16h6103,
16h8000,
16h700C,
16h18CE,
16h7303,
16h6565,
16h4787,
16h450A,
16h6081,
16h6C00,
16h4277,
16hF00C,
16h6503,
16h2CA6,
16hBFFF,
16h6303,
16h8001,
16h6D03,
16h4C6A,
16h4277,
16h2C9F,
16h44E2,
16h4B08,
16h0CA4,
16h6081,
16h6C00,
16hFFFF,
16h6303,
16h4543,
16h4342,
16h0C8F,
16h0286,
16h1916,
16h2807,
16h6F77,
16h6472,
16h2973,
16h450A,
16h6C00,
16h4277,
16h2CB5,
16h6081,
16h4B08,
16h44E2,
16h4348,
16h0CAD,
16h700C,
16h1950,
16h7705,
16h726F,
16h7364,
16h4B40,
16h4277,
16h2CC8,
16h6180,
16h450A,
16h450A,
16h4528,
16h3A01,
16h6081,
16h4B4B,
16h450A,
16h4CAC,
16h6A00,
16h0CBB,
16h700C,
16h196E,
16h7603,
16h7265,
16h8002,
16h8100,
16h6413,
16h8001,
16h720F,
16h1994,
16h6802,
16h0069,
16h450A,
16h4528,
16h650B,
16h6F66,
16h7472,
16h2068,
16h316A,
16h7620,
16hFE80,
16h6C00,
16h4429,
16h4CCC,
16h43EB,
16h43FD,
16h43FD,
16h802E,
16h43F3,
16h43FD,
16h4415,
16h44FA,
16hFE80,
16h6023,
16h6103,
16h050A,
16h19A4,
16h6304,
16h6C6F,
16h0064,
16h8002,
16hFE80,
16h8042,
16h4557,
16h476F,
16hFE94,
16h6081,
16hFE90,
16h6023,
16h6103,
16h6081,
16hFE9A,
16h4370,
16h4A36,
16hC000,
16h4342,
16h6081,
16h4348,
16h6C00,
16h4749,
16hFEA6,
16h43B3,
16h4778,
16h0CF0,
16h19DA,
16h3205,
16h766F,
16h7265,
16h6147,
16h6147,
16h428C,
16h6B8D,
16h6B8D,
16h427E,
16h6147,
16h427E,
16h6B8D,
16h700C,
16h1A12,
16h3205,
16h7773,
16h7061,
16h427E,
16h6147,
16h427E,
16h6B8D,
16h700C,
16h1A2E,
16h3204,
16h696E,
16h0070,
16h427E,
16h6103,
16h427E,
16h710F,
16h1A40,
16h3204,
16h6F72,
16h0074,
16h6180,
16h6147,
16h6147,
16h4D1A,
16h6B8D,
16h6B8D,
16h6180,
16h0D1A,
16h1A50,
16h6403,
16h3D30,
16h805F,
16h6600,
16h4264,
16h8043,
16h6600,
16h7C0C,
16h1A68,
16h6402,
16h003D,
16h805F,
16h6600,
16h4264,
16h8041,
16h6600,
16h7C0C,
16h1A7A,
16h6402,
16h002B,
16h805F,
16h6600,
16h4264,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h026E,
16h1A8C,
16h6402,
16h002D,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h805D,
16h6600,
16h026E,
16h1AA4,
16h7303,
16h643E,
16h6081,
16h791C,
16h1ABC,
16h6403,
16h2B31,
16h805F,
16h6600,
16h4264,
16h805B,
16h6600,
16h026E,
16h1AC6,
16h6403,
16h2D31,
16h805F,
16h6600,
16h4264,
16h8059,
16h6600,
16h026E,
16h1AD8,
16h6404,
16h6F78,
16h0072,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h804F,
16h6600,
16h026E,
16h1AEA,
16h6404,
16h6E61,
16h0064,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h804D,
16h6600,
16h026E,
16h1B04,
16h6403,
16h726F,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h804B,
16h6600,
16h026E,
16h1B1E,
16h6407,
16h6E69,
16h6576,
16h7472,
16h805F,
16h6600,
16h4264,
16h8051,
16h6600,
16h026E,
16h1B36,
16h6403,
16h2A32,
16h805F,
16h6600,
16h4264,
16h8057,
16h6600,
16h026E,
16h1B4C,
16h6403,
16h2F32,
16h805F,
16h6600,
16h4264,
16h8055,
16h6600,
16h026E,
16h1B5E,
16h6404,
16h6261,
16h0073,
16h805F,
16h6600,
16h4264,
16h8049,
16h6600,
16h026E,
16h1B70,
16h6404,
16h616D,
16h0078,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h8047,
16h6600,
16h026E,
16h1B84,
16h6404,
16h696D,
16h006E,
16h805D,
16h6600,
16h4264,
16h805F,
16h6600,
16h4264,
16h8045,
16h6600,
16h026E,
16h1B9E,
16h6C04,
16h6465,
16h0040,
16h8FFD,
16h6600,
16h7C0C,
16h1BB8,
16h6C04,
16h6465,
16h0021,
16h8FFD,
16h6600,
16h6023,
16h710F,
16h1BC6,
16h6208,
16h7475,
16h6F74,
16h736E,
16h0040,
16h8FFC,
16h6600,
16h7C0C,
16h1BD6,
16h6205,
16h6565,
16h2170,
16h6081,
16h801D,
16h6600,
16h6023,
16h6103,
16h8019,
16h6600,
16h6023,
16h6103,
16h6081,
16h801E,
16h6600,
16h6023,
16h6103,
16h801A,
16h6600,
16h6023,
16h6103,
16h6081,
16h801F,
16h6600,
16h6023,
16h6103,
16h801B,
16h6600,
16h6023,
16h6103,
16h6081,
16h801C,
16h6600,
16h6023,
16h6103,
16h8018,
16h6600,
16h6023,
16h710F,
16h1BE8,
16h6205,
16h6565,
16h3F70,
16h801C,
16h6600,
16h6C00,
16h6010,
16h2E1F,
16h8018,
16h6600,
16h6C00,
16h6010,
16h2E24,
16h700C,
16h1C38,
16h6206,
16h6565,
16h4C70,
16h0021,
16h801D,
16h6600,
16h6023,
16h6103,
16h801E,
16h6600,
16h6023,
16h6103,
16h801F,
16h6600,
16h6023,
16h6103,
16h801C,
16h6600,
16h6023,
16h710F,
16h1C56,
16h6206,
16h6565,
16h5270,
16h0021,
16h8019,
16h6600,
16h6023,
16h6103,
16h801A,
16h6600,
16h6023,
16h6103,
16h801B,
16h6600,
16h6023,
16h6103,
16h8018,
16h6600,
16h6023,
16h710F,
16h1C80,
16h6206,
16h6565,
16h4C70,
16h003F,
16h801C,
16h6600,
16h6C00,
16h6010,
16h2E59,
16h700C,
16h1CAA,
16h6206,
16h6565,
16h5270,
16h003F,
16h8018,
16h6600,
16h6C00,
16h6010,
16h2E64,
16h700C,
16h1CC0,
16h6306,
16h6F6C,
16h6B63,
16h0040,
16h8FFB,
16h6600,
16h7C0C,
16h1CD6,
16h7409,
16h6D69,
16h7265,
16h6831,
16h217A,
16h8001,
16h8012,
16h6600,
16h6023,
16h710F,
16h1CE6,
16h7409,
16h6D69,
16h7265,
16h6831,
16h407A,
16h8012,
16h6600,
16h7C0C,
16h1CFC,
16h740A,
16h6D69,
16h7265,
16h6B31,
16h7A68,
16h0021,
16h8011,
16h6600,
16h6023,
16h710F,
16h1D0E,
16h740A,
16h6D69,
16h7265,
16h6B31,
16h7A68,
16h0040,
16h8011,
16h6600,
16h7C0C,
16h1D24,
16h740A,
16h6D69,
16h7265,
16h6B31,
16h7A68,
16h003F,
16h8011,
16h6600,
16h6C00,
16h6010,
16h2EA2,
16h700C,
16h1D38,
16h7305,
16h656C,
16h7065,
16h8010,
16h6600,
16h6023,
16h6103,
16h8010,
16h6600,
16h6C00,
16h6010,
16h2EB0,
16h700C,
16h1D52,
16h7203,
16h676E,
16h801F,
16h6600,
16h6C00,
16h6180,
16h42F8,
16h710F,
16h1D6E,
16h7607,
16h6C62,
16h6E61,
16h3F6B,
16h8000,
16h6600,
16h6C00,
16h6110,
16h2EC4,
16h700C,
16h1D80,
16h620B,
16h6361,
16h676B,
16h6F72,
16h6E75,
16h2164,
16h800D,
16h6600,
16h6023,
16h6103,
16h800E,
16h6600,
16h6023,
16h6103,
16h800F,
16h6600,
16h6023,
16h710F,
16h1D96,
16h6704,
16h7570,
16h003F,
16h80F8,
16h6600,
16h6C00,
16h6010,
16h2EE1,
16h700C,
16h1DBC,
16h6704,
16h7570,
16h0021,
16h4EE1,
16h80F8,
16h6600,
16h6023,
16h710F,
16h1DD0,
16h7006,
16h7869,
16h6C65,
16h0021,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8001,
16h0EEB,
16h1DE2,
16h720A,
16h6365,
16h6174,
16h676E,
16h656C,
16h0021,
16h80FB,
16h6600,
16h6023,
16h6103,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8002,
16h0EEB,
16h1E08,
16h6C05,
16h6E69,
16h2165,
16h80FB,
16h6600,
16h6023,
16h6103,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8003,
16h0EEB,
16h1E42,
16h6307,
16h7269,
16h6C63,
16h2165,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8004,
16h0EEB,
16h1E76,
16h6608,
16h6963,
16h6372,
16h656C,
16h0021,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8006,
16h0EEB,
16h1EA4,
16h7409,
16h6972,
16h6E61,
16h6C67,
16h2165,
16h80F9,
16h6600,
16h6023,
16h6103,
16h80FA,
16h6600,
16h6023,
16h6103,
16h80FB,
16h6600,
16h6023,
16h6103,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8007,
16h0EEB,
16h1ED4,
16h6206,
16h696C,
16h3174,
16h0021,
16h80FE,
16h6600,
16h6023,
16h6103,
16h80FF,
16h6600,
16h6023,
16h6103,
16h80FC,
16h6600,
16h6023,
16h6103,
16h80FD,
16h6600,
16h6023,
16h6103,
16h8005,
16h0EEB,
16h1F1C,
16h620A,
16h696C,
16h3174,
16h6974,
16h656C,
16h0021,
16h80F4,
16h6600,
16h6023,
16h6103,
16h8010,
16h6A00,
16h6081,
16h80F3,
16h6600,
16h6023,
16h6103,
16h6180,
16h80F2,
16h6600,
16h6023,
16h6103,
16h6081,
16h6010,
16h2FB0,
16h710F,
16h1F4A,
16h6303,
16h2173,
16h8005,
16h80F7,
16h6600,
16h6023,
16h6103,
16h8040,
16h8000,
16h8000,
16h82F7,
16h81DF,
16h0F0A,
16h1F80,
16h6C08,
16h6C73,
16h6974,
16h656C,
16h0021,
16h80C7,
16h6600,
16h6023,
16h6103,
16h8080,
16h6A00,
16h6081,
16h80C6,
16h6600,
16h6023,
16h6103,
16h6180,
16h80C5,
16h6600,
16h6023,
16h6103,
16h6081,
16h6010,
16h2FD8,
16h710F,
16h1F9C,
16h6C0A,
16h6C73,
16h7073,
16h6972,
16h6574,
16h0021,
16h80CF,
16h6600,
16h6023,
16h6103,
16h80C9,
16h6600,
16h6023,
16h6103,
16h80CE,
16h6600,
16h6023,
16h6103,
16h80CD,
16h6600,
16h6023,
16h6103,
16h80CA,
16h6600,
16h6023,
16h6103,
16h80CB,
16h6600,
16h6023,
16h6103,
16h80CC,
16h6600,
16h6023,
16h710F,
16h1FD0,
16h6C0A,
16h6C73,
16h7075,
16h6164,
16h6574,
16h0021,
16h80CF,
16h6600,
16h6023,
16h6103,
16h80C1,
16h6600,
16h6023,
16h710F,
16h2016,
16h7508,
16h6C73,
16h6974,
16h656C,
16h0021,
16h80B7,
16h6600,
16h6023,
16h6103,
16h8080,
16h6A00,
16h6081,
16h80B6,
16h6600,
16h6023,
16h6103,
16h6180,
16h80B5,
16h6600,
16h6023,
16h6103,
16h6081,
16h6010,
16h3024,
16h710F,
16h2034,
16h750A,
16h6C73,
16h7073,
16h6972,
16h6574,
16h0021,
16h80BF,
16h6600,
16h6023,
16h6103,
16h80B9,
16h6600,
16h6023,
16h6103,
16h80BE,
16h6600,
16h6023,
16h6103,
16h80BD,
16h6600,
16h6023,
16h6103,
16h80BA,
16h6600,
16h6023,
16h6103,
16h80BB,
16h6600,
16h6023,
16h6103,
16h80BC,
16h6600,
16h6023,
16h710F,
16h2068,
16h750A,
16h6C73,
16h7075,
16h6164,
16h6574,
16h0021,
16h80BF,
16h6600,
16h6023,
16h6103,
16h80B1,
16h6600,
16h6023,
16h710F,
16h20AE,
16h760D,
16h6365,
16h6F74,
16h7672,
16h7265,
16h6574,
16h2178,
16h8089,
16h6600,
16h6023,
16h6103,
16h808A,
16h6600,
16h6023,
16h6103,
16h8087,
16h6600,
16h6023,
16h6103,
16h8088,
16h6600,
16h6023,
16h6103,
16h8086,
16h6600,
16h6023,
16h710F,
16h20CC,
16h7607,
16h6365,
16h6F74,
16h3F72,
16h808B,
16h6600,
16h6C00,
16h6010,
16h3086,
16h700C,
16h2104,
16h7607,
16h6365,
16h6F74,
16h2172,
16h5086,
16h808F,
16h6600,
16h6023,
16h6103,
16h808C,
16h6600,
16h6023,
16h6103,
16h808D,
16h6600,
16h6023,
16h6103,
16h808E,
16h6600,
16h6023,
16h6103,
16h8001,
16h808B,
16h6600,
16h6023,
16h710F,
16h211A,
16h7404,
16h7570,
16h0021,
16h80EA,
16h6600,
16h6C00,
16h6010,
16h30AB,
16h80EA,
16h6600,
16h6023,
16h710F,
16h2150,
16h7406,
16h7570,
16h7978,
16h0021,
16h80EE,
16h6600,
16h6023,
16h6103,
16h80EF,
16h6600,
16h6023,
16h6103,
16h8001,
16h10AB,
16h216A,
16h740E,
16h7570,
16h6F66,
16h6572,
16h7267,
16h756F,
16h646E,
16h0021,
16h80EB,
16h6600,
16h6023,
16h710F,
16h2188,
16h740E,
16h7570,
16h6162,
16h6B63,
16h7267,
16h756F,
16h646E,
16h0021,
16h80EC,
16h6600,
16h6023,
16h710F,
16h21A2,
16h7407,
16h7570,
16h6D65,
16h7469,
16h80ED,
16h6600,
16h6023,
16h6103,
16h8002,
16h10AB,
16h21BC,
16h7406,
16h7570,
16h7363,
16h0021,
16h8003,
16h10AB,
16h21D2,
16h7408,
16h7570,
16h7073,
16h6361,
16h0065,
16h4353,
16h10E2,
16h21E0,
16h7409,
16h7570,
16h7073,
16h6361,
16h7365,
16h8000,
16h6E13,
16h6147,
16h1102,
16h50F5,
16h6B81,
16h3108,
16h6B8D,
16h6A00,
16h6147,
16h1101,
16h6B8D,
16h710F,
16h21F0,
16h7407,
16h7570,
16h7974,
16h6570,
16h6147,
16h1113,
16h4383,
16h50E2,
16h6B81,
16h3119,
16h6B8D,
16h6A00,
16h6147,
16h1111,
16h6B8D,
16h6103,
16h710F,
16h2216,
16h7405,
16h7570,
16h242E,
16h4383,
16h110F,
16h223A,
16h7405,
16h7570,
16h722E,
16h6147,
16h441E,
16h6B8D,
16h6181,
16h42A1,
16h50FD,
16h110F,
16h2246,
16h7406,
16h7570,
16h2E75,
16h0072,
16h6147,
16h43EB,
16h4404,
16h4415,
16h6B8D,
16h6181,
16h42A1,
16h50FD,
16h110F,
16h225C,
16h7405,
16h7570,
16h2E75,
16h43EB,
16h4404,
16h4415,
16h50F5,
16h110F,
16h2278,
16h7404,
16h7570,
16h002E,
16hFE80,
16h6C00,
16h800A,
16h6503,
16h314E,
16h113F,
16h441E,
16h50F5,
16h110F,
16h228A,
16h7405,
16h7570,
16h232E,
16hFE80,
16h6C00,
16h6180,
16h4432,
16h5148,
16hFE80,
16h6023,
16h710F,
16h22A4,
16h7406,
16h7570,
16h2E75,
16h0023,
16hFE80,
16h6C00,
16h6180,
16h4432,
16h43EB,
16h4404,
16h4415,
16h50F5,
16h510F,
16hFE80,
16h6023,
16h710F,
16h22BC,
16h7407,
16h7570,
16h2E75,
16h2372,
16hFE80,
16h6C00,
16h427E,
16h427E,
16h4432,
16h6147,
16h43EB,
16h4404,
16h4415,
16h6B8D,
16h6181,
16h42A1,
16h50FD,
16h510F,
16hFE80,
16h6023,
16h710F,
16h22DE,
16h7406,
16h7570,
16h722E,
16h0023,
16hFE80,
16h6C00,
16h427E,
16h427E,
16h4432,
16h6147,
16h441E,
16h6B8D,
16h6181,
16h42A1,
16h50FD,
16h510F,
16hFE80,
16h6023,
16h710F,
16h230A,
16h7407,
16h746D,
16h6C69,
16h2165,
16h8069,
16h6600,
16h6023,
16h6103,
16h8010,
16h6A00,
16h6081,
16h8068,
16h6600,
16h6023,
16h6103,
16h6180,
16h8067,
16h6600,
16h6023,
16h6103,
16h6081,
16h6010,
16h31A2,
16h710F,
16h2332,
16h7403,
16h216D,
16h806B,
16h6600,
16h6023,
16h6103,
16h806C,
16h6600,
16h6023,
16h6103,
16h806D,
16h6600,
16h6023,
16h6103,
16h806E,
16h6600,
16h6023,
16h6103,
16h806F,
16h6600,
16h6023,
16h6103,
16h8001,
16h806A,
16h6600,
16h6023,
16h710F,
16h2364,
16h7407,
16h6D6D,
16h766F,
16h2165,
16h8065,
16h6600,
16h6C00,
16h6010,
16h31D2,
16h8066,
16h6600,
16h6023,
16h710F,
16h239C,
16h7405,
16h636D,
16h2173,
16h8065,
16h6600,
16h6C00,
16h6010,
16h31DF,
16h8009,
16h8066,
16h6600,
16h6023,
16h710F,
16h23B8,
16h740D,
16h7265,
16h696D,
16h616E,
16h736C,
16h6F68,
16h2177,
16h8001,
16h80DE,
16h6600,
16h6023,
16h710F,
16h23D4,
16h740D,
16h7265,
16h696D,
16h616E,
16h686C,
16h6469,
16h2165,
16h8000,
16h80DE,
16h6600,
16h6023,
16h710F

        , pad(uninitialized)
    };

    // Setup Memory Mapped I/O
    memmap_io IO_Map
        <@clock_50mhz,!reset>
    (
        leds :> leds,
        btns <: btns,

        // UART
        uart_tx :> uart_tx,
        uart_rx <: uart_rx,

        // AUDIO
        audio_l :> audio_l,
        audio_r :> audio_r,

        // VGA/HDMI
        video_r :> video_r,
        video_g :> video_g,
        video_b :> video_b,
        vblank <: vblank,
        pix_active <: pix_active,
        pix_x <: pix_x,
        pix_y <: pix_y,

        // CLOCKS
        clock_50mhz <: clock_50mhz,
        clock_25mhz <: clock,
        video_clock <:video_clock,
        video_reset <: video_reset,

        // Memory Address/Data
        memoryAddress <: stackTop,
        writeData <: stackNext
    );

    // RAM is read via port 0, written via port 1
    ram.wenable1 := 1;

    // Setup addresses for the dstack and rstack
    // Read via port 0, write via port 1
    dstack.addr0 := dsp;
    dstack.wenable1 := 1;
    rstack.addr0 := rsp;
    rstack.wenable1 := 1;

    // IO Map Read / Write Flags
    IO_Map.memoryWrite := 0;
    IO_Map.memoryRead := 0;


    // Set initial write to top of memory
    ram.addr1 = 16383;
    ram.wdata1 = 0;

    // EXECUTE J1 CPU
    while( 1 ) {
        // FETCH INSTRUCTION
        ram.addr0 = pc;
        ++:
        instruction = ram.rdata0;
        ram.addr0 = stackTop >> 1;
        ++:

        // J1 CPU Instruction Execute
        if(is_lit) {
            // LITERAL Push value onto stack
            newStackTop = immediate;
            newPC = pcPlusOne;
            newDSP = dsp + 1;
            newRSP = rsp;
        } else {
            switch( callbranch(instruction).is_callbranchalu ) { // BRANCH 0BRANCH CALL ALU
                case 2b11: {
                    // ALU
                    if( ~aluop(instruction).is_j1j1plus && ( aluop(instruction).operation == 4b1100 ) && stackTop[15,1] ) {
                        IO_Map.memoryRead = 1;
                    }
                    newStackTop = ALU.newStackTop;

                    // UPDATE newDSP newRSP
                    newDSP = dsp + ddelta;
                    newRSP = rsp + rdelta;
                    rstackWData = stackTop;

                    // Update PC for next instruction, return from call or next instruction
                    newPC = ( aluop(instruction).is_r2pc ) ? rStackTop >> 1 : pcPlusOne;

                    // n2memt mem[t] = n
                    if( is_n2memt && ~stackTop[15,1] ) {
                        ram.addr1 = stackTop >> 1;
                        ram.wdata1 = stackNext;
                    }
                    IO_Map.memoryWrite = is_n2memt && ( stackTop[15,1] );
                } // ALU

                default: {
                    newStackTop = CALLBRANCH.newStackTop;
                    newPC = CALLBRANCH.newPC;
                    newDSP = CALLBRANCH.newDSP;
                    newRSP = CALLBRANCH.newRSP;
                    rstackWData = pcPlusOne << 1;
                }
            }
        } // J1 CPU Instruction Execute

        ++:

        // Commit to dstack and rstack
        if( dstackWrite ) {
            dstack.addr1 = newDSP;
            dstack.wdata1 = stackTop;
        }
        if( rstackWrite ) {
            rstack.addr1 = newRSP;
            rstack.wdata1 = rstackWData;
        }

        // Update dsp, rsp, pc, stackTop
        dsp = newDSP;
        pc = newPC;
        stackTop = newStackTop;
        rsp = newRSP;

        ++:
    } // execute J1 CPU
}

algorithm j1eforthplusALU(
    input   uint16  instruction,

    input   uint8   dsp,
    input   uint8   rsp,

    input   uint16  stackTop,
    input   uint16  stackNext,
    input   uint16  rStackTop,

    input   uint16  IOmemoryRead,
    input   uint16  RAMmemoryRead,

    output! uint16  newStackTop
) <autorun> {
    while(1) {
        switch( aluop(instruction).is_j1j1plus ) {
            case 1b0: {
                switch( aluop(instruction).operation ) {
                    case 4b0000: {newStackTop = stackTop;}
                    case 4b0001: {newStackTop = stackNext;}
                    case 4b0010: {newStackTop = stackTop + stackNext;}
                    case 4b0011: {newStackTop = stackTop & stackNext;}
                    case 4b0100: {newStackTop = stackTop | stackNext;}
                    case 4b0101: {newStackTop = stackTop ^ stackNext;}
                    case 4b0110: {newStackTop = ~stackTop;}
                    case 4b0111: {newStackTop = {16{(stackNext == stackTop)}};}
                    case 4b1000: {newStackTop = {16{(__signed(stackNext) < __signed(stackTop))}};}
                    case 4b1001: {newStackTop = stackNext >> nibbles(stackTop).nibble0;}
                    case 4b1010: {newStackTop = stackTop - 1;}
                    case 4b1011: {newStackTop = rStackTop;}
                    case 4b1100: {newStackTop = stackTop[15,1] ? IOmemoryRead : RAMmemoryRead;}
                    case 4b1101: {newStackTop = stackNext << nibbles(stackTop).nibble0;}
                    case 4b1110: {newStackTop = {rsp, dsp};}
                    case 4b1111: {newStackTop = {16{(__unsigned(stackNext) < __unsigned(stackTop))}};}
                }
            }

            case 1b1: {
                // Extra J1+ CPU Operations
                switch( aluop(instruction).operation ) {
                        case 4b0000: {newStackTop = {16{(stackTop == 0)}};}
                    case 4b0001: {newStackTop = {16{(stackTop != 0)}};}
                    case 4b0010: {newStackTop = {16{(stackNext != stackTop)}};}
                    case 4b0011: {newStackTop = stackTop + 1;}
                    case 4b0100: {newStackTop = stackNext * stackTop;}
                    case 4b0101: {newStackTop = stackTop << 1;}
                    case 4b0110: {newStackTop = -stackTop;}
                    case 4b0111: {newStackTop = { stackTop[15,1], stackTop[1,15]}; }
                    case 4b1000: {newStackTop = stackNext - stackTop;}
                    case 4b1001: {newStackTop = {16{(__signed(stackTop) < __signed(0))}};}
                    case 4b1010: {newStackTop = {16{(__signed(stackTop) > __signed(0))}};}
                    case 4b1011: {newStackTop = {16{(__signed(stackNext) > __signed(stackTop))}};}
                    case 4b1100: {newStackTop = {16{(__signed(stackNext) >= __signed(stackTop))}};}
                    case 4b1101: {newStackTop = ( __signed(stackTop) < __signed(0) ) ?  -stackTop : stackTop;}
                    case 4b1110: {newStackTop = ( __signed(stackNext) > __signed(stackTop) ) ? stackNext : stackTop;}
                    case 4b1111: {newStackTop = ( __signed(stackNext) < __signed(stackTop) ) ? stackNext : stackTop;}
                }
            }
        } // ALU Operation
    }
}

algorithm j1eforthcallbranch(
    input   uint2   is_callbranchalu,
    input   uint16  stackTop,
    input   uint16  stackNext,
    input   uint13  callBranchAddress,
    input   uint13  pcPlusOne,
    input   uint8   dsp,
    input   uint8   rsp,

    output! uint16  newStackTop,
    output! uint13  newPC,
    output! uint8   newDSP,
    output! uint8   newRSP,
) <autorun> {
    while(1) {
        // ONLY TRIGGER IF CALL BRANCH 0BRANCH
        switch( is_callbranchalu ) {
            case 2b00: {
                // BRANCH
                newStackTop = stackTop;
                newPC = callBranchAddress;
                newDSP = dsp;
                newRSP = rsp;
            }
            case 2b01: {
                // 0BRANCH
                newStackTop = stackNext;
                newPC = ( stackTop == 0 ) ? callBranchAddress : pcPlusOne;
                newDSP = dsp - 1;
                newRSP = rsp;
            }
            case 2b10: {
                // CALL
                newStackTop = stackTop;
                newPC = callBranchAddress;
                newDSP = dsp;
                newRSP = rsp + 1;
            }
        }
    }
}


